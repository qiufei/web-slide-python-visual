<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>信息技术基础 📊</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<link href="../https://assets.qiufei.site/personal/profile.jpg" rel="icon" type="image/jpeg">
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ea72dc5fed832574809a9c94082fbbb.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-681fbf911679f9b3dbf9743eb275ba49.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-7e49aeac8059a213a463aa1a739e8272.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://qiufei.github.io"> 
<span class="menu-text">首页</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://qiufei.github.io/web-slide"> 
<span class="menu-text">课件</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">信息技术基础 📊</h1>
<p class="subtitle lead">第五章 数据分析与知识发现——一些常用的方法 💡</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="本章概述" class="level2">
<h2 class="anchored" data-anchor-id="本章概述">本章概述 🗺️</h2>
<p>本章将带你探索数据分析与知识发现的奇妙世界，我们将学习几种常用的方法，就像解锁一个个宝箱 🔑，发现数据中隐藏的秘密。主要包括：</p>
<ul>
<li>📦 <strong>分类分析 (Classification Analysis)</strong>：将数据分门别类，就像整理房间一样。</li>
<li>🔗 <strong>关联分析 (Association Analysis)</strong>：寻找数据之间的关联，就像侦探 🕵️‍♀️ 发现线索。</li>
<li>🤝 <strong>聚类分析 (Cluster Analysis)</strong>：将相似的数据聚集在一起，就像朋友们聚会 🥳。</li>
<li>📈 <strong>回归分析 (Regression Analysis)</strong>：预测未来的趋势，就像天气预报 🌤️。</li>
</ul>
<p>这些方法在金融、商业、科学研究等领域都有广泛的应用。通过学习这些方法，我们可以从数据中提取有价值的信息，并将其转化为知识，为决策提供支持。</p>
</section>
<section id="什么是数据分析" class="level2">
<h2 class="anchored" data-anchor-id="什么是数据分析">什么是数据分析？ 🤔</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>数据分析是一个<strong>迭代探索</strong>的过程。它利用<strong>统计学、机器学习</strong>等方法，对数据进行<strong>收集、清洗、转换、建模和可视化</strong>，从而发现数据中的<strong>模式、趋势、异常和关联</strong>，并对这些发现进行<strong>解释和评估</strong>。最终目的是从数据中提取有价值的信息，将其转化为知识，为决策提供支持。</p>
<p>数据分析就像一位厨师 👨‍🍳，将原始食材（数据）经过一系列处理，变成美味佳肴（知识）。</p>
</div>
</div>
</section>
<section id="数据分析与python" class="level2">
<h2 class="anchored" data-anchor-id="数据分析与python">数据分析与Python 🐍</h2>
<p>Python 是一种广泛应用于数据分析的编程语言，它就像一把瑞士军刀 🛠️，功能强大，方便实用。它具有以下优点：</p>
<ul>
<li><strong>易于学习和使用</strong>: Python 语法简洁清晰，易于上手，就像搭乐高积木一样 🧱。</li>
<li><strong>丰富的库和工具</strong>: Python 拥有大量用于数据分析的库和工具，如 NumPy, Pandas, Scikit-learn, Matplotlib, Seaborn 等，可以大大提高数据分析的效率，就像拥有了各种神奇的工具 🧰。</li>
<li><strong>强大的社区支持</strong>: Python 拥有庞大的用户社区，可以提供丰富的学习资源和技术支持，就像有一个智囊团 🧠 在你身边。</li>
<li><strong>跨平台性</strong>: Python 可以在各种操作系统上运行，包括 Windows, macOS 和 Linux，就像一名旅行家 🌍，可以在不同的地方工作。</li>
</ul>
</section>
<section id="python小例子" class="level2">
<h2 class="anchored" data-anchor-id="python小例子">Python小例子 🐍</h2>
<div id="33e31f0f" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建一个 DataFrame (数据表格) 就像制作一个 Excel 表格 📊</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">'Name'</span>: [<span class="st">'Alice'</span>, <span class="st">'Bob'</span>, <span class="st">'Charlie'</span>, <span class="st">'David'</span>],</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Age'</span>: [<span class="dv">25</span>, <span class="dv">32</span>, <span class="dv">18</span>, <span class="dv">47</span>],</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">'City'</span>: [<span class="st">'New York'</span>, <span class="st">'Paris'</span>, <span class="st">'London'</span>, <span class="st">'Tokyo'</span>]}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印 DataFrame</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算平均年龄</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>average_age <span class="op">=</span> df[<span class="st">'Age'</span>].mean()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"平均年龄: </span><span class="sc">{</span>average_age<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      Name  Age      City
0    Alice   25  New York
1      Bob   32     Paris
2  Charlie   18    London
3    David   47     Tokyo
平均年龄: 30.5</code></pre>
</div>
</div>
<p>这段代码演示了如何使用 Pandas 库创建一个简单的数据表格并计算平均年龄，就像用 Excel 做简单的计算一样。</p>
<ul>
<li>首先，我们导入了<code>pandas</code>库，这是Python中用于数据分析的核心库。</li>
<li>然后，我们创建了一个字典<code>data</code>，其中包含了一些姓名、年龄和城市的数据。</li>
<li>接着，我们使用<code>pd.DataFrame(data)</code>将这个字典转换成了一个<code>DataFrame</code>对象，<code>DataFrame</code>是<code>pandas</code>中用于表示表格数据的核心数据结构。</li>
<li>最后，我们使用<code>df['Age'].mean()</code>计算了年龄这一列的平均值。</li>
</ul>
</section>
<section id="分类分析" class="level2">
<h2 class="anchored" data-anchor-id="分类分析">分类分析 🎯</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>分类是找出数据库中一组数据对象的共同特点并按照分类模式将其划分为不同的类，其目的是通过分类模型，将数据库中的数据项映射到某个给定的类别。</p>
<p>分类就像图书管理员 📚 将书籍按照主题分类，或者像垃圾分类 ♻️ 一样，将不同的物品放入不同的垃圾桶。</p>
</div>
</div>
<section id="监督学习" class="level3">
<h3 class="anchored" data-anchor-id="监督学习">监督学习 👀</h3>
<p>分类学习是一类<strong>监督学习 (Supervised Learning)</strong> 的问题。</p>
<ul>
<li><strong>监督学习</strong>: 从有标签的训练数据中学习模型，然后对未知数据进行预测。
<ul>
<li><strong>训练数据</strong>: 包含特征和标签的数据集，就像一本带有答案的练习册 📖。</li>
<li><strong>标签</strong>: 数据的类别或目标值，就像练习册中的答案 ✅。</li>
</ul></li>
<li>常见的监督学习任务：
<ul>
<li><strong>分类 (Classification)</strong>: 预测离散的类别标签，就像判断一张图片是猫 🐱 还是狗 🐶。</li>
<li><strong>回归 (Regression)</strong>: 预测连续的目标值，就像预测明天的气温 🌡️。</li>
</ul></li>
</ul>
</section>
<section id="监督学习举例说明" class="level3">
<h3 class="anchored" data-anchor-id="监督学习举例说明">监督学习：举例说明 📝</h3>
<p>假设我们有一组鸢尾花的数据，每朵花都有花萼长度、花萼宽度、花瓣长度、花瓣宽度四个特征，并且知道每朵花属于哪个品种（山鸢尾、变色鸢尾、维吉尼亚鸢尾）。</p>
<ul>
<li><strong>特征</strong>: 花萼长度、花萼宽度、花瓣长度、花瓣宽度</li>
<li><strong>标签</strong>: 山鸢尾、变色鸢尾、维吉尼亚鸢尾</li>
</ul>
<p>我们的目标是训练一个模型，能够根据花的特征预测花的品种。这就是一个典型的监督学习中的分类问题。</p>
</section>
<section id="分类问题的类型" class="level3">
<h3 class="anchored" data-anchor-id="分类问题的类型">分类问题的类型 🗂️</h3>
<p>根据分类结果可以分为：</p>
<ul>
<li><strong>二分类问题 (Binary Classification)</strong>: 是与非的判断，分类结果为两类，从中选择一个作为预测结果。例如：判断一封邮件是否为垃圾邮件 📧🚫。</li>
<li><strong>多分类问题 (Multi-class Classification)</strong>: 分类结果为多个类别，从中选择一个作为预测结果。例如：识别一张图片中的动物是猫 🐱、狗 🐶、鸟 🐦 还是兔子 🐰。</li>
<li><strong>多标签分类问题 (Multi-label Classification)</strong>: 不同于前两者，多标签分类问题一个样本的预测结果可能是多个，或者有多个标签。例如：一部电影可以同时被分为动作片 🎬 和犯罪片 🔪，一则新闻可以同时属于政治 🏛️ 和法律 ⚖️ 等。</li>
</ul>
</section>
</section>
<section id="分类分析常用算法---概览" class="level2">
<h2 class="anchored" data-anchor-id="分类分析常用算法---概览">分类分析常用算法 ⚙️- 概览</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 30%">
<col style="width: 24%">
<col style="width: 15%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>逻辑回归</td>
<td>基于线性模型，使用Logistic函数将输出映射到[0,1]区间</td>
<td>模型简单，可解释性强，计算效率高</td>
<td>对非线性关系拟合能力有限</td>
<td>信用风险评估、疾病诊断、客户流失预测</td>
</tr>
<tr class="even">
<td>线性判别分析</td>
<td>将数据投影到一条直线上，使得同类样本尽可能接近，异类样本尽可能远离</td>
<td>计算效率高，对数据分布有一定的鲁棒性</td>
<td>对非线性关系拟合能力有限，对异常值敏感</td>
<td>人脸识别、手写数字识别</td>
</tr>
<tr class="odd">
<td>支持向量机</td>
<td>找到一个最优超平面，将不同类别的样本分隔开，并最大化间隔</td>
<td>对高维数据和非线性关系有较好的处理能力，具有较好的泛化性能</td>
<td>对大规模数据集计算复杂度较高，对参数和核函数选择敏感</td>
<td>文本分类、图像识别</td>
</tr>
<tr class="even">
<td>决策树</td>
<td>基于树结构进行决策，通过一系列的if-else规则进行分类</td>
<td>模型易于理解和解释，可以处理非线性关系，对缺失值不敏感</td>
<td>容易过拟合，对数据中的噪声敏感</td>
<td>客户细分、医疗诊断</td>
</tr>
<tr class="odd">
<td>K邻近</td>
<td>基于距离度量，找到与待分类样本最近的k个邻居，根据邻居的类别进行投票</td>
<td>无需训练，实现简单</td>
<td>计算复杂度较高，对k值选择敏感，对数据分布敏感</td>
<td>推荐系统、异常检测</td>
</tr>
<tr class="even">
<td>朴素贝叶斯</td>
<td>基于贝叶斯定理和特征条件独立假设，计算样本属于每个类别的概率，选择概率最大的类别</td>
<td>计算效率高，对缺失数据不敏感</td>
<td>特征条件独立假设在实际中往往不成立</td>
<td>垃圾邮件过滤、情感分析</td>
</tr>
</tbody>
</table>
</section>
<section id="逻辑回归-logistic-regression" class="level2">
<h2 class="anchored" data-anchor-id="逻辑回归-logistic-regression">逻辑回归 (Logistic Regression) 🧠</h2>
<section id="概念解释" class="level3">
<h3 class="anchored" data-anchor-id="概念解释">概念解释 🤓</h3>
<ul>
<li><p><strong>线性关系</strong>: 特征与分类结果之间的关系可以用线性方程表示，就像我们可以用一条直线 📏 来近似描述身高和体重的关系。</p>
<ul>
<li>线性方程：<span class="math inline">\(y = wx + b\)</span></li>
<li>其中，<span class="math inline">\(w\)</span> 是权重向量，<span class="math inline">\(x\)</span> 是特征向量，<span class="math inline">\(b\)</span> 是偏置项。</li>
</ul></li>
<li><p><strong>实数域</strong>: 所有实数的集合，就像一条无限延伸的数轴 ↔︎️。</p></li>
<li><p><strong>{0, 1} 空间</strong>: 只有 0 和 1 两个值的集合，就像一个开关 💡，只有开和关两种状态。</p></li>
<li><p><strong>Logistic 函数</strong>: 一种 S 形函数，可以将实数映射到 (0, 1) 区间，就像一个魔法 🧙‍♀️，将任何数字变成 0 到 1 之间的数字。</p></li>
</ul>
</section>
<section id="logistic-函数" class="level3">
<h3 class="anchored" data-anchor-id="logistic-函数">Logistic 函数 📝</h3>
<p><span class="math display">\[
\sigma(z) = \frac{1}{1 + e^{-z}}
\]</span></p>
<ul>
<li><span class="math inline">\(z\)</span>: 线性方程的结果 (<span class="math inline">\(z = wx + b\)</span>)</li>
<li><span class="math inline">\(e\)</span>: 自然对数的底数 (约等于 2.718)</li>
<li><span class="math inline">\(\sigma(z)\)</span>: 介于 0 和 1 之间的概率值</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Logistic函数图像
</div>
</div>
<div class="callout-body-container callout-body">
<div id="cell-fig-logistic" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">100</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>z))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>plt.plot(z, sigma)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"z"</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"$\sigma(z)$"</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Logistic Function"</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>&lt;&gt;:10: SyntaxWarning: invalid escape sequence '\s'
&lt;&gt;:10: SyntaxWarning: invalid escape sequence '\s'
/tmp/ipykernel_2705/2242896298.py:10: SyntaxWarning: invalid escape sequence '\s'
  plt.ylabel("$\sigma(z)$")</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-logistic" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-logistic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="chapter6_files/figure-html/fig-logistic-output-2.png" width="664" height="523" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-logistic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Logistic函数图像
</figcaption>
</figure>
</div>
</div>
</div>
<p>从图中可以看出，Logistic函数将任意实数映射到 (0, 1) 区间，当 <span class="math inline">\(z\)</span> 趋近于正无穷时，<span class="math inline">\(\sigma(z)\)</span> 趋近于 1；当 <span class="math inline">\(z\)</span> 趋近于负无穷时，<span class="math inline">\(\sigma(z)\)</span> 趋近于 0。</p>
</div>
</div>
</section>
<section id="逻辑回归的优点" class="level3">
<h3 class="anchored" data-anchor-id="逻辑回归的优点">逻辑回归的优点 👍</h3>
<ul>
<li>直接对分类<strong>概率</strong>进行建模，无需事先假设数据分布，就像我们可以直接估计一件事情发生的可能性，而不需要知道事情发生的具体细节。</li>
<li>是一个<strong>判别模型</strong> (Discriminative Model)。
<ul>
<li><strong>判别模型</strong>: 直接学习预测模型，例如逻辑回归，就像我们直接学习如何区分猫 🐱 和狗 🐶，而不需要知道猫和狗是如何产生的。</li>
<li><strong>生成模型</strong> (Generative Model): 学习数据的联合分布，然后进行预测，例如朴素贝叶斯，就像我们先学习猫和狗的各种特征，然后根据这些特征来判断一个动物是猫还是狗。</li>
</ul></li>
<li>Logistic 函数是<strong>任意阶可导凸函数</strong>，可以使用许多数学优化算法，就像我们可以用各种工具 🛠️ 来打磨一块玉石 💎。</li>
</ul>
</section>
</section>
<section id="线性判别分析-linear-discriminant-analysis-lda" class="level2">
<h2 class="anchored" data-anchor-id="线性判别分析-linear-discriminant-analysis-lda">线性判别分析 (Linear Discriminant Analysis, LDA) 📐</h2>
<section id="lda-的核心思想" class="level3">
<h3 class="anchored" data-anchor-id="lda-的核心思想">LDA 的核心思想 💡</h3>
<ul>
<li>将训练样本投影到一条直线上，使得：
<ul>
<li><strong>同类样本</strong>的投影点尽可能<strong>接近</strong>，就像让好朋友们 🤝 站得近一些。</li>
<li><strong>异类样本</strong>的投影点尽可能<strong>远离</strong>，就像让陌生人 🧍 保持距离。</li>
<li>协方差尽可能小。</li>
</ul></li>
</ul>
</section>
<section id="投影" class="level3">
<h3 class="anchored" data-anchor-id="投影">投影 📐</h3>
<ul>
<li>假设有一条直线 <span class="math inline">\(l\)</span>，我们可以将任意一个点 <span class="math inline">\(x\)</span> 投影到这条直线上，得到投影点 <span class="math inline">\(x'\)</span>。</li>
<li>投影的过程可以用向量内积来表示：<span class="math inline">\(x' = w^Tx\)</span>，其中 <span class="math inline">\(w\)</span> 是直线的方向向量。</li>
</ul>
</section>
<section id="目标函数" class="level3">
<h3 class="anchored" data-anchor-id="目标函数">目标函数 🎯</h3>
<p>LDA 的目标是最大化类间距离，最小化类内距离。可以通过数学公式推导出 LDA 的目标函数，就像我们可以用公式来计算投篮 🏀 的最佳角度。</p>
<ul>
<li><strong>类间距离</strong>: 不同类别样本的投影点之间的距离。</li>
<li><strong>类内距离</strong>: 同一类别样本的投影点之间的距离。</li>
<li><strong>目标函数</strong>: <span class="math inline">\(\frac{w^TS_bw}{w^TS_ww}\)</span>
<ul>
<li><span class="math inline">\(S_b\)</span>: 类间散度矩阵</li>
<li><span class="math inline">\(S_w\)</span>: 类内散度矩阵</li>
</ul></li>
</ul>
</section>
</section>
<section id="支持向量机-support-vector-machine-svm" class="level2">
<h2 class="anchored" data-anchor-id="支持向量机-support-vector-machine-svm">支持向量机 (Support Vector Machine, SVM) 🛡️</h2>
<section id="svm-的基本思想" class="level3">
<h3 class="anchored" data-anchor-id="svm-的基本思想">SVM 的基本思想</h3>
<ul>
<li>基于训练集在样本空间中找到一个<strong>超平面</strong>可以将不同类别的样本分开,就像用一把刀 🔪 将苹果 🍎 和橙子 🍊 分开。</li>
<li>并且使得所有的数据点都尽可能的远离超平面</li>
<li>如何找到一个最优的超平面以及最优超平面如何定义是支持向量机需要解决的问题。</li>
<li>我们所需要寻找的超平面应该对样本局部扰动的“容忍性”最好,即结果对于未知样本的预测更加准确。</li>
</ul>
</section>
<section id="核心概念" class="level3">
<h3 class="anchored" data-anchor-id="核心概念">核心概念 🤓</h3>
<ul>
<li><strong>超平面 (Hyperplane)</strong>: 在高维空间中，将数据划分为两部分的平面，就像在二维空间中，用一条直线将平面分成两部分。
<ul>
<li>方程：<span class="math inline">\(w \cdot x + b = 0\)</span></li>
<li><span class="math inline">\(w\)</span>: 法向量，决定超平面的方向，就像指南针 🧭 指引方向。</li>
<li><span class="math inline">\(b\)</span>: 位移项，决定超平面与原点之间的距离，就像调整刀 🔪 的位置。</li>
</ul></li>
<li><strong>函数间隔 (Functional Margin)</strong>: <span class="math inline">\(\gamma' = y(w \cdot x + b)\)</span>
<ul>
<li><span class="math inline">\(y\)</span>: 样本的真实类别 (+1 或 -1)，就像标签 🏷️。</li>
<li><span class="math inline">\(w \cdot x + b\)</span>: 样本点到超平面的“距离”，就像测量距离 📏。</li>
<li>函数间隔的符号表示分类是否正确，大小表示确信度，就像考试分数 💯，越高越好。</li>
</ul></li>
<li><strong>几何间隔 (Geometric Margin)</strong>: <span class="math inline">\(\gamma = \frac{y(w \cdot x + b)}{||w||_2}\)</span>
<ul>
<li>几何间隔是点到超平面的真实距离，就像用尺子 📏 测量距离。</li>
<li><span class="math inline">\(||w||_2\)</span>: 向量 <span class="math inline">\(w\)</span> 的 L2 范数（模长），就像计算向量的长度。</li>
<li><strong>支持向量 (Support Vectors)</strong>: 距离超平面最近的几个训练样本点，就像支撑起整个分类的士兵 💂‍♀️💂。</li>
</ul></li>
</ul>
</section>
<section id="支持向量的作用" class="level3">
<h3 class="anchored" data-anchor-id="支持向量的作用">支持向量的作用</h3>
<ul>
<li>支持向量决定了超平面的位置和方向。</li>
<li>只有支持向量对模型起作用，其他样本点可以被忽略。</li>
</ul>
</section>
<section id="svm-的优化目标" class="level3">
<h3 class="anchored" data-anchor-id="svm-的优化目标">SVM 的优化目标 🎯</h3>
<ul>
<li><strong>目标</strong>: 最大化几何间隔，就像让苹果和橙子之间的距离最大。</li>
<li><strong>约束</strong>: 所有样本点都被正确分类，且位于支持向量定义的间隔之外，就像确保每个水果 🍏🍊 都被分到正确的类别。</li>
<li><strong>数学表达</strong>: <span class="math display">\[
\max_{\mathbf{w}, b} \frac{2}{\|\mathbf{w}\|} \\
\text{s.t.} \quad y_i(\mathbf{w}^T\mathbf{x}_i + b) \geq 1, \quad i=1,2,\ldots,m.
\]</span></li>
<li><strong>对偶问题</strong>: 通过拉格朗日乘子法，可以将上述优化问题转化为对偶问题，更高效地求解，就像用更巧妙的方法解决问题。</li>
</ul>
</section>
<section id="svm-图示" class="level3">
<h3 class="anchored" data-anchor-id="svm-图示">SVM 图示 🖼️</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/svm.png" class="img-fluid figure-img"></p>
<figcaption>SVM 图示</figcaption>
</figure>
</div>
<ul>
<li><strong>实线</strong>: 超平面，就像刀 🔪。</li>
<li><strong>虚线</strong>: 间隔边界，就像安全线 🚧。</li>
<li><strong>圆圈和叉</strong>: 不同类别的样本，就像苹果 🍎 和橙子 🍊。</li>
<li><strong>带箭头的虚线</strong>: 支持向量到超平面的距离，就像测量距离 📏。</li>
</ul>
<p><strong>图示解释 (1/4)</strong></p>
<ul>
<li><strong>实线</strong>: 这是我们希望找到的最优超平面，它能够将不同类别的样本分隔开。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/svm.png" class="img-fluid figure-img"></p>
<figcaption>SVM 图示</figcaption>
</figure>
</div>
<p><strong>图示解释 (2/4)</strong></p>
<ul>
<li><strong>虚线</strong>: 这两条虚线是间隔边界，它们与超平面平行，并且距离超平面的距离相等。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/svm.png" class="img-fluid figure-img"></p>
<figcaption>SVM 图示</figcaption>
</figure>
</div>
<p><strong>图示解释 (3/4)</strong></p>
<ul>
<li><strong>圆圈和叉</strong>: 这些是不同类别的样本点，我们的目标是将它们分隔开。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/svm.png" class="img-fluid figure-img"></p>
<figcaption>SVM 图示</figcaption>
</figure>
</div>
<p><strong>图示解释 (4/4)</strong></p>
<ul>
<li><strong>带箭头的虚线</strong>: 这些虚线表示支持向量到超平面的距离，支持向量是距离超平面最近的样本点，它们决定了超平面的位置和方向。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/svm.png" class="img-fluid figure-img"></p>
<figcaption>SVM 图示</figcaption>
</figure>
</div>
</section>
</section>
<section id="决策树-decision-tree" class="level2">
<h2 class="anchored" data-anchor-id="决策树-decision-tree">决策树 (Decision Tree) 🌳</h2>
<section id="决策树的核心思想" class="level3">
<h3 class="anchored" data-anchor-id="决策树的核心思想">决策树的核心思想 💡</h3>
<ul>
<li>决策树是一种<strong>树形结构</strong>，用于模拟人类的决策过程，就像一棵有许多分叉的树 🌳。</li>
<li>通过一系列的<strong>问题 (特征)</strong>，对样本进行分类，就像玩“猜猜我是谁”的游戏 🕵️‍♀️。</li>
<li><strong>节点</strong>:
<ul>
<li><strong>内部节点</strong>: 表示一个特征或属性，就像一个问题 🤔。</li>
<li><strong>叶节点</strong>: 表示一个类别，就像一个答案 ✅。</li>
</ul></li>
<li><strong>分支</strong>: 表示特征的取值，就像不同的选择 ➡️。</li>
</ul>
</section>
<section id="决策树示例信用卡申请" class="level3">
<h3 class="anchored" data-anchor-id="决策树示例信用卡申请">决策树示例：信用卡申请 💳</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/decision_tree.png" class="img-fluid figure-img"></p>
<figcaption>决策树示例</figcaption>
</figure>
</div>
<ul>
<li><strong>问题</strong>: 是否批准信用卡申请？</li>
</ul>
<p><strong>决策树示例：信用卡申请 💳 (1/5)</strong></p>
<ul>
<li><strong>根节点</strong>: 第一个问题是“年龄”，根据年龄将申请人分为不同的组。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/decision_tree.png" class="img-fluid figure-img"></p>
<figcaption>决策树示例</figcaption>
</figure>
</div>
<p><strong>决策树示例：信用卡申请 💳 (2/5)</strong></p>
<ul>
<li><strong>分支</strong>:
<ul>
<li>如果年龄 &lt;= 30，进入左侧分支。</li>
<li>如果年龄 &gt; 30，进入右侧分支。</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/decision_tree.png" class="img-fluid figure-img"></p>
<figcaption>决策树示例</figcaption>
</figure>
</div>
<p><strong>决策树示例：信用卡申请 💳 (3/5)</strong></p>
<ul>
<li><strong>内部节点</strong>: 在左侧分支，下一个问题是“是否有房产”。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/decision_tree.png" class="img-fluid figure-img"></p>
<figcaption>决策树示例</figcaption>
</figure>
</div>
<p><strong>决策树示例：信用卡申请 💳 (4/5)</strong></p>
<ul>
<li><strong>内部节点</strong>: 在右侧分支，下一个问题是“是否有固定工作”。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/decision_tree.png" class="img-fluid figure-img"></p>
<figcaption>决策树示例</figcaption>
</figure>
</div>
<p><strong>决策树示例：信用卡申请 💳 (5/5)</strong></p>
<ul>
<li><strong>叶节点</strong>:
<ul>
<li>“批准”：表示批准信用卡申请。</li>
<li>“拒绝”：表示拒绝信用卡申请。</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/decision_tree.png" class="img-fluid figure-img"></p>
<figcaption>决策树示例</figcaption>
</figure>
</div>
</section>
</section>
<section id="k-邻近-k-nearest-neighbors-knn" class="level2">
<h2 class="anchored" data-anchor-id="k-邻近-k-nearest-neighbors-knn">K 邻近 (K-Nearest Neighbors, KNN) 🏘️</h2>
<section id="knn-的工作机制" class="level3">
<h3 class="anchored" data-anchor-id="knn-的工作机制">KNN 的工作机制 ⚙️</h3>
<ul>
<li>给定测试样本，计算它与训练集中每个样本的距离，就像测量你和每个邻居 🧍🧍‍♀️ 的距离。</li>
<li>找出距离最近的 <em>k</em> 个训练样本（<em>k</em> 个邻居），就像找到你最近的 <em>k</em> 个邻居。</li>
<li>根据这 <em>k</em> 个邻居的类别，预测测试样本的类别。
<ul>
<li><strong>多数表决</strong>: 选择 <em>k</em> 个邻居中出现次数最多的类别，就像投票 🗳️ 选出最受欢迎的邻居。</li>
<li><strong>加权表决</strong>: 根据距离的远近，对 <em>k</em> 个邻居的投票进行加权，就像给更近的邻居更多的投票权 ⚖️。</li>
</ul></li>
</ul>
</section>
<section id="knn-的关键因素" class="level3">
<h3 class="anchored" data-anchor-id="knn-的关键因素">KNN 的关键因素 🤔</h3>
<ul>
<li><strong>k 值的选择</strong>:
<ul>
<li><em>k</em> 值过小，容易受噪声影响，就像只听一个邻居的意见，可能会被误导。</li>
<li><em>k</em> 值过大，容易受不相关样本影响，就像听太多人的意见，会变得犹豫不决。</li>
</ul></li>
<li><strong>距离度量</strong>:
<ul>
<li>欧氏距离 (Euclidean Distance)，就像直线距离 📏。</li>
<li>曼哈顿距离 (Manhattan Distance)，就像城市街区距离 🏙️。</li>
<li>其他距离度量。</li>
</ul></li>
</ul>
</section>
<section id="knn-的特点" class="level3">
<h3 class="anchored" data-anchor-id="knn-的特点">KNN 的特点 👍</h3>
<ul>
<li><strong>懒惰学习 (Lazy Learning)</strong>: 无需训练，直接使用训练集进行预测，就像“临时抱佛脚” 📖。</li>
<li><strong>急切学习 (Eager Learning)</strong>: 需要在训练阶段对样本进行处理，就像“未雨绸缪” ☔️。</li>
</ul>
</section>
<section id="knn-算法示例" class="level3">
<h3 class="anchored" data-anchor-id="knn-算法示例">KNN 算法示例 🍎🍊</h3>
<p>假设我们有一些水果的数据，包括水果的重量和颜色，以及水果的种类（苹果或橙子）。</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>重量 (克)</th>
<th>颜色 (0-1)</th>
<th>种类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>150</td>
<td>0.8</td>
<td>苹果</td>
</tr>
<tr class="even">
<td>180</td>
<td>0.9</td>
<td>苹果</td>
</tr>
<tr class="odd">
<td>200</td>
<td>0.5</td>
<td>橙子</td>
</tr>
<tr class="even">
<td>220</td>
<td>0.4</td>
<td>橙子</td>
</tr>
</tbody>
</table>
<p>现在有一个新的水果，重量为 170 克，颜色为 0.7，我们想用 KNN 算法来预测它是苹果还是橙子。</p>
<ul>
<li><strong>计算距离</strong>:
<ul>
<li>假设我们使用欧氏距离：
<ul>
<li>距离第 1 个样本：<span class="math inline">\(\sqrt{(170-150)^2 + (0.7-0.8)^2} \approx 20.02\)</span></li>
<li>距离第 2 个样本：<span class="math inline">\(\sqrt{(170-180)^2 + (0.7-0.9)^2} \approx 10.02\)</span></li>
<li>距离第 3 个样本：<span class="math inline">\(\sqrt{(170-200)^2 + (0.7-0.5)^2} \approx 30.07\)</span></li>
<li>距离第 4 个样本：<span class="math inline">\(\sqrt{(170-220)^2 + (0.7-0.4)^2} \approx 50.09\)</span></li>
</ul></li>
</ul></li>
<li><strong>选择 k 值</strong>:
<ul>
<li>假设我们选择 <span class="math inline">\(k=3\)</span>，即选择最近的 3 个邻居。</li>
</ul></li>
<li><strong>多数表决</strong>:
<ul>
<li>最近的 3 个邻居是：第 2 个样本（苹果）、第 1 个样本（苹果）、第 3 个样本（橙子）。</li>
<li>苹果的票数：2，橙子的票数：1。</li>
<li>因此，预测新水果为苹果。</li>
</ul></li>
</ul>
</section>
</section>
<section id="朴素贝叶斯-naive-bayes" class="level2">
<h2 class="anchored" data-anchor-id="朴素贝叶斯-naive-bayes">朴素贝叶斯 (Naive Bayes) 🍀</h2>
<section id="贝叶斯定理-bayes-theorem" class="level3">
<h3 class="anchored" data-anchor-id="贝叶斯定理-bayes-theorem">贝叶斯定理 (Bayes’ Theorem) 🤓</h3>
<p><span class="math display">\[
P(B|A) = \frac{P(A|B)P(B)}{P(A)}
\]</span></p>
<ul>
<li><span class="math inline">\(P(B|A)\)</span>: 后验概率 (Posterior Probability)，就像在知道一些信息后，对事件发生的可能性的重新评估。</li>
<li><span class="math inline">\(P(A|B)\)</span>: 似然概率 (Likelihood)，就像事件发生后，观察到某些现象的可能性。</li>
<li><span class="math inline">\(P(B)\)</span>: 先验概率 (Prior Probability)，就像在没有任何信息的情况下，对事件发生的可能性的初步估计。</li>
<li><span class="math inline">\(P(A)\)</span>: 证据 (Evidence)，就像观察到的现象。</li>
</ul>
</section>
<section id="贝叶斯定理例子" class="level3">
<h3 class="anchored" data-anchor-id="贝叶斯定理例子">贝叶斯定理：例子 🌰</h3>
<p>假设一个学校里有 60% 的男生和 40% 的女生。女生穿裤子和裙子的概率相等，都是 50%；男生都穿裤子。一个人在远处走来，我们只能看到他/她穿了一条裤子，求这个人是女生的概率。</p>
<ul>
<li>事件 A: 观察到穿裤子</li>
<li>事件 B: 这个人是女生</li>
<li><span class="math inline">\(P(B)\)</span>: 女生的先验概率 (40%)</li>
<li><span class="math inline">\(P(A)\)</span>: 穿裤子的概率 (60% * 100% + 40% * 50% = 80%)</li>
<li><span class="math inline">\(P(A|B)\)</span>: 女生穿裤子的概率 (50%)</li>
<li><span class="math inline">\(P(B|A)\)</span>: 穿裤子的人是女生的概率 (根据贝叶斯定理计算)</li>
</ul>
<p><span class="math display">\[
P(B|A) = \frac{P(A|B)P(B)}{P(A)} = \frac{0.5 \times 0.4}{0.8} = 0.25
\]</span></p>
</section>
<section id="朴素贝叶斯分类器" class="level3">
<h3 class="anchored" data-anchor-id="朴素贝叶斯分类器">朴素贝叶斯分类器 🤖</h3>
<ul>
<li><strong>生成模型</strong>: 学习特征 <em>X</em> 和类别 <em>Y</em> 的联合分布 <em>P(X, Y)</em>，就像先了解猫 🐱 和狗 🐶 的各种特征。</li>
<li><strong>预测</strong>: 计算条件概率 <em>P(Y|X) = P(X, Y) / P(X)</em>，就像根据观察到的特征，判断是猫还是狗。</li>
<li><strong>朴素 (Naive)</strong>: 假设特征之间相互独立，就像认为猫的颜色和体重之间没有关系，这在现实中可能不成立，但可以让计算更简单。</li>
</ul>
</section>
<section id="朴素贝叶斯分类器例子" class="level3">
<h3 class="anchored" data-anchor-id="朴素贝叶斯分类器例子">朴素贝叶斯分类器：例子 📧</h3>
<p>假设我们要判断一封邮件是否为垃圾邮件。</p>
<ul>
<li>特征：邮件中出现的词语（“免费”、“优惠”、“发票”等）</li>
<li>类别：垃圾邮件、非垃圾邮件</li>
<li><strong>朴素假设</strong>：假设每个词语的出现都是独立的，即一个词语的出现与其他词语的出现无关。</li>
</ul>
<p>我们可以根据训练数据（已标注的垃圾邮件和非垃圾邮件）来计算：</p>
<ul>
<li><span class="math inline">\(P(Y)\)</span>: 垃圾邮件和非垃圾邮件的先验概率</li>
<li><span class="math inline">\(P(X|Y)\)</span>: 在垃圾邮件和非垃圾邮件中，每个词语出现的概率</li>
</ul>
<p>然后，对于一封新的邮件，我们可以根据贝叶斯定理计算它是垃圾邮件的概率：</p>
<p><span class="math display">\[
P(垃圾邮件|邮件内容) = \frac{P(邮件内容|垃圾邮件)P(垃圾邮件)}{P(邮件内容)}
\]</span></p>
</section>
</section>
<section id="关联分析-association-analysis" class="level2">
<h2 class="anchored" data-anchor-id="关联分析-association-analysis">关联分析 (Association Analysis) 🔗</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>关联规则是描述数据库中数据项之间所存在的关系的规则，即根据一个事务中某些项的出现可导出另一些项在同一事务中也出现，即隐藏在数据间的关联或相互关系。</p>
<p>关联分析就像侦探 🕵️‍♀️ 在犯罪现场寻找线索，发现不同物品之间的关联。</p>
</div>
</div>
<section id="关联分析的应用" class="level3">
<h3 class="anchored" data-anchor-id="关联分析的应用">关联分析的应用 🛒</h3>
<ul>
<li><strong>购物篮分析</strong>: 发现顾客购买商品之间的关联规则，例如著名的“啤酒与尿布” 🍺🧷 故事。
<ul>
<li>超市发现，购买啤酒的顾客往往也会购买尿布，因此可以将啤酒和尿布放在一起促销。</li>
</ul></li>
<li><strong>其他应用</strong>: 医疗诊断 🩺、网页浏览分析 🖱️、文本挖掘 📝 等。
<ul>
<li>医疗诊断：发现某些症状与某种疾病之间的关联。</li>
<li>网页浏览分析：发现用户经常同时访问的网页。</li>
<li>文本挖掘：发现文章中经常同时出现的词语。</li>
</ul></li>
</ul>
</section>
<section id="关联规则的定义" class="level3">
<h3 class="anchored" data-anchor-id="关联规则的定义">关联规则的定义 🤓</h3>
<ul>
<li><strong>项集 (Itemset)</strong>: 一组项目的集合，例如 {啤酒, 尿布}。
<ul>
<li>项集可以是单个项目，也可以是多个项目的组合。</li>
</ul></li>
<li><strong>事务 (Transaction)</strong>: 一次购买记录，例如 {牛奶, 面包, 啤酒, 尿布}。
<ul>
<li>事务是项集的集合。</li>
</ul></li>
<li><strong>关联规则 (Association Rule)</strong>: 形如 X → Y 的蕴含式，其中 X 和 Y 是不相交的项集。
<ul>
<li>例如: {啤酒} → {尿布}</li>
<li>X 称为前项 (antecedent)，Y 称为后项 (consequent)。</li>
</ul></li>
</ul>
</section>
<section id="关联规则的指标" class="level3">
<h3 class="anchored" data-anchor-id="关联规则的指标">关联规则的指标 📊</h3>
<ul>
<li><strong>支持度 (Support)</strong>: 项集 X 和 Y 同时出现的概率。
<ul>
<li><span class="math inline">\(Support(X \to Y) = P(X \cup Y)\)</span></li>
<li>就像计算同时购买啤酒和尿布的顾客比例。</li>
</ul></li>
<li><strong>置信度 (Confidence)</strong>: 在 X 出现的条件下，Y 出现的概率。
<ul>
<li><span class="math inline">\(Confidence(X \to Y) = P(Y|X) = \frac{P(X \cup Y)}{P(X)}\)</span></li>
<li>就像计算购买啤酒的顾客中，也购买尿布的比例。</li>
</ul></li>
<li><strong>例子</strong>: 假设有 100 个顾客，其中：
<ul>
<li>15 个顾客同时购买了啤酒和尿布。</li>
<li>30 个顾客购买了啤酒。</li>
<li>那么：
<ul>
<li>Support({啤酒} → {尿布}) = 15/100 = 15%</li>
<li>Confidence({啤酒} → {尿布}) = 15/30 = 50%</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="关联规则的指标-续" class="level3">
<h3 class="anchored" data-anchor-id="关联规则的指标-续">关联规则的指标 (续) 📈</h3>
<ul>
<li><strong>期望置信度 (Expected Confidence)</strong>: Y 单独出现的概率。
<ul>
<li><span class="math inline">\(Expected Confidence(X \to Y) = P(Y)\)</span></li>
<li>就像计算所有顾客中，购买尿布的比例。</li>
</ul></li>
<li><strong>提升度 (Lift)</strong>: 置信度与期望置信度的比值。
<ul>
<li><span class="math inline">\(Lift(X \to Y) = \frac{Confidence(X \to Y)}{Expected Confidence(X \to Y)} = \frac{P(Y|X)}{P(Y)} = \frac{P(X \cup Y)}{P(X)P(Y)}\)</span></li>
<li>提升度反映了 X 的出现对 Y 的出现概率的影响程度，就像研究啤酒的出现是否会让尿布的销量增加。</li>
<li>Lift &gt; 1: 正相关，就像啤酒的出现会促进尿布的销量。</li>
<li>Lift = 1: 不相关，就像啤酒的出现对尿布的销量没有影响。</li>
<li>Lift &lt; 1: 负相关，就像啤酒的出现会抑制尿布的销量。</li>
</ul></li>
<li><strong>例子</strong> (续): 假设有 100 个顾客，其中：
<ul>
<li>25 个顾客购买了尿布。</li>
<li>那么：
<ul>
<li>Expected Confidence({啤酒} → {尿布}) = 25/100 = 25%</li>
<li>Lift({啤酒} → {尿布}) = 50% / 25% = 2</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="关联规则挖掘定义" class="level3">
<h3 class="anchored" data-anchor-id="关联规则挖掘定义">关联规则挖掘定义 ⛏️</h3>
<ul>
<li><strong>目标</strong>: 给定一个交易数据集 <em>T</em>，找出其中所有支持度 ≥ min_support 和置信度 ≥ min_confidence 的关联规则。
<ul>
<li>min_support: 最小支持度阈值</li>
<li>min_confidence: 最小置信度阈值</li>
</ul></li>
<li><strong>步骤</strong>:
<ol type="1">
<li><strong>生成频繁项集 (Frequent Itemset Generation)</strong>: 找出所有满足最小支持度的项集，就像找到所有经常被一起购买的商品组合。</li>
<li><strong>生成规则 (Rule Generation)</strong>: 在上一步产生的频繁项集的基础上生成满足最小置信度的规则，就像从经常被一起购买的商品组合中，找到那些具有强关联关系的组合。</li>
</ol></li>
</ul>
</section>
<section id="关联规则挖掘算法" class="level3">
<h3 class="anchored" data-anchor-id="关联规则挖掘算法">关联规则挖掘算法 ⚙️</h3>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true">Apriori 算法</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">FP-Tree 算法 🌳</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false">PrefixSpan 算法</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<ul>
<li><strong>核心思想</strong>: 基于两条定律，减少频繁项集的生成时间：
<ol type="1">
<li>如果一个项集是频繁的，则它的所有子集都是频繁的。就像如果 {啤酒, 尿布, 牛奶} 经常被一起购买，那么 {啤酒, 尿布} 也一定经常被一起购买。</li>
<li>如果一个项集是非频繁的，则它的所有超集都是非频繁的。就像如果 {薯片} 很少被购买，那么 {薯片, 啤酒} 也一定很少被一起购买。</li>
</ol></li>
<li><strong>例子</strong>:
<ul>
<li>如果 {A, B} 是频繁项集，则 {A} 和 {B} 一定是频繁项集。</li>
<li>如果 {A} 是非频繁项集，则 {A, B}, {A, C}, {A, B, C} 等一定是非频繁项集。</li>
</ul></li>
</ul>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<ul>
<li><strong>FP-Tree (Frequent Pattern Tree)</strong>: 一种树形数据结构，用于存储频繁项集的信息，就像一棵“购物树” 🌳，树上的每个节点都代表一个商品，节点之间的路径代表商品之间的关联。</li>
<li><strong>构建 FP-Tree</strong>:
<ol type="1">
<li>扫描数据集，统计每个项的支持度，就像统计每个商品的销量。</li>
<li>根据支持度对项进行排序，就像将商品按照销量从高到低排序。</li>
<li>再次扫描数据集，将每个事务中的项按照排序后的顺序插入到 FP-Tree 中，就像将每个顾客的购物清单 🛒 按照商品销量排序后，添加到“购物树”中。</li>
</ol></li>
<li><strong>挖掘 FP-Tree</strong>: 从 FP-Tree 中递归地挖掘频繁项集，就像从“购物树”中找到那些经常出现的“树枝” 🌿。</li>
</ul>
<section id="算法示例1" class="level5">
<h5 class="anchored" data-anchor-id="算法示例1">算法示例1</h5>
<p><img src="images/fptree1.png" class="img-fluid" alt="FP-Tree 示例 1"> 原始数据中，一共有10条交易数据，分别统计每个商品的支持度计数，A出现了8次，记为<code>A:8</code>，其他商品同理。</p>
</section>
<section id="算法示例1-解释" class="level5">
<h5 class="anchored" data-anchor-id="算法示例1-解释">算法示例1-解释</h5>
<p>这张图展示了FP-Tree算法的第一步：统计每个商品的支持度计数。</p>
<ul>
<li><strong>原始数据</strong>: 左侧表格是原始的交易数据，每一行代表一次交易，包含了顾客购买的商品。</li>
<li><strong>支持度计数</strong>: 右侧表格是统计结果，显示了每个商品出现的次数（支持度计数）。</li>
<li><strong>例子</strong>:
<ul>
<li>A: 8 表示商品A在所有交易中出现了8次。</li>
<li>B: 6 表示商品B在所有交易中出现了6次。</li>
</ul></li>
</ul>
</section>
<section id="算法示例2" class="level5">
<h5 class="anchored" data-anchor-id="算法示例2">算法示例2</h5>
<p><img src="images/fptree2.png" class="img-fluid" alt="FP-Tree 示例 2"> 设置支持度阈值为20%，因为一共有10条交易数据，所以支持度计数至少为2，所以将支持度计数小于2的商品删除。</p>
</section>
<section id="算法示例2-解释" class="level5">
<h5 class="anchored" data-anchor-id="算法示例2-解释">算法示例2-解释</h5>
<p>这张图展示了FP-Tree算法的第二步：根据支持度阈值过滤商品。</p>
<ul>
<li><strong>支持度阈值</strong>: 这里设置为20%，意味着只有出现次数达到总交易数20%的商品才会被保留。</li>
<li><strong>计算</strong>: 总共有10条交易数据，20%的支持度对应着至少出现2次。</li>
<li><strong>过滤</strong>: 支持度计数小于2的商品（如O、I、J、K、L、M、N、H）被删除。</li>
</ul>
</section>
<section id="算法示例3" class="level5">
<h5 class="anchored" data-anchor-id="算法示例3">算法示例3</h5>
<p><img src="images/fptree3.png" class="img-fluid" alt="FP-Tree 示例 3"> 将每条交易数据中的商品按照支持度技术排序。 比如第一条交易数据ABCEFO，按照新的支持度表排序为ACEBF。其他交易数据同理。</p>
</section>
<section id="算法示例3-解释" class="level5">
<h5 class="anchored" data-anchor-id="算法示例3-解释">算法示例3-解释</h5>
<p>这张图展示了FP-Tree算法的第三步：对每条交易数据中的商品按照支持度计数排序。</p>
<ul>
<li><strong>排序依据</strong>: 根据上一步过滤后的支持度计数表，对商品进行降序排列。</li>
<li><strong>例子</strong>:
<ul>
<li>原始交易数据：ABCEFO</li>
<li>排序后：ACEBF (A &gt; C &gt; E &gt; B &gt; F)</li>
</ul></li>
</ul>
</section>
<section id="算法示例4" class="level5">
<h5 class="anchored" data-anchor-id="算法示例4">算法示例4</h5>
<p><img src="images/fptree4.png" class="img-fluid" alt="FP-Tree 示例 4"> 将排序好的交易数据添加到FP树中。 第一条数据ACEBF，则创建A:1, C:1, E:1, B:1, F:1的FP树分支。 第二条数据ACG，创建单独的A:1, C:1, G:1分支。 以此类推。</p>
</section>
<section id="算法示例4-解释" class="level5">
<h5 class="anchored" data-anchor-id="算法示例4-解释">算法示例4-解释</h5>
<p>这张图展示了FP-Tree算法的第四步：开始构建FP-Tree。</p>
<ul>
<li><strong>插入规则</strong>:
<ul>
<li>从根节点开始，按照排序后的交易数据顺序插入商品。</li>
<li>如果FP-Tree中已存在相同的商品节点，则增加该节点的计数。</li>
<li>如果不存在相同的商品节点，则创建新的节点。</li>
</ul></li>
<li><strong>例子</strong>:
<ul>
<li>第一条数据 ACEBF：创建 A:1 -&gt; C:1 -&gt; E:1 -&gt; B:1 -&gt; F:1 的分支。</li>
<li>第二条数据 ACG：创建 A:1 -&gt; C:1 -&gt; G:1 的分支。</li>
</ul></li>
</ul>
</section>
<section id="算法示例5" class="level5">
<h5 class="anchored" data-anchor-id="算法示例5">算法示例5</h5>
<p><img src="images/fptree5.png" class="img-fluid" alt="FP-Tree 示例 5"> 当插入第四条交易数据ACEGD时，发现可以与第二条数据ACG共享A:1, C:1的前缀，所以形成A:2, C:2, G:1, E:1, D:1的分支。 以此类推。</p>
</section>
<section id="算法示例5-解释" class="level5">
<h5 class="anchored" data-anchor-id="算法示例5-解释">算法示例5-解释</h5>
<p>这张图展示了FP-Tree算法的第五步：继续构建FP-Tree，合并共享前缀。</p>
<ul>
<li><strong>合并规则</strong>:
<ul>
<li>如果新插入的交易数据与FP-Tree中已有的分支有相同的前缀，则共享这些前缀节点，并增加节点的计数。</li>
</ul></li>
<li><strong>例子</strong>:
<ul>
<li>第四条数据 ACEGD：与第二条数据 ACG 共享前缀 A 和 C，因此 A 和 C 的计数增加到 2，形成 A:2 -&gt; C:2 -&gt; G:1 -&gt; E:1 -&gt; D:1 的分支。</li>
</ul></li>
</ul>
</section>
<section id="算法示例6" class="level5">
<h5 class="anchored" data-anchor-id="算法示例6">算法示例6</h5>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fptree6.png" class="img-fluid figure-img"></p>
<figcaption>FP-Tree 示例 6</figcaption>
</figure>
</div>
<p>构建好的FP树。 挖掘FP-Tree：从FP-Tree中递归地挖掘频繁项集，比如以D为条件，找到D的条件模式基为&lt;A:2, C:2&gt;，这意味着在所有交易数据中，D和AC同时出现的次数为2次。其他商品同理。</p>
</section>
<section id="算法示例6-解释" class="level5">
<h5 class="anchored" data-anchor-id="算法示例6-解释">算法示例6-解释</h5>
<p>这张图展示了最终构建好的FP-Tree，以及如何从中挖掘频繁项集。</p>
<ul>
<li><strong>FP-Tree</strong>:
<ul>
<li>根节点通常为空。</li>
<li>每个节点表示一个商品，节点上的数字表示该商品在路径中出现的次数。</li>
<li>具有相同前缀的路径会被合并。</li>
</ul></li>
<li><strong>挖掘频繁项集</strong>:
<ul>
<li>从FP-Tree的叶子节点开始，递归地向上查找其条件模式基（conditional pattern base）。</li>
<li>条件模式基是指以该节点为结尾的所有前缀路径。</li>
<li>例如，以 D 为条件，找到 D 的条件模式基为 &lt;A:2, C:2&gt;，这意味着在所有交易数据中，D 和 AC 同时出现的次数为 2 次。</li>
</ul></li>
</ul>
</section>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<ul>
<li><strong>PrefixSpan (Prefix-Projected Pattern Growth)</strong>: 一种挖掘频繁序列的算法。</li>
<li><strong>序列 (Sequence)</strong>: 一组有序的项集，例如 &lt;(AB)(AC)D(CF)&gt;，就像顾客按时间顺序购买的商品列表。</li>
<li><strong>子序列 (Subsequence)</strong>: 如果序列 A 的所有项集都能在序列 B 的项集中找到，则 A 是 B 的子序列，就像顾客购买了商品列表 A 中的所有商品，那么 A 就是 B 的子序列。</li>
<li><strong>前缀 (Prefix)</strong> 和 <strong>后缀 (Suffix)</strong>:
<ul>
<li>例如，序列 &lt;a(abc)(ac)d(cf)&gt; 的前缀和后缀例子：</li>
</ul></li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>前缀</th>
<th>后缀 (前缀投影)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&lt;&gt;</td>
<td>&lt;(abc)(ac)d(cf)&gt;</td>
</tr>
<tr class="even">
<td>&lt;&gt;</td>
<td>&lt;(_bc)(ac)d(cf)&gt;</td>
</tr>
<tr class="odd">
<td>&lt;&gt;</td>
<td>&lt;(_c)(ac)d(cf)&gt;</td>
</tr>
</tbody>
</table>
<section id="prefixspan算法步骤" class="level5">
<h5 class="anchored" data-anchor-id="prefixspan算法步骤">PrefixSpan算法步骤</h5>
<ul>
<li><strong>输入</strong>: 序列数据集S和支持度阈值α</li>
<li><strong>输出</strong>: 所有满足支持度要求的频繁序列集</li>
<li>找出所有长度为1的前缀和对应的投影数据库</li>
<li>对长度为1的前缀进行计数,将支持度低于阈值α的前缀对应的项从数据集S删除,同时得到所有的频繁1项序列, i=1.</li>
<li>对于每个长度为i满足支持度要求的前缀进行递归挖掘:
<ul>
<li>找出前缀所对应的投影数据库。如果投影数据库为空,则递归返回。</li>
<li>统计对应投影数据库中各项的支持度计数。如果所有项的支持度计数都低于阈值, 则递归返回。</li>
<li>将满足支持度计数的各个单项和当前的前缀进行合并, 得到若干新的前缀</li>
<li>令i=i+1, 前缀为合并单项后的各个前缀, 分别递归执行第3步。</li>
</ul></li>
</ul>
</section>
</div>
</div>
</div>
</section>
</section>
<section id="聚类分析-cluster-analysis" class="level2">
<h2 class="anchored" data-anchor-id="聚类分析-cluster-analysis">聚类分析 (Cluster Analysis) 🤝</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>聚类分析是典型的无监督学习任务，训练样本的标签信息未知，通过对无标签样本的学习揭示数据内在性质及规律，这个规律通常是样本间相似性的规律。</p>
<p>聚类分析就像将不同的水果 🍎🍊🍌🍇 按照种类放在不同的篮子里 🧺。</p>
</div>
</div>
<section id="聚类分析的目标" class="level3">
<h3 class="anchored" data-anchor-id="聚类分析的目标">聚类分析的目标 🎯</h3>
<ul>
<li>将一组数据按照<strong>相似性</strong>和<strong>差异性</strong>分为几个类别。</li>
<li>使得：
<ul>
<li><strong>同一类别</strong>内的数据相似性<strong>尽可能大</strong>，就像让同一品种的水果 🍎🍎 放在一起。</li>
<li><strong>不同类别</strong>间的数据相似性<strong>尽可能小</strong>，就像让不同品种的水果 🍎🍊 分开。</li>
</ul></li>
</ul>
</section>
<section id="聚类分析的应用" class="level3">
<h3 class="anchored" data-anchor-id="聚类分析的应用">聚类分析的应用 🏘️</h3>
<ul>
<li><strong>市场细分</strong>: 将顾客划分为不同的群体，以便进行精准营销，就像将顾客按照年龄、收入等特征分成不同的群体。
<ul>
<li>针对不同群体制定不同的营销策略。</li>
</ul></li>
<li><strong>图像分割</strong>: 将图像分割成不同的区域，以便进行目标识别，就像将照片中的天空 ☁️、树木 🌳、人物 🧍‍♀️ 分割开来。
<ul>
<li>自动驾驶汽车识别道路、行人、车辆等。</li>
</ul></li>
<li><strong>异常检测</strong>: 发现数据中的异常点，例如信用卡欺诈 💳🚫，就像找出不正常的交易记录。
<ul>
<li>银行检测信用卡欺诈交易。</li>
</ul></li>
</ul>
</section>
<section id="聚类分析的特点" class="level3">
<h3 class="anchored" data-anchor-id="聚类分析的特点">聚类分析的特点 🤔</h3>
<ul>
<li><strong>无监督学习</strong>: 无需标签信息，就像在没有标签的情况下，将水果 🍎🍊🍌🍇 分类。</li>
<li><strong>探索性分析</strong>: 发现数据中潜在的规律，就像探索未知的领域 🗺️。</li>
<li><strong>结果解释</strong>: 需要对聚类结果进行解释，赋予其语义，就像给每个水果篮子 🧺 贴上标签 🏷️。</li>
</ul>
</section>
<section id="聚类分析算法" class="level3">
<h3 class="anchored" data-anchor-id="聚类分析算法">聚类分析算法 ⚙️</h3>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true">K-均值算法 (K-Means)</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-2" role="tab" aria-controls="tabset-2-2" aria-selected="false">DBSCAN 算法</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<ul>
<li><strong>原理</strong>: 将样本划分到 <em>k</em> 个簇中，使得每个样本到其所属簇的中心的距离之和最小，就像将学生 🧑‍🎓 分到 <em>k</em> 个班级 🏫，使得每个学生到班级中心的距离之和最小。</li>
<li><strong>步骤</strong>:
<ol type="1">
<li>随机选取 <em>k</em> 个聚类中心，就像随机选择 <em>k</em> 个班长 🙋‍♀️🙋‍♂️。</li>
<li>重复以下过程，直到收敛：
<ul>
<li>对于每个样本，计算其所属的类别（距离最近的中心），就像让每个学生选择离自己最近的班级。</li>
<li>对于每个类别，重新计算聚类中心（该类别所有样本的均值），就像重新选举班长，选出班级的平均位置。</li>
</ul></li>
</ol></li>
<li><strong>缺点</strong>:
<ul>
<li>需要预先指定 <em>k</em> 值，就像需要预先确定班级的数量，这在实际中可能很难确定。</li>
<li>对初始聚类中心敏感，就像不同的班长人选可能会导致不同的分班结果。</li>
<li>对噪声和离群点敏感，就像个别学生的特殊情况可能会影响分班结果。</li>
<li>可能陷入局部最优，就像分班结果可能不是最佳的。</li>
</ul></li>
<li><strong>公式</strong>
<ul>
<li>距离和E: <span class="math display">\[
E = \sum_{i=1}^{k}\sum_{x \in C_i}||x - \mu_i||_2^2
  \]</span> 其中<span class="math inline">\(\mu_i\)</span>是簇<span class="math inline">\(C_i\)</span>的均值向量, 即： <span class="math display">\[
\mu_i = \frac{1}{|C_i|} \sum_{x \in C_i}x
\]</span></li>
</ul></li>
</ul>
</div>
<div id="tabset-2-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-2-tab">
<ul>
<li><strong>DBSCAN (Density-Based Spatial Clustering of Applications with Noise)</strong>: 一种基于密度的聚类算法，就像根据人群的密度 🧑‍🤝‍🧑 来划分不同的区域。</li>
<li><strong>核心思想</strong>: 将具有足够密度的区域划分为簇，并发现任意形状的簇，就像找出人群聚集的区域。</li>
<li><strong>关键概念</strong>:
<ul>
<li><strong>Eps 邻域</strong>: 以点 <em>p</em> 为中心，半径为 Eps 的区域，就像以你为中心，画一个半径为 Eps 的圆 ⭕。</li>
<li><strong>MinPts</strong>: 给定的密度阈值，就像规定一个区域内至少有多少人 👨‍👩‍👧‍👦 才能算作人群聚集。</li>
<li><strong>核心对象 (Core Object)</strong>: Eps 邻域内包含至少 MinPts 个点的点，就像人群中的核心人物 😎。</li>
<li><strong>直接密度可达 (Directly Density-Reachable)</strong>: 如果点 <em>p</em> 在点 <em>q</em> 的 Eps 邻域内，且 <em>q</em> 是核心对象，则 <em>p</em> 从 <em>q</em> 直接密度可达，就像你和一个核心人物 😎 在同一个圈子里。</li>
<li><strong>密度可达 (Density-Reachable)</strong>: 如果存在一系列点，使得每个点从前一个点直接密度可达，则最后一个点从第一个点密度可达，就像你通过一系列朋友 🤝 认识了一个名人 🌟。</li>
<li><strong>密度相连 (Density-Connected)</strong>: 如果两个点都从同一个点密度可达，则这两个点密度相连，就像你和另一个人都通过朋友 🤝 认识了同一个名人 🌟。</li>
</ul></li>
<li><strong>步骤</strong>:
<ol type="1">
<li>检查每个点的 Eps 邻域。</li>
<li>如果一个点的 Eps 邻域包含的点数多于 MinPts，则创建一个以该点为核心对象的新簇。</li>
<li>迭代地聚集从核心对象直接密度可达的对象。</li>
<li>当没有新的点添加到任何簇时，过程结束。</li>
</ol></li>
<li><strong>优点</strong>:
<ul>
<li>无需预先指定簇的数量，就像不需要事先知道有多少个人群聚集区。</li>
<li>可以发现任意形状的簇，就像可以找出各种形状的人群聚集区 🚶‍♀️🚶‍♂️🧍🧍‍♀️。</li>
<li>对噪声不敏感，就像可以忽略那些离群的独行侠 👤。</li>
</ul></li>
<li><strong>缺点</strong>:
<ul>
<li>对参数 Eps 和 MinPts 敏感，就像半径 Eps 和人数阈值 MinPts 的设置会影响聚类结果。</li>
<li>当数据密度不均匀时，聚类效果较差，就像人群密度差异很大时，很难确定合适的半径和人数阈值。</li>
<li>对于高维数据，存在“维度灾难” 😨，就像在高维空间中，很难定义“距离”和“密度”。</li>
</ul></li>
</ul>
</div>
</div>
</div>
</section>
</section>
<section id="回归分析-regression-analysis" class="level2">
<h2 class="anchored" data-anchor-id="回归分析-regression-analysis">回归分析 (Regression Analysis) 📈</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>回归分析方法反映的是事务数据库中属性值在时间上的特征,产生一个将数据项映射到一个实值预测变量的函数,发现变量或属性间的依赖关系,其主要研究问题包括数据序列的趋势特征、数据序列的预测以及数据间的相关关系等。</p>
<p>回归分析就像根据过去的天气数据 🌤️🌧️🌈 来预测明天的天气 ☔。</p>
</div>
</div>
<section id="回归分析的目标" class="level3">
<h3 class="anchored" data-anchor-id="回归分析的目标">回归分析的目标 🎯</h3>
<ul>
<li>研究变量之间的<strong>相关关系</strong>，就像研究身高和体重之间的关系。
<ul>
<li>身高越高，体重通常越重。</li>
</ul></li>
<li>建立<strong>数学模型</strong>进行预测，就像建立一个公式，根据身高来预测体重。
<ul>
<li>体重 = a * 身高 + b</li>
</ul></li>
</ul>
</section>
<section id="回归分析与分类" class="level3">
<h3 class="anchored" data-anchor-id="回归分析与分类">回归分析与分类 📊</h3>
<ul>
<li><strong>相似之处</strong>: 都是监督学习问题，就像都需要有标签的数据 🏷️ 来进行学习。</li>
<li><strong>区别</strong>:
<ul>
<li><strong>分类</strong>: 预测离散的类别标签，就像判断一张图片是猫 🐱 还是狗 🐶。
<ul>
<li>输出是类别（离散值）。</li>
</ul></li>
<li><strong>回归</strong>: 预测连续的目标值，就像预测明天的气温 🌡️。
<ul>
<li>输出是数值（连续值）。</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="常见的回归分析模型" class="level3">
<h3 class="anchored" data-anchor-id="常见的回归分析模型">常见的回归分析模型 ⚙️</h3>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-3-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-1" role="tab" aria-controls="tabset-3-1" aria-selected="true">线性回归分析 (Linear Regression)</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-2" role="tab" aria-controls="tabset-3-2" aria-selected="false">支持向量回归 (Support Vector Regression, SVR) 🛡️</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-3" role="tab" aria-controls="tabset-3-3" aria-selected="false">K 邻近回归 (K-Nearest Neighbors Regression) 🏘️</a></li></ul>
<div class="tab-content">
<div id="tabset-3-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-3-1-tab">
<ul>
<li><strong>原理</strong>: 用线性模型刻画特征向量 <em>X</em> 与回归目标 <em>y</em> 之间的关系，就像用一条直线 📏 来拟合身高和体重之间的关系。</li>
<li><strong>模型</strong>:
<ul>
<li><span class="math inline">\(f(x_i) = w_1x_{i1} + w_2x_{i2} + ... + w_nx_{in} + b\)</span>, 使得 <span class="math inline">\(f(x_i) \approx y_i\)</span></li>
<li>就像找到一条直线，使得直线上的点尽可能接近真实的数据点。</li>
</ul></li>
<li><strong>损失函数</strong>:
<ul>
<li><span class="math inline">\(L(w, b) = \sum_{i=1}^{m}(y_i - w^Tx_i - b)^2\)</span></li>
<li>就像计算每个数据点到直线的距离的平方和，然后最小化这个和。</li>
</ul></li>
<li><strong>求解</strong>: 最小二乘法 (Least Squares Method)，就像找到一条“最佳拟合”直线。</li>
<li><strong>广义线性模型 (Generalized Linear Model)</strong>: 引入非线性函数 <em>g</em>，使得 <em>y</em> 和 <em>f(x)</em> 之间存在非线性关系，就像用曲线 〰️ 来拟合数据。
<ul>
<li><span class="math inline">\(y_i = g^{-1}(w^Tx_i + b)\)</span></li>
<li><em>g</em>: 联系函数 (Link Function)，就像一个“桥梁” 🌉，连接线性模型和非线性模型。</li>
</ul></li>
</ul>
</div>
<div id="tabset-3-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-2-tab">
<ul>
<li><strong>原理</strong>: 允许预测值 <em>f(x)</em> 和真实值 <em>y</em> 之间存在一定的偏差 (容忍度 <em>ε</em>)，就像允许预测的气温和真实气温之间存在一定的误差。</li>
<li><strong>核心思想</strong>: 构建一个宽度为 2<em>ε</em> 的间隔带，落入间隔带内的样本被认为预测正确，就像在真实气温周围画一个“安全区” 🚧。</li>
</ul>
</div>
<div id="tabset-3-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-3-tab">
<ul>
<li><strong>原理</strong>: 类似于 K 邻近分类，找到 <em>k</em> 个最近邻居，将这些邻居的回归目标的平均值作为预测值，就像根据你周围邻居的身高，来预测你的身高。</li>
<li><strong>加权平均</strong>: 可以根据距离的远近，对邻居的回归目标进行加权平均，就像给更近的邻居更大的权重。</li>
</ul>
</div>
</div>
</div>
</section>
</section>
<section id="总结" class="level2">
<h2 class="anchored" data-anchor-id="总结">总结 🎉</h2>
<p>本章我们学习了数据分析和知识发现的几种常用方法，就像打开了一个工具箱 🧰，里面装满了各种神奇的工具：</p>
<ul>
<li><strong>分类分析</strong> 📦：将数据对象划分到不同的类别中，就像整理房间一样。</li>
<li><strong>关联分析</strong> 🔗：发现数据项之间的关联规则，就像侦探 🕵️‍♀️ 发现线索。</li>
<li><strong>聚类分析</strong> 🤝：将数据对象分成不同的簇，使得同一簇内的对象相似度高，不同簇之间的对象相似度低，就像朋友们聚会 🥳。</li>
<li><strong>回归分析</strong> 📈：研究变量之间的关系，并建立模型进行预测，就像天气预报 🌤️。</li>
</ul>
<p>这些方法在实际应用中非常广泛，可以帮助我们从数据中提取有价值的信息，并将其转化为知识，为决策提供支持。</p>
</section>
<section id="思考与讨论" class="level2">
<h2 class="anchored" data-anchor-id="思考与讨论">思考与讨论 🤔</h2>
<ul>
<li>你之前是否接触过这些方法？在什么场景下接触到的呢？</li>
<li>你认为这些方法有哪些应用场景？你能举出一些具体的例子吗？</li>
<li>你认为这些方法的优缺点是什么？在实际应用中需要注意哪些问题？</li>
<li>你觉得还有什么需要补充的地方吗？</li>
<li>结合本章学习的内容，谈谈你在日常生活、学习和未来的工作中如何运用这些知识？</li>
<li>你在金融领域有自己感兴趣的方向吗？这些知识和技能对你有什么帮助？</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/qiufei\.github\.io\/web-slide-python-visual");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>🔋<a href="https://posit.co"><img src="https://posit.co/wp-content/themes/Posit/assets/images/posit-logo-2024.svg" class="img-fluid" alt="Posit" width="65"></a></p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 邱飞 © 2025
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://beian.miit.gov.cn">
<p>浙ICP备 2024072710号-1</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33021202002511">
<p>浙公网安备 33021202002511号</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:hfutqiufei@163.com">
      <i class="bi bi-envelope-at-fill" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>