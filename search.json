[
  {
    "objectID": "qmd/chapter4.html",
    "href": "qmd/chapter4.html",
    "title": "信息技术基础",
    "section": "",
    "text": "本节课我们将深入学习NumPy，它是Python数据科学生态的基石。🧱\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNumPy为我们提供了强大的多维数组对象和快速的数值计算能力，是数据分析和机器学习的必备工具！💪"
  },
  {
    "objectID": "qmd/chapter4.html#课程引入",
    "href": "qmd/chapter4.html#课程引入",
    "title": "信息技术基础",
    "section": "",
    "text": "本节课我们将深入学习NumPy，它是Python数据科学生态的基石。🧱\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNumPy为我们提供了强大的多维数组对象和快速的数值计算能力，是数据分析和机器学习的必备工具！💪"
  },
  {
    "objectID": "qmd/chapter4.html#目录",
    "href": "qmd/chapter4.html#目录",
    "title": "信息技术基础",
    "section": "目录",
    "text": "目录\n\n\n\n\n\n\n\nNumPy介绍 🧐\n\n什么是NumPy？\n为什么使用NumPy？\nNumPy的应用场景\n\nNumPy的数组对象-ndarray 📦\n\n什么是ndarray?\nndarray的重要属性\n创建ndarray\nndarray的数据类型\n\n\n\n\n\n\n\n\n\n\n\n\nndarray的索引、切片和迭代 🔍\n\n索引（Indexing）\n切片（Slicing）\n布尔索引（Boolean Indexing）\n花式索引（Fancy Indexing）\n迭代（Iteration）\n\nndarray的基础操作 ⚙️\n\n算术运算\n广播（Broadcasting）\n通用函数（Universal Functions, ufuncs）\n聚合函数（Aggregation Functions）"
  },
  {
    "objectID": "qmd/chapter4.html#numpy介绍",
    "href": "qmd/chapter4.html#numpy介绍",
    "title": "信息技术基础",
    "section": "NumPy介绍",
    "text": "NumPy介绍\n\n什么是NumPy？\n\nNumPy（Numerical Python的缩写）是一个开源的Python库。🐍\n几乎所有Python的数据科学和机器学习库（如Pandas, SciPy, scikit-learn等）都依赖于NumPy。🧩\n\nPandas: 提供高性能、易于使用的数据结构和数据分析工具。\nSciPy: 基于NumPy，提供许多科学计算中常用的算法，例如数值积分、插值、优化、线性代数等。\nscikit-learn: 流行的机器学习库，建立在NumPy, SciPy, and matplotlib之上，提供了许多用于机器学习的工具，包括分类、回归、聚类、降维、模型选择和预处理等。\n\nNumPy的核心是ndarray（n-dimensional array，多维数组）对象，它提供：\n\n快速的向量化运算（比Python内置列表快得多！⚡）。\n高效的内存利用。💾\n大量的数学函数库。➕➖✖️➗\n线性代数、傅里叶变换、随机数生成等高级功能。🧮\n向量化运算: 意味着运算可以直接应用于整个数组，而无需编写循环。"
  },
  {
    "objectID": "qmd/chapter4.html#numpy介绍-1",
    "href": "qmd/chapter4.html#numpy介绍-1",
    "title": "信息技术基础",
    "section": "NumPy介绍",
    "text": "NumPy介绍\n\n为什么要用NumPy, 不用Python自带的列表（list）？ 🤔\n\n\n\n\n\n\nTip\n\n\n\n\n速度：NumPy底层使用C语言编写，执行速度快。🚄\n\nNumPy数组上的操作通常比Python列表快得多，尤其是在进行数学和科学计算时。\n\n内存：NumPy数组在内存中是连续存储的，Python列表中的元素是指针，分散在内存各处，访问效率低。💾 vs 🗂️\n\nNumPy数组是连续的内存块，存储相同类型的元素。\nPython列表可以包含不同类型的对象，这导致额外的内存开销和类型检查。\n\n向量化操作：NumPy支持对整个数组进行操作，而无需编写循环。➿\n\n这种方式更简洁、更易读，也更高效。\n\n广播机制：NumPy可以对形状不同的数组进行运算。📡\n\n广播是NumPy中一种强大的机制，可以自动处理不同形状数组之间的运算。"
  },
  {
    "objectID": "qmd/chapter4.html#numpy介绍-2",
    "href": "qmd/chapter4.html#numpy介绍-2",
    "title": "信息技术基础",
    "section": "NumPy介绍",
    "text": "NumPy介绍\n让我们通过一个例子来直观感受一下NumPy的速度优势：\nimport numpy as np\nimport time\n\n# Python列表\nsize = 1000000\nlist1 = list(range(size))\nlist2 = list(range(size))\n\nstart = time.time()\nresult_list = [(x + y) for x, y in zip(list1, list2)]\nend = time.time()\nprint(f\"Python列表耗时: {(end - start) * 1000:.2f} 毫秒\")\n\n# Numpy数组\narray1 = np.arange(size)\narray2 = np.arange(size)\n\nstart = time.time()\nresult_array = array1 + array2\nend = time.time()\nprint(f\"NumPy数组耗时: {(end - start) * 1000:.2f} 毫秒\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy介绍-3",
    "href": "qmd/chapter4.html#numpy介绍-3",
    "title": "信息技术基础",
    "section": "NumPy介绍",
    "text": "NumPy介绍\n你会发现，对于大规模数据的运算，NumPy比Python列表快得多！🚀\n\n\n\n\n\n\nTip\n\n\n\n通常情况下，数据量越大，NumPy的优势越明显。"
  },
  {
    "objectID": "qmd/chapter4.html#numpy介绍-4",
    "href": "qmd/chapter4.html#numpy介绍-4",
    "title": "信息技术基础",
    "section": "NumPy介绍",
    "text": "NumPy介绍\n\nNumPy的应用场景\n\n数据分析：清洗、转换、统计分析。📊\n\n使用NumPy可以方便地对数据进行各种操作，如筛选、排序、去重、聚合等。\n\n机器学习：特征工程、模型输入。🤖\n\nNumPy数组是许多机器学习算法的期望输入格式。\n\n科学计算：物理模拟、工程计算。🔬\n\nNumPy提供了许多用于科学计算的函数和工具。\n\n图像处理：图像表示、滤波、变换。🖼️\n\n图像可以表示为NumPy数组，从而进行各种处理。\n\n信号处理：滤波、频谱分析。📡\n\nNumPy的傅里叶变换等函数可用于信号处理。"
  },
  {
    "objectID": "qmd/chapter4.html#numpy介绍-5",
    "href": "qmd/chapter4.html#numpy介绍-5",
    "title": "信息技术基础",
    "section": "NumPy介绍",
    "text": "NumPy介绍\n\n\n\n\n\n\nNote\n\n\n\n可以说，NumPy是现代Python数据科学生态的核心。掌握NumPy，是进行高效数据处理和科学计算的关键！🔑"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n什么是ndarray?\n\nndarray是NumPy中的核心数据结构，表示一个多维数组。📦\n数组中的所有元素必须是相同类型（例如，都是整数，或都是浮点数）。🔢\n数组的维度（dimension）称为轴（axis），轴的数量称为秩（rank）。📏"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-1",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-1",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n\n\nndarray示意图\n\n\n\n\n\n\n\n\nTip\n\n\n\n上图展示了一个二维数组，它有2个轴（axis），形状（shape）为(3, 4)，即3行4列。"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-2",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-2",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\nndarray的重要属性 📝\n\n\n\n\n\n\n\n属性\n说明\n\n\n\n\nshape\n返回一个元组(tuple)，表示ndarray各个维度的长度。元组的长度就是数组的维度（轴的个数，也称作秩rank）。元组中每个元素的值表示对应维度的大小。\n\n\nndim\nndarray对象的维度（轴的个数，即秩）。\n\n\nsize\nndarray中元素的总个数。\n\n\ndtype\nndarray中存储的元素的数据类型（如int32, float64等）。\n\n\nitemsize\nndarray中每个元素占用的字节数。\n\n\nnbytes\n整个ndarray数组占用的总字节数"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-3",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-3",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n\n\n\n\n\nNote\n\n\n\n通过这些属性，我们可以快速了解数组的结构、大小和数据类型。\n\n\n让我们看一个例子：\nimport numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(f\"形状 (shape): {arr.shape}\")\nprint(f\"维度 (ndim): {arr.ndim}\")\nprint(f\"元素个数 (size): {arr.size}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-4",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-4",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\nimport numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(f\"数据类型 (dtype): {arr.dtype}\")\nprint(f\"元素字节数 (itemsize): {arr.itemsize}\")\nprint(f\"数组总字节数 (nbytes): {arr.nbytes}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-5",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-5",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n创建ndarray 🛠️\n我们可以使用多种方法创建ndarray：\n\n\n\n\n\n\n\n函数\n说明\n\n\n\n\narray\n将输入的序列类型数据（如列表、元组、其他ndarray等）转换为ndarray。如果未指定dtype，会自动推断。\n\n\nasarray\n类似于array，但如果输入已经是ndarray，则不会创建副本，而是直接引用。\n\n\narange\n类似于Python内置的range，但返回的是ndarray而不是列表。可以指定起始值、终止值（不包含）和步长。\n\n\nones\n创建指定形状的全1数组。\n\n\nones_like\n以另一个ndarray的形状为模板，创建全1数组。\n\n\nzeros\n创建指定形状的全0数组。\n\n\nzeros_like\n以另一个ndarray的形状为模板，创建全0数组。\n\n\nempty\n创建指定形状的未初始化数组（值不确定，可能是内存中的残留数据）。\n\n\nempty_like\n以另一个ndarray的形状为模板，创建未初始化数组。\n\n\neye, identity\n创建N×N单位矩阵（对角线元素为1，其余为0）。\n\n\nfull\n创建指定形状，并用指定值填充的数组\n\n\nfull_like\n以另一个ndarray的形状为模板，创建指定填充值的数组\n\n\nrandom\nNumPy的子模块，用于生成各种随机数组，包括：random.rand, random.randn, random.randint, random.uniform等等"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-6",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-6",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\nimport numpy as np\n\n# 从列表创建\narr1 = np.array([1, 2, 3, 4])\nprint(f\"arr1: \\n{arr1}\")\n\n# 从元组创建\narr2 = np.array((5, 6, 7, 8))\nprint(f\"arr2: \\n{arr2}\")\n\n# 指定数据类型\narr3 = np.array([1, 2, 3], dtype=np.float64)\nprint(f\"arr3: \\n{arr3}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-7",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-7",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\nimport numpy as np\n# 使用arange\narr4 = np.arange(0, 10, 2)  # 从0开始，到10结束（不包含），步长为2\nprint(f\"arr4: \\n{arr4}\")\n\n# 创建全1数组\narr5 = np.ones((2, 3))  # 2行3列\nprint(f\"arr5: \\n{arr5}\")\n\n# 创建全0数组\narr6 = np.zeros((3, 2), dtype=np.int32)  # 3行2列，整数类型\nprint(f\"arr6: \\n{arr6}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-8",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-8",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\nimport numpy as np\n# 创建单位矩阵\narr7 = np.eye(3)  # 3x3单位矩阵\nprint(f\"arr7: \\n{arr7}\")\n\n# 创建指定填充值的数组\narr8 = np.full((2,3), 3.14)\nprint(f\"arr8: \\n{arr8}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-9",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-9",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\nimport numpy as np\n# 创建随机数组\narr9 = np.random.rand(2,3) # 从0到1的均匀分布随机数\nprint(f\"arr9: \\n{arr9}\")\n\narr10 = np.random.randn(3,2) # 标准正态分布随机数\nprint(f\"arr10: \\n{arr10}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-10",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-10",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\nimport numpy as np\n# 创建随机数组\narr11 = np.random.randint(1, 10, (2,2)) # 最小值和最大值之间的随机整数\nprint(f\"arr11: \\n{arr11}\")\n\narr12 = np.random.uniform(1, 10, (2,4)) # 从最小值和最大值之间的均匀分布\nprint(f\"arr12: \\n{arr12}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-11",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-11",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n\n\n\n\n\nImportant\n\n\n\nnp.array会试图为创建的数组推断出一个合适的数据类型。\n\n\n# 整数列表\narr1 = np.array([1, 2, 3])\nprint(f\"arr1 dtype: {arr1.dtype}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-12",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-12",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n# 浮点数列表\narr2 = np.array([1.0, 2.0, 3.0])\nprint(f\"arr2 dtype: {arr2.dtype}\")\n\n# 混合整数和浮点数\narr3 = np.array([1, 2.0, 3])\nprint(f\"arr3 dtype: {arr3.dtype}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-13",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-13",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n# 包含字符串\narr4 = np.array(['a', 'b', 'c'])\nprint(f\"arr4 dtype: {arr4.dtype}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-14",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-14",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\nndarray的数据类型 📊\n\n\n\n\n\n\n\n\n数据类型\n类型代码\n说明\n\n\n\n\nint8, uint8\ni1, u1\n有符号和无符号8位（1字节）整型\n\n\nint16, uint16\ni2, u2\n有符号和无符号16位（2字节）整型\n\n\nint32, uint32\ni4, u4\n有符号和无符号32位（4字节）整型\n\n\nint64, uint64\ni8, u8\n有符号和无符号64位（8字节）整型\n\n\nfloat16\nf2\n半精度浮点数（16位，2字节）\n\n\nfloat32\nf4或f\n单精度浮点数（32位，4字节），与C语言的float兼容\n\n\nfloat64\nf8或d\n双精度浮点数（64位，8字节），与C语言的double和Python的float对象兼容\n\n\nfloat128\nf16或g\n扩展精度浮点数（128位，16字节）\n\n\ncomplex64\nc8\n复数，由两个32位浮点数表示\n\n\ncomplex128\nc16\n复数，由两个64位浮点数表示\n\n\ncomplex256\nc32\n复数，由两个128位浮点数表示\n\n\nbool\n?\n布尔类型，存储True或False\n\n\nobject\nO\nPython对象类型\n\n\nstring_\nS\n固定长度字符串类型（每个字符1字节）。例如，S10表示长度为10的字符串。\n\n\nunicode_\nU\n固定长度Unicode类型（字节数取决于平台）。例如，U10表示长度为10的Unicode字符串。"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-15",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-15",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n\n\n\n\n\nTip\n\n\n\n我们可以使用dtype属性查看或指定数组的数据类型。在创建数组时，可以使用dtype参数指定数据类型。\n\n\narr = np.array([1, 2, 3], dtype=np.float64)\nprint(arr.dtype)"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-16",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-16",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n\n\n\n\n\nNote\n\n\n\n还可以使用astype方法显式地转换数组的数据类型。\n\n\narr = np.array([1, 2, 3])\nprint(f\"Original dtype: {arr.dtype}\")\n\nfloat_arr = arr.astype(np.float64)\nprint(f\"Converted to float64: {float_arr.dtype}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-17",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-17",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\narr = np.array([1, 2, 3])\n\nstring_arr = arr.astype(np.string_)\nprint(f\"Converted to string_: {string_arr.dtype}\")"
  },
  {
    "objectID": "qmd/chapter4.html#numpy的数组对象-ndarray-18",
    "href": "qmd/chapter4.html#numpy的数组对象-ndarray-18",
    "title": "信息技术基础",
    "section": "NumPy的数组对象-ndarray",
    "text": "NumPy的数组对象-ndarray\n\n\n\n\n\n\nImportant\n\n\n\nastype方法会创建一个新的数组（原始数组的副本），即使新的数据类型与原来的相同。"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n索引（Indexing）\n\n一维数组：与Python列表类似，使用方括号[]和从0开始的下标。\n\narr = np.arange(10)\nprint(arr)\nprint(arr[0])  # 第一个元素\nprint(arr[5])  # 第六个元素\nprint(arr[-1])  # 最后一个元素"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-1",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-1",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n索引（Indexing）\n\n多维数组：\n\n每个维度都有一个索引，用逗号分隔。\n可以使用递归方式访问元素，也可以使用逗号分隔的索引列表。\n\n\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d)\nprint(arr2d[0, 0])  # 第一行第一列\nprint(arr2d[1, 2])  # 第二行第三列"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-2",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-2",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n索引（Indexing）\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d[2, 0])  # 第三行第一列\nprint(arr2d[2][0])  # 与上一行等价"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-3",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-3",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n\n\n\n\n\nTip\n\n\n\n如果只指定部分维度，返回的将是降维后的子数组。\n\n\n# 假设有一个3x4x5的三维数组\narr3d = np.arange(60).reshape(3, 4, 5)\nprint(\"arr3d:\\n\", arr3d)\n\n# 获取第一个维度为0的子数组\nslice_0 = arr3d[0]\nprint(\"arr3d[0]:\\n\", slice_0)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-4",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-4",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n# 假设有一个3x4x5的三维数组\narr3d = np.arange(60).reshape(3, 4, 5)\n\n# 获取第一个维度为1的子数组\nslice_1 = arr3d[1]\nprint(\"arr3d[1]:\\n\", slice_1)\n\n# 获取第一个维度为2的子数组\nslice_2 = arr3d[2]\nprint(\"arr3d[2]:\\n\", slice_2)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-5",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-5",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n切片（Slicing）\n\n一维数组的切片与Python列表的切片类似, 都是“左闭右开”区间。\n\narr = np.arange(10)\nprint(arr)\nprint(arr[2:5])  # 下标2到5（不包含5）"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-6",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-6",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n切片（Slicing）\narr = np.arange(10)\nprint(arr[:4])  # 开头到4（不包含4）\nprint(arr[6:])  # 6到结尾\nprint(arr[::2])  # 从头到尾，步长为2\nprint(arr[::-1])  # 倒序"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-7",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-7",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n切片（Slicing）\n\n多维数组的切片：\n\n在每个维度上分别进行切片，用逗号分隔。\n可以使用:表示整个轴。\n\n\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d)\nprint(arr2d[:2, :2])  # 前两行，前两列"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-8",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-8",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n切片（Slicing）\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d[1, :])  # 第二行的所有列\nprint(arr2d[:, 2])  # 第三列的所有行"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-9",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-9",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n\n\n\n\n\nImportant\n\n\n\n与Python列表不同，NumPy数组的切片是原始数组的视图（view）。这意味着对切片的修改会直接影响原始数组！⚠️\n\n\narr = np.arange(5)\nprint(\"Original array:\", arr)\narr_slice = arr[1:4]\nprint(\"Slice:\", arr_slice)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-10",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-10",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\narr = np.arange(5)\narr_slice = arr[1:4]\narr_slice[0] = 100\nprint(\"Modified slice:\", arr_slice)\nprint(\"Original array after modification:\", arr)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-11",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-11",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n\n\n\n\n\nTip\n\n\n\n如果希望得到副本（copy）而不是视图，可以使用copy()方法。\n\n\narr = np.arange(5)\narr_copy = arr[1:4].copy()\narr_copy[0] = 100  # 修改副本不会影响原始数组\nprint(arr)\nprint(arr_copy)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-12",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-12",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n布尔索引（Boolean Indexing）\n\n可以使用布尔数组（通常是比较运算的结果）来选择元素。\n布尔数组的形状必须与要索引的数组相同。\n\narr = np.array([1, 2, 3, 4, 5])\nbool_index = arr &gt; 2  # 返回一个布尔数组\nprint(bool_index)\nprint(arr[bool_index])  # 选择大于2的元素"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-13",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-13",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n布尔索引（Boolean Indexing）\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nbool_index2d = arr2d &gt; 5\nprint(bool_index2d)\nprint(arr2d[bool_index2d])  # 选择大于5的元素"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-14",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-14",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n\n\n\n\n\nNote\n\n\n\n布尔索引常用于根据条件筛选数据。\n\n\n我们还可以在布尔索引中使用逻辑运算符&(和), | (或), ~ (非)来组合多个条件。\narr = np.array([1, 2, 3, 4, 5, 6])\n\n# 选择大于2且小于6的元素\ncondition1 = arr &gt; 2\ncondition2 = arr &lt; 6\ncombined_condition = condition1 & condition2\nprint(arr[combined_condition])"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-15",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-15",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\narr = np.array([1, 2, 3, 4, 5, 6])\n\n# 选择小于2或大于4的元素\ncondition3 = arr &lt; 2\ncondition4 = arr &gt; 4\ncombined_condition2 = condition3 | condition4\nprint(arr[combined_condition2])"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-16",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-16",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\narr = np.array([1, 2, 3, 4, 5, 6])\n# 选择不等于3的元素\ncondition5 = arr != 3\nprint(arr[condition5])\n\n# 或者使用~运算符\ncondition6 = ~(arr==3)\nprint(arr[condition6])"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-17",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-17",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n花式索引（Fancy Indexing）\n\n使用整数数组（或列表）作为索引，一次选择多个元素。\n与切片不同，花式索引总是返回数据的副本。\n\narr = np.arange(10) * 10\nprint(arr)\nindices = [1, 3, 5]\nprint(arr[indices])  # 选择下标为1、3、5的元素"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-18",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-18",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n花式索引（Fancy Indexing）\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d)\nrow_indices = [0, 2]\ncol_indices = [1, 0]\nprint(arr2d[row_indices, col_indices])  # 选择(0, 1)和(2, 0)位置的元素"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-19",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-19",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n\n\n\n\n\nTip\n\n\n\n花式索引可以用于按任意顺序选择或重排数组的行或列。\n\n\narr2d = np.arange(12).reshape(4,3)\nprint(arr2d)\n\nnew_order = [2, 0, 3, 1]\nrearranged_arr2d = arr2d[new_order]\nprint(rearranged_arr2d)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-20",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-20",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n迭代（Iteration）\n\n一维数组：迭代方式与Python列表相同。\n\narr = np.arange(5)\nfor x in arr:\n    print(x)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-21",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-21",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n迭代（Iteration）\n\n多维数组：迭代是相对于第一个轴（axis 0，即行）进行的。\n\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nfor row in arr2d:\n    print(row)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的索引切片和迭代-22",
    "href": "qmd/chapter4.html#ndarray的索引切片和迭代-22",
    "title": "信息技术基础",
    "section": "ndarray的索引、切片和迭代",
    "text": "ndarray的索引、切片和迭代\n\n迭代（Iteration）\n\n如果需要遍历每个元素，可以使用flat属性（返回一个迭代器）：\n\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nfor element in arr2d.flat:\n    print(element)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作",
    "href": "qmd/chapter4.html#ndarray的基础操作",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n算术运算 ➕➖✖️➗\n\nNumPy数组支持元素级（element-wise）的算术运算（+, -, *, /, **等）。\n运算是在两个数组的对应元素之间进行的。\n数组必须具有兼容的形状（或满足广播规则）。\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\nprint(arr1 + arr2)  # 对应元素相加\nprint(arr1 * arr2)  # 对应元素相乘\nprint(arr1 ** 2)  # 每个元素求平方"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-1",
    "href": "qmd/chapter4.html#ndarray的基础操作-1",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n广播（Broadcasting）📡\n\n广播是一种强大的机制，允许NumPy在不同形状的数组之间进行算术运算。\n广播的规则：\n\n如果两个数组的维度不同，则维度较小的数组会在其前面补1，直到维度相同。\n如果两个数组在某个维度上的大小相同，或者其中一个数组在该维度上的大小为1，则认为它们在该维度上是兼容的。\n如果两个数组在所有维度上都兼容，则可以进行广播运算。\n在广播运算中，大小为1的维度会被“拉伸”以匹配另一个数组在该维度上的大小。"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-2",
    "href": "qmd/chapter4.html#ndarray的基础操作-2",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n\n\n\n\n\nTip\n\n\n\n理解广播规则对于高效使用NumPy非常重要。\n\n\n可以参考如下图片来理解数组的广播："
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-3",
    "href": "qmd/chapter4.html#ndarray的基础操作-3",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n让我们通过几个例子来理解广播：\n# 例子1：数组与标量相加\narr = np.array([1, 2, 3])\nscalar = 5\nprint(arr + scalar)  # 标量被广播到数组的每个元素"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-4",
    "href": "qmd/chapter4.html#ndarray的基础操作-4",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n# 例子2：不同形状数组相加\narr1 = np.array([[1, 2, 3], [4, 5, 6]])  # 形状为(2, 3)\narr2 = np.array([10, 20, 30])            # 形状为(3,)\nprint(arr1 + arr2)\n# arr2被广播到arr1的每一行"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-5",
    "href": "qmd/chapter4.html#ndarray的基础操作-5",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n# 例子3：更复杂的广播\narr1 = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]])  # 形状为(4, 3)\narr2 = np.array([1, 2, 3])                                   # 形状为(3,)\nprint(arr1 + arr2)\n# arr2被广播到arr1的每一行"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-6",
    "href": "qmd/chapter4.html#ndarray的基础操作-6",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n# 例子3：更复杂的广播\narr1 = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]])  # 形状为(4, 3)\narr3 = np.array([[1,], [2,], [3,], [4,]])                   # 形状为(4, 1)\nprint(arr1 + arr3)\n# arr3被广播到arr1的每一列"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-7",
    "href": "qmd/chapter4.html#ndarray的基础操作-7",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n\n\n\n\n\nImportant\n\n\n\n如果两个数组的形状不满足广播规则，会抛出ValueError异常。"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-8",
    "href": "qmd/chapter4.html#ndarray的基础操作-8",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n通用函数（Universal Functions, ufuncs）⚙️\n\nufunc是一种对ndarray中的每个元素进行操作的函数。\nufunc是向量化操作的基础，可以避免编写显式循环，提高效率。⚡\n常见的ufunc：\n\n一元ufunc（接受一个数组）：abs, sqrt, exp, log, sin, cos, tan等。\n二元ufunc（接受两个数组）：add, subtract, multiply, divide, power, maximum, minimum等。"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-9",
    "href": "qmd/chapter4.html#ndarray的基础操作-9",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\narr = np.array([1, 4, 9, 16])\n\nprint(np.sqrt(arr))  # 对每个元素求平方根\nprint(np.sin(arr))  # 对每个元素求正弦值"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-10",
    "href": "qmd/chapter4.html#ndarray的基础操作-10",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\nprint(np.maximum(arr1, arr2))  # 逐元素比较，取最大值"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-11",
    "href": "qmd/chapter4.html#ndarray的基础操作-11",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n\n\n\n\n\nNote\n\n\n\n许多ufunc都有一个可选的out参数，允许你指定结果存放的位置。\n\n\narr = np.arange(5)\nout_arr = np.zeros(5)\nnp.multiply(arr, 10, out=out_arr)\nprint(out_arr)"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-12",
    "href": "qmd/chapter4.html#ndarray的基础操作-12",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n聚合函数（Aggregation Functions）📊\n\n聚合函数是对数组进行汇总计算的函数，返回一个标量结果。\n常见的聚合函数：sum, mean, min, max, std, var, argmin, argmax等。\n可以指定axis参数来沿着某个轴进行聚合。"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-13",
    "href": "qmd/chapter4.html#ndarray的基础操作-13",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(\"arr:\\n\", arr)\n\nprint(\"np.sum(arr):\", np.sum(arr))  # 所有元素求和\nprint(\"np.mean(arr):\",np.mean(arr))  # 所有元素的平均值\nprint(\"np.min(arr):\", np.min(arr))  # 所有元素的最小值\nprint(\"np.max(arr):\", np.max(arr))  # 所有元素的最大值"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-14",
    "href": "qmd/chapter4.html#ndarray的基础操作-14",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(\"np.std(arr):\", np.std(arr)) # 所有元素的标准差\nprint(\"np.var(arr):\", np.var(arr))  # 所有元素的方差\nprint(\"np.argmin(arr):\", np.argmin(arr))  # 最小元素的索引\nprint(\"np.argmax(arr):\", np.argmax(arr))  # 最大元素的索引"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-15",
    "href": "qmd/chapter4.html#ndarray的基础操作-15",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\n# 沿着axis 0（行）求和\nprint(\"np.sum(arr, axis=0):\", np.sum(arr, axis=0))  \nprint(\"np.sum(arr, axis=1):\", np.sum(arr, axis=1))  # 沿着axis 1（列）求和"
  },
  {
    "objectID": "qmd/chapter4.html#ndarray的基础操作-16",
    "href": "qmd/chapter4.html#ndarray的基础操作-16",
    "title": "信息技术基础",
    "section": "ndarray的基础操作",
    "text": "ndarray的基础操作\n\n\n\n\n\n\nImportant\n\n\n\n当对多维数组进行聚合时，如果不指定axis参数，会沿着所有轴进行聚合，得到一个标量值。如果指定了axis参数，会沿着指定的轴进行聚合，得到一个降维的数组。"
  },
  {
    "objectID": "qmd/chapter4.html#总结",
    "href": "qmd/chapter4.html#总结",
    "title": "信息技术基础",
    "section": "总结 📝",
    "text": "总结 📝\n\nNumPy是Python数据科学的核心库，提供了高性能的多维数组对象ndarray。\nndarray具有多个重要属性，如shape、ndim、size、dtype等。\n可以使用多种方法创建ndarray，如array、arange、ones、zeros等。🛠️\nNumPy支持多种数据类型，如整数、浮点数、复数、布尔值等。📊\nndarray支持索引、切片、布尔索引、花式索引等多种数据访问方式。🔍\nNumPy的广播机制允许在不同形状的数组之间进行算术运算。📡\n通用函数（ufunc）提供了元素级的快速运算。⚙️\n聚合函数可以对数组进行汇总计算。📊"
  },
  {
    "objectID": "qmd/chapter4.html#思考与讨论",
    "href": "qmd/chapter4.html#思考与讨论",
    "title": "信息技术基础",
    "section": "思考与讨论 🤔",
    "text": "思考与讨论 🤔\n\n你能总结一下NumPy数组（ndarray）与Python列表（list）的主要区别吗？\n\n\n\n\n\n\nTip\n\n\n\n\nNumPy数组是同质的（所有元素类型相同），Python列表可以是异质的。\nNumPy数组在内存中连续存储，Python列表元素分散存储。\nNumPy数组支持向量化运算和广播，Python列表需要循环。\nNumPy数组通常比Python列表更快、更省内存。\n\n\n\n你能举例说明NumPy的广播机制是如何工作的吗？\n\n\n\n\n\n\nTip\n\n\n\n例如，一个形状为(3, 3)的数组与一个形状为(3,)的数组相加，(3,)的数组会被广播到(3, 3)的每一行。\n\n\n你能说出至少5种常见的NumPy通用函数（ufunc）吗？\n\n\n\n\n\n\nTip\n\n\n\nnp.sqrt, np.sin, np.cos, np.exp, np.log, np.add, np.multiply, np.maximum等。\n\n\n如何根据某个条件筛选NumPy数组中的元素？\n\n\n\n\n\n\nTip\n\n\n\n使用布尔索引。例如，arr[arr &gt; 5]会选择arr中所有大于5的元素。\n\n\n你觉得学习NumPy对你未来的数据分析或机器学习工作有何帮助？\n\n\n\n\n\n\nTip\n\n\n\nNumPy是数据分析和机器学习的基础工具，掌握NumPy可以提高数据处理的效率，为后续的学习打下基础。"
  },
  {
    "objectID": "qmd/chapter8.html",
    "href": "qmd/chapter8.html",
    "title": "信息技术基础 🚀",
    "section": "",
    "text": "Matplotlib 是 Python 数据科学生态中一颗璀璨的明星 🌟，它是创建各种静态、动态和交互式可视化图表的强大武器 🛠️。无论你是数据分析新手还是经验丰富的专家，Matplotlib 都能满足你的需求。\n\n\n\n\n它具有以下闪光点：\n\n\n\n🎨 易学易用: Matplotlib 的 API 设计简洁明了，就像搭积木一样，你可以轻松组合各种元素，构建出漂亮的图表。\n📊 功能强大: 无论是折线图、散点图、直方图，还是饼图、箱线图、热力图，Matplotlib 都能轻松驾驭，让你的数据栩栩如生。\n⚙️ 高度可定制: 想要个性化你的图表？没问题！Matplotlib 允许你精细控制图表的每一个细节，从颜色、线型到标签、标题，一切尽在掌握。\n💡 与 Jupyter Notebook 完美结合: 在 Jupyter Notebook 中，你可以直接显示 Matplotlib 图表，并与之互动，让数据探索更加便捷高效。"
  },
  {
    "objectID": "qmd/chapter8.html#matplotlib-简介",
    "href": "qmd/chapter8.html#matplotlib-简介",
    "title": "信息技术基础 🚀",
    "section": "",
    "text": "Matplotlib 是 Python 数据科学生态中一颗璀璨的明星 🌟，它是创建各种静态、动态和交互式可视化图表的强大武器 🛠️。无论你是数据分析新手还是经验丰富的专家，Matplotlib 都能满足你的需求。\n\n\n\n\n它具有以下闪光点：\n\n\n\n🎨 易学易用: Matplotlib 的 API 设计简洁明了，就像搭积木一样，你可以轻松组合各种元素，构建出漂亮的图表。\n📊 功能强大: 无论是折线图、散点图、直方图，还是饼图、箱线图、热力图，Matplotlib 都能轻松驾驭，让你的数据栩栩如生。\n⚙️ 高度可定制: 想要个性化你的图表？没问题！Matplotlib 允许你精细控制图表的每一个细节，从颜色、线型到标签、标题，一切尽在掌握。\n💡 与 Jupyter Notebook 完美结合: 在 Jupyter Notebook 中，你可以直接显示 Matplotlib 图表，并与之互动，让数据探索更加便捷高效。"
  },
  {
    "objectID": "qmd/chapter8.html#为什么要拥抱-matplotlib",
    "href": "qmd/chapter8.html#为什么要拥抱-matplotlib",
    "title": "信息技术基础 🚀",
    "section": "为什么要拥抱 Matplotlib？ 🤗",
    "text": "为什么要拥抱 Matplotlib？ 🤗\n\n\n\n📈 数据可视化是数据分析的灵魂。 通过将数据转化为图形，我们能够更直观地洞察数据背后的故事，发现隐藏的模式，识别异常值，并从中获得宝贵的见解。\n📣 Matplotlib 是 Python 数据科学生态系统的基石。 它与 NumPy、Pandas 等数据科学利器无缝集成，让你能够流畅地处理和可视化数据，事半功倍。\n👨‍💻 Matplotlib 是业界广泛使用的可视化工具。 无论是在学术殿堂、商业战场，还是数据新闻领域，Matplotlib 都是数据可视化不可或缺的伙伴，助你一臂之力。\n\n\n\n\n\n\n\n\nNote\n\n\n\n数据可视化是将抽象的数据以图形或图像的形式呈现出来，让数据更易于理解、分析和沟通。它就像一座桥梁，连接着冰冷的数据和人类的认知，让数据变得生动有趣。\n\n\n\n\n\n\n\n\nNote\n\n\n\nPython 数据科学生态系统是由一系列用于数据科学的 Python 库和工具组成的大家庭。这些成员各有所长，相互协作，为数据处理、分析、可视化和机器学习提供了强大的支持。其中，Numpy和Pandas是重要的组成部分。"
  },
  {
    "objectID": "qmd/chapter8.html#matplotlib-vs.-matlab一场绘图库的较量",
    "href": "qmd/chapter8.html#matplotlib-vs.-matlab一场绘图库的较量",
    "title": "信息技术基础 🚀",
    "section": "Matplotlib vs. MATLAB：一场绘图库的较量 ⚔️",
    "text": "Matplotlib vs. MATLAB：一场绘图库的较量 ⚔️\nMatplotlib 的绘图接口与 MATLAB 有着异曲同工之妙，这使得 MATLAB 用户可以轻松过渡到 Matplotlib。不过，它们之间也存在一些关键差异：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性\nMatplotlib\nMATLAB\n\n\n\n\n语言\nPython\nMATLAB\n\n\n类型\n开源、免费 🆓\n商业软件、收费 💰\n\n\n扩展性\n易于与其他 Python 库集成，拥有无限可能 ♾️\n扩展性相对有限\n\n\n社区支持\n庞大的开源社区，活跃的开发者和用户群体，让你不再孤单 💪\nMathWorks 公司提供的官方支持和有限的社区资源\n\n\n应用领域\n数据科学、机器学习、科学计算、Web 开发等，无所不能 🚀\n工程、科学计算、控制系统等"
  },
  {
    "objectID": "qmd/chapter8.html#目录探索-matplotlib-的奇妙世界",
    "href": "qmd/chapter8.html#目录探索-matplotlib-的奇妙世界",
    "title": "信息技术基础 🚀",
    "section": "目录：探索 Matplotlib 的奇妙世界 🗺️",
    "text": "目录：探索 Matplotlib 的奇妙世界 🗺️\n\n基本布局对象：揭开 Matplotlib 图表结构的神秘面纱，认识 Figure、Axes 和 Subplot 这三位核心成员。\n图表样式修改与装饰项接口：学习如何为图表穿上华丽的 পোশাক (孟加拉语：服装)，定制线条样式、颜色、标记、坐标轴、图例等，让你的图表独一无二。\n基础图表绘制：掌握绘制各种常见图表类型的独门秘籍，包括直方图、散点图、饼图、柱状图、折线图和表格，让你的数据跃然纸上。"
  },
  {
    "objectID": "qmd/chapter8.html#目录探索-matplotlib-的奇妙世界-续",
    "href": "qmd/chapter8.html#目录探索-matplotlib-的奇妙世界-续",
    "title": "信息技术基础 🚀",
    "section": "目录：探索 Matplotlib 的奇妙世界 🗺️ （续）",
    "text": "目录：探索 Matplotlib 的奇妙世界 🗺️ （续）\n\nMatplotlib 3D：开启三维可视化之旅，探索如何使用 Matplotlib 创建令人惊叹的立体图表，让你的数据更具立体感。\nMatplotlib 与 Jupyter 结合：解锁 Matplotlib 与 Jupyter Notebook 的协同魔法，打造交互式数据可视化文档，让你的数据分析更上一层楼。"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象图表的骨骼与肌肉",
    "href": "qmd/chapter8.html#基本布局对象图表的骨骼与肌肉",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：图表的骨骼与肌肉 💪",
    "text": "基本布局对象：图表的骨骼与肌肉 💪\nMatplotlib 图表由多个基本组件构成，它们共同支撑起整个可视化框架。\n\nFigure (图形): 🖼️ 整个绘图区域，就像一块画布，你可以在上面尽情挥洒创意。它可以包含一个或多个 Axes。\n\n使用 matplotlib.pyplot.figure() 创建。\n\nAxes (轴域): 📈 具有数据空间的图像区域，通常包含两个（二维）或三个（三维）坐标轴，它们定义了数据的范围和刻度。一个 Figure 可以包含多个 Axes，但一个 Axes 只能属于一个 Figure。\n\n使用 matplotlib.figure.Figure.add_axes() 创建。\n\nSubplot (子图): 🧩 将 Figure 划分为多个子区域，每个子区域可以包含一个 Axes。这就像在画布上划分出多个小格子，每个格子都可以绘制不同的图表。\n\n使用 matplotlib.figure.Figure.add_subplot() 或 plt.subplots() 创建。"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象图解",
    "href": "qmd/chapter8.html#基本布局对象图解",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：图解",
    "text": "基本布局对象：图解"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象图解---figure",
    "href": "qmd/chapter8.html#基本布局对象图解---figure",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：图解 - Figure",
    "text": "基本布局对象：图解 - Figure\n\n\n\n\n\n\nNote\n\n\n\nFigure (图形): 🖼️ 整个绘图区域，就像一块画布，你可以在上面尽情挥洒创意。它可以包含一个或多个 Axes。\n\n使用 matplotlib.pyplot.figure() 创建。"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象图解---axes",
    "href": "qmd/chapter8.html#基本布局对象图解---axes",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：图解 - Axes",
    "text": "基本布局对象：图解 - Axes\n\n\n\n\n\n\nNote\n\n\n\nAxes (轴域): 📈 具有数据空间的图像区域，通常包含两个（二维）或三个（三维）坐标轴，它们定义了数据的范围和刻度。一个 Figure 可以包含多个 Axes，但一个 Axes 只能属于一个 Figure。\n\n使用 matplotlib.figure.Figure.add_axes() 创建。"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象图解---subplot",
    "href": "qmd/chapter8.html#基本布局对象图解---subplot",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：图解 - Subplot",
    "text": "基本布局对象：图解 - Subplot\n\n\n\n\n\n\nNote\n\n\n\nSubplot (子图): 🧩 将 Figure 划分为多个子区域，每个子区域可以包含一个 Axes。这就像在画布上划分出多个小格子，每个格子都可以绘制不同的图表。\n\n使用 matplotlib.figure.Figure.add_subplot() 或 plt.subplots() 创建。"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象实战演练",
    "href": "qmd/chapter8.html#基本布局对象实战演练",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：实战演练 ⚔️",
    "text": "基本布局对象：实战演练 ⚔️\n让我们通过一个简单的例子来理解这些概念：\n\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 2)  # 创建一个包含 2x2 个子图的 Figure\nplt.show()\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt：导入 matplotlib.pyplot 模块，并将其简称为 plt。这是使用 Matplotlib 的标准做法。\nfig, axes = plt.subplots(2, 2)：创建一个包含 2x2 个子图的 Figure，并将 Figure 对象赋值给 fig，将 Axes 对象数组赋值给 axes。axes 数组的形状是 (2, 2)，可以通过 axes[0, 0]、axes[0, 1]、axes[1, 0]、axes[1, 1] 分别访问每个子图。"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象实战演练---结果",
    "href": "qmd/chapter8.html#基本布局对象实战演练---结果",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：实战演练 ⚔️ - 结果",
    "text": "基本布局对象：实战演练 ⚔️ - 结果"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象进阶实战",
    "href": "qmd/chapter8.html#基本布局对象进阶实战",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：进阶实战 🚀",
    "text": "基本布局对象：进阶实战 🚀\n现在，让我们在每个子图中绘制不同的图表：\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axes = plt.subplots(2, 2, figsize=(8, 8))  # 创建一个包含 2x2 个子图的 Figure\n\n# 绘制简单图形\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\naxes[0, 0].plot(t, s)\naxes[0, 0].set_title('Simple Plot') # 添加标题\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象进阶实战-续",
    "href": "qmd/chapter8.html#基本布局对象进阶实战-续",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：进阶实战 🚀 （续）",
    "text": "基本布局对象：进阶实战 🚀 （续）\n\n# 绘制直方图\nnp.random.seed(20180201)\ns = np.random.randn(2, 50)\naxes[0, 1].hist(s[0], bins = 10, color='skyblue', edgecolor='black') # 10个柱子的直方图，并设置颜色\naxes[0, 1].set_title('Histogram')\nplt.show()\n\n\n\n\n\n\n\nNumPy：Python 数值计算的基石 🧱\n\n\n\nNumPy（Numerical Python）是 Python 科学计算的基础库，它提供了强大的 N 维数组对象 ndarray，以及用于对数组进行高效操作的各种函数。NumPy 是数据分析、机器学习等领域不可或缺的工具。\nnp.random.randn(2, 50) 用于生成一个形状为 (2, 50) 的数组，其中的元素服从标准正态分布（均值为 0，标准差为 1）。"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象进阶实战-续-1",
    "href": "qmd/chapter8.html#基本布局对象进阶实战-续-1",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：进阶实战 🚀 （续）",
    "text": "基本布局对象：进阶实战 🚀 （续）\n\n# 绘制散点图\naxes[1, 0].scatter(s[0], s[1], color='coral', marker='o') # 绘制散点图，设置颜色，标记\naxes[1, 0].set_title('Scatter Plot')\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#基本布局对象进阶实战-续-2",
    "href": "qmd/chapter8.html#基本布局对象进阶实战-续-2",
    "title": "信息技术基础 🚀",
    "section": "基本布局对象：进阶实战 🚀 （续）",
    "text": "基本布局对象：进阶实战 🚀 （续）\n\n# 绘制饼图\nlabels = 'Taxi', 'Metro', 'Walk', 'Bus', 'Bicycle', 'Drive'\nsizes = [10, 30, 5, 25, 5, 25]\nexplode = (0, 0.1, 0, 0, 0, 0)  # 突出显示 \"Metro\"\naxes[1, 1].pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)\naxes[1, 1].axis('equal')  # 确保饼图是圆形的\naxes[1, 1].set_title('Pie Chart')\n\nplt.tight_layout() # 自动调整子图参数, 使之填充整个图像区域\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#subplot-与-axes兄弟情深",
    "href": "qmd/chapter8.html#subplot-与-axes兄弟情深",
    "title": "信息技术基础 🚀",
    "section": "Subplot 与 Axes：兄弟情深 🤝",
    "text": "Subplot 与 Axes：兄弟情深 🤝\n\nSubplot 是 Axes 的子类，它们之间有着密切的关系。\nadd_subplot() 方法实际上创建了一个 Axes 对象，并将其添加到 Figure 的子图网格中。\nAxes 提供了更丰富的方法来定制图表，例如设置坐标轴范围、添加标题、添加图例等。"
  },
  {
    "objectID": "qmd/chapter8.html#subplot-与-axes兄弟情深---代码解释",
    "href": "qmd/chapter8.html#subplot-与-axes兄弟情深---代码解释",
    "title": "信息技术基础 🚀",
    "section": "Subplot 与 Axes：兄弟情深 🤝 - 代码解释",
    "text": "Subplot 与 Axes：兄弟情深 🤝 - 代码解释\n\n\n\n\n\n\nNote\n\n\n\n从上图可以看出，add_subplot() 方法返回的是 AxesSubplot 对象，它是 Axes 的子类。"
  },
  {
    "objectID": "qmd/chapter8.html#直接创建并选中-subplot一步到位",
    "href": "qmd/chapter8.html#直接创建并选中-subplot一步到位",
    "title": "信息技术基础 🚀",
    "section": "直接创建并选中 Subplot：一步到位 🎯",
    "text": "直接创建并选中 Subplot：一步到位 🎯\n除了使用 add_subplot() 方法外，还可以使用 matplotlib.pyplot.subplot() 方法直接创建一个 Subplot 并将其设置为当前活动的 Subplot，这样后续的绘图操作都会在这个 Subplot 上进行。\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\naxe = plt.subplot(2, 2, 1)  # 创建一个 2x2 的子图网格，并选中第一个子图\n# 在第一个子图中绘制一些内容...\naxe.plot([1,2,3,4,5], [2,4,1,5,2])\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#直接创建并选中-subplot一步到位-续",
    "href": "qmd/chapter8.html#直接创建并选中-subplot一步到位-续",
    "title": "信息技术基础 🚀",
    "section": "直接创建并选中 Subplot：一步到位 🎯 （续）",
    "text": "直接创建并选中 Subplot：一步到位 🎯 （续）\n\naxe = plt.subplot(2, 2, 3)  # 选中第三个子图\n# 在第三个子图中绘制一些内容...\naxe.scatter([1,2,3,4,5], [2,4,1,5,2])\n\nfig.suptitle('Example of multiple subplots')\nplt.show()\n\n\n\n\n\n\n\nTip\n\n\n\n激活状态的图表：谁是主角？ 🎬\n在 Matplotlib 中，可以同时存在多个 Figure 和 Axes 对象。处于激活状态的 Figure 或 Axes 是指当前正在进行绘图操作的对象。可以使用 plt.gcf() 获取当前活动的 Figure，使用 plt.gca() 获取当前活动的 Axes。"
  },
  {
    "objectID": "qmd/chapter8.html#figure-的构成细节决定成败",
    "href": "qmd/chapter8.html#figure-的构成细节决定成败",
    "title": "信息技术基础 🚀",
    "section": "Figure 的构成：细节决定成败 🔍",
    "text": "Figure 的构成：细节决定成败 🔍\n一个 Figure 对象通常包含以下元素，它们共同构成了图表的完整信息：\n\n坐标轴刻度 (Tick): 坐标轴上的标记，用于指示数据值。\n图表标题 (Title): 图表的名称，概括图表的主题。\n图例 (Legend): 用于解释图表中不同元素的含义，例如不同颜色或线型代表的数据系列。\n其他装饰元素： 如图例、网格线、文本注释等，用于增强图表的可读性和美观性。\n\n所有这些元素都可以通过 Matplotlib 提供的接口进行修改，让你的图表更加个性化。"
  },
  {
    "objectID": "qmd/chapter8.html#图表样式修改与装饰项接口让你的图表焕然一新",
    "href": "qmd/chapter8.html#图表样式修改与装饰项接口让你的图表焕然一新",
    "title": "信息技术基础 🚀",
    "section": "图表样式修改与装饰项接口：让你的图表焕然一新 ✨",
    "text": "图表样式修改与装饰项接口：让你的图表焕然一新 ✨\nMatplotlib 提供了丰富的接口来修改图表的样式和添加装饰项，让你可以随心所欲地定制图表的外观，打造出独具风格的可视化作品。\n\n修改线条样式和颜色： 可以使用 plot() 函数的 linestyle 和 color 参数来控制线条的样式和颜色，让你的曲线更加生动。\n修改坐标轴刻度和标签： 可以使用 set_xticks()、set_yticks()、set_xticklabels() 和 set_yticklabels() 方法来控制坐标轴的刻度和标签，让你的图表更加清晰易读。\n添加文字注释： 可以使用 text() 和 annotate() 方法在图表中添加文字注释，突出显示重要信息或添加解释说明。"
  },
  {
    "objectID": "qmd/chapter8.html#修改图表样式线条的舞步",
    "href": "qmd/chapter8.html#修改图表样式线条的舞步",
    "title": "信息技术基础 🚀",
    "section": "修改图表样式：线条的舞步 💃",
    "text": "修改图表样式：线条的舞步 💃\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axe = plt.subplots()\n\n# 绘制第一条曲线\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\naxe.plot(t, s, color='black', linestyle='-', linewidth=2)  # 黑色实线，线宽为2\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#修改图表样式线条的舞步-续",
    "href": "qmd/chapter8.html#修改图表样式线条的舞步-续",
    "title": "信息技术基础 🚀",
    "section": "修改图表样式：线条的舞步 💃（续）",
    "text": "修改图表样式：线条的舞步 💃（续）\n\n# 绘制第二条曲线\ns = np.sin(2 * np.pi * (t + 0.5))\naxe.plot(t, s, color='cyan', linestyle='--', linewidth=1.5, marker='o', markersize=4)  # 青色虚线, 加点标记\n\nplt.show()\n\n在上面的例子中，我们使用了 color、linestyle、linewidth、marker 和 markersize 等参数来定制线条的样式。"
  },
  {
    "objectID": "qmd/chapter8.html#常用线条样式和颜色参数色彩与形态的交响曲",
    "href": "qmd/chapter8.html#常用线条样式和颜色参数色彩与形态的交响曲",
    "title": "信息技术基础 🚀",
    "section": "常用线条样式和颜色参数：色彩与形态的交响曲 🌈",
    "text": "常用线条样式和颜色参数：色彩与形态的交响曲 🌈\n\n\n\ncolor 参数值\n含义\nlinestyle 参数值\n含义\n\n\n\n\n'r'\n红色 🔴\n'-'\n实线\n\n\n'y'\n黄色 🟡\n'--'\n虚线 (短划线)\n\n\n'g'\n绿色 🟢\n'-.'\n点划线\n\n\n'c'\n青色 🔵\n':'\n虚线 (点)\n\n\n'b'\n蓝色 🔵\n\n\n\n\n'm'\n紫红色 🟣\n\n\n\n\n'w'\n白色 ⚪\n\n\n\n\n'k'\n黑色 ⚫"
  },
  {
    "objectID": "qmd/chapter8.html#修改装饰项坐标轴的刻度与标签",
    "href": "qmd/chapter8.html#修改装饰项坐标轴的刻度与标签",
    "title": "信息技术基础 🚀",
    "section": "修改装饰项：坐标轴的刻度与标签 📏",
    "text": "修改装饰项：坐标轴的刻度与标签 📏\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axe = plt.subplots()\n\n# 绘制两条曲线（与上一个示例相同）\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\naxe.plot(t, s, color='k', linestyle='-', label='Line 1')\ns = np.sin(2 * np.pi * (t + 0.5))\naxe.plot(t, s, color='c', linestyle='--', label='Line 2')\n\n# 设置坐标轴刻度\naxe.set_xticks(np.arange(0.0, 2.5, 0.5))  # 设置 x 轴刻度\naxe.set_yticks([-1, 0, 1])  # 设置 y 轴刻度\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#修改装饰项坐标轴的刻度与标签-续",
    "href": "qmd/chapter8.html#修改装饰项坐标轴的刻度与标签-续",
    "title": "信息技术基础 🚀",
    "section": "修改装饰项：坐标轴的刻度与标签 📏 （续）",
    "text": "修改装饰项：坐标轴的刻度与标签 📏 （续）\n\naxe.minorticks_on()  # 显示 minor ticks\n\n# 修改x轴刻度标签\naxe.set_xticklabels(['零', '0.5', '壹', '1.5', '二'], fontproperties='SimHei') #设置中文字体\n\n# 移动坐标轴\naxe.spines['right'].set_color('none')  # 隐藏右侧边框\naxe.spines['top'].set_color('none')  # 隐藏顶部边框\naxe.spines['bottom'].set_position(('data', 0))  # 将 x 轴移动到 y=0 的位置\naxe.spines['left'].set_position(('data', 0))  # 将 y 轴移动到 x=0 的位置\n\n# 添加图例\naxe.legend(loc='upper right', bbox_to_anchor=(1.25, 1.05))\n\nplt.show()\n\n在上面的例子中，我们使用了 set_xticks()、set_yticks()、minorticks_on()、set_xticklabels() 和 spines 等方法来定制坐标轴的样式。我们还使用fontproperties='SimHei'显示了中文标签。"
  },
  {
    "objectID": "qmd/chapter8.html#添加注释画龙点睛之笔",
    "href": "qmd/chapter8.html#添加注释画龙点睛之笔",
    "title": "信息技术基础 🚀",
    "section": "添加注释：画龙点睛之笔 🖋️",
    "text": "添加注释：画龙点睛之笔 🖋️\n\ntext() 方法：在图表的指定位置添加文本，就像在画布上写字一样。\n\nx, y: 文本的坐标，指定文本框左下角的位置。\ns: 文本内容，可以是任何你想表达的信息。\nfontsize: 字体大小，让你的文字更醒目。\ncolor: 字体颜色，让你的文字更出彩。\nbbox: 用于设置文本框的样式，如背景颜色、边框等，让你的文字更具个性。\n\nannotate() 方法：在图表的指定位置添加带箭头的注释，就像给图表中的某个点添加一个标注。\n\ns: 注释文本，说明你要标注的内容。\nxy: 箭头指向的坐标，指定你要标注的点。\nxytext: 注释文本的坐标，指定文本框的位置。\narrowprops: 用于设置箭头的样式，如颜色、箭头类型等，让你的标注更清晰。"
  },
  {
    "objectID": "qmd/chapter8.html#添加注释实战演练",
    "href": "qmd/chapter8.html#添加注释实战演练",
    "title": "信息技术基础 🚀",
    "section": "添加注释：实战演练 ⚔️",
    "text": "添加注释：实战演练 ⚔️\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axe = plt.subplots()\naxe.plot(np.arange(0, 24, 2), [14, 9, 7, 5, 12, 19, 23, 26, 27, 24, 21, 19], '-o')\naxe.set_xticks(np.arange(0, 24, 2))\n\n# 添加箭头注释\naxe.annotate('最高温度出现在 16:00', xy=(16, 27), xytext=(16, 22),\n             arrowprops=dict(facecolor='black', shrink=0.05, connectionstyle=\"arc3,rad=.2\"), #箭头弯曲\n             horizontalalignment='center', verticalalignment='center')\nplt.show()\n\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 26368 (\\N{CJK UNIFIED IDEOGRAPH-6700}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 39640 (\\N{CJK UNIFIED IDEOGRAPH-9AD8}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 28201 (\\N{CJK UNIFIED IDEOGRAPH-6E29}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 24230 (\\N{CJK UNIFIED IDEOGRAPH-5EA6}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 20986 (\\N{CJK UNIFIED IDEOGRAPH-51FA}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 29616 (\\N{CJK UNIFIED IDEOGRAPH-73B0}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 22312 (\\N{CJK UNIFIED IDEOGRAPH-5728}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)"
  },
  {
    "objectID": "qmd/chapter8.html#添加注释实战演练-续",
    "href": "qmd/chapter8.html#添加注释实战演练-续",
    "title": "信息技术基础 🚀",
    "section": "添加注释：实战演练 ⚔️ （续）",
    "text": "添加注释：实战演练 ⚔️ （续）\n\n# 添加文本注释\naxe.text(12, 10, '日期: 2018年3月26日', bbox={'facecolor': 'cyan', 'alpha': 0.3, 'pad': 6})\n\nplt.show()\n\n在上面的例子中，我们使用了 annotate() 方法添加了一个带箭头的注释，指出了最高温度出现的时间。我们还使用了 text() 方法添加了一个文本注释，说明了数据的日期。"
  },
  {
    "objectID": "qmd/chapter8.html#基础图表绘制数据可视化百宝箱",
    "href": "qmd/chapter8.html#基础图表绘制数据可视化百宝箱",
    "title": "信息技术基础 🚀",
    "section": "基础图表绘制：数据可视化百宝箱 🧰",
    "text": "基础图表绘制：数据可视化百宝箱 🧰\nMatplotlib 提供了绘制各种常见图表类型的函数，就像一个百宝箱，里面装满了各种绘图工具，让你可以轻松应对不同的数据可视化需求。\n\n直方图 (hist()): 显示数据分布的频数或频率，就像数据的“体检报告”。\n散点图 (scatter()): 显示两个变量之间的关系，就像探索数据“星座”的奥秘。\n饼图 (pie()): 显示各部分占总体的比例，就像切蛋糕一样，清晰展现数据的组成。\n柱状图 (bar()): 比较不同类别的数据，就像数据的“身高”比拼。\n折线图 (plot()): 显示数据随时间变化的趋势，就像数据的“心电图”。\n表格 (table()): 在图表中显示表格数据，让数据一目了然。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制直方图数据的体检报告",
    "href": "qmd/chapter8.html#绘制直方图数据的体检报告",
    "title": "信息技术基础 🚀",
    "section": "绘制直方图：数据的“体检报告” 📊",
    "text": "绘制直方图：数据的“体检报告” 📊\n直方图用于显示数据集中各个区间内数据值出现的频数或频率。通过直方图，我们可以大致了解数据集的分布情况，判断数据是否集中在某个区间，是否存在异常值等。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成随机数据\ndata = np.random.standard_normal(1000) # 生成1000个标准正态分布的随机数\nbins = 50 # 设置柱子的数量\n\n# 绘制直方图\nfig, ax = plt.subplots()\nax.hist(data, bins, color='skyblue', edgecolor='black') # 设置柱子的颜色和边框颜色\nax.set_title(r'Histogram')\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们使用了 hist() 函数绘制了一个直方图。data 参数指定了要绘制的数据，bins 参数指定了柱子的数量。我们还使用了 color 和 edgecolor 参数来定制柱子的颜色和边框颜色。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制带有正态分布密度曲线的直方图更上一层楼",
    "href": "qmd/chapter8.html#绘制带有正态分布密度曲线的直方图更上一层楼",
    "title": "信息技术基础 🚀",
    "section": "绘制带有正态分布密度曲线的直方图：更上一层楼 📈",
    "text": "绘制带有正态分布密度曲线的直方图：更上一层楼 📈\n我们可以在直方图上叠加一条正态分布密度曲线，以便更直观地观察数据的分布是否接近正态分布。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成随机数据\ndata = np.random.standard_normal(1000)\nnumber_of_bins = 50\n\n# 绘制直方图\nfig, ax = plt.subplots()\nn, bins, patch = ax.hist(data, number_of_bins, density=True, color='skyblue', edgecolor='black') # density=True 表示绘制频率直方图\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#绘制带有正态分布密度曲线的直方图更上一层楼-续",
    "href": "qmd/chapter8.html#绘制带有正态分布密度曲线的直方图更上一层楼-续",
    "title": "信息技术基础 🚀",
    "section": "绘制带有正态分布密度曲线的直方图：更上一层楼 📈（续）",
    "text": "绘制带有正态分布密度曲线的直方图：更上一层楼 📈（续）\n\n# 计算正态分布密度曲线\nstandard_data = ((1 / (np.sqrt(2 * np.pi) * 1)) * np.exp(-0.5 * (1 / 1 * (bins - 0))**2))\n\n# 绘制正态分布密度曲线\nax.plot(bins, standard_data, 'orange', '-', linewidth=2) # 设置曲线颜色和线宽\n\nplt.show()\n\n\n\n\n\n\n\nNote\n\n\n\n这里补充说明一下正态分布的概率密度函数公式：\n\\[\nf(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}\n\\]\n其中：\n\n\\(\\mu\\) 是正态分布的均值。\n\\(\\sigma\\) 是正态分布的标准差。\n\\(e\\) 是自然对数的底数。\n\\(\\pi\\) 是圆周率。\n\nstandard_data = ((1 / (np.sqrt(2 * np.pi) * 1)) * np.exp(-0.5 * (1 / 1 * (bins - 0))**2)) 这行代码就是根据上述公式计算标准正态分布（均值为 0，标准差为 1）在 bins 中每个点处的概率密度。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制散点图探索数据星座的奥秘",
    "href": "qmd/chapter8.html#绘制散点图探索数据星座的奥秘",
    "title": "信息技术基础 🚀",
    "section": "绘制散点图：探索数据“星座”的奥秘 🌌",
    "text": "绘制散点图：探索数据“星座”的奥秘 🌌\n散点图用于显示两个变量之间的关系。将样本数据绘制在二维平面上，可以直观地显示这些点的分布情况，判断两个变量之间是否存在线性关系、非线性关系或其他关系。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成随机数据\nN = 60\nnp.random.seed(100)\nx = np.random.rand(N)\ny = np.random.rand(N)\n\n# 绘制散点图\nfig, axe = plt.subplots()\naxe.scatter(x, y, color='coral', marker='o', s=50) # 设置散点的颜色、标记和大小\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们使用了 scatter() 函数绘制了一个散点图。x 和 y 参数分别指定了散点的横坐标和纵坐标。我们还使用了 color、marker 和 s 参数来定制散点的颜色、标记和大小。"
  },
  {
    "objectID": "qmd/chapter8.html#自定义散点图-marker让你的散点图与众不同",
    "href": "qmd/chapter8.html#自定义散点图-marker让你的散点图与众不同",
    "title": "信息技术基础 🚀",
    "section": "自定义散点图 Marker：让你的散点图与众不同 🌟",
    "text": "自定义散点图 Marker：让你的散点图与众不同 🌟\nscatter() 函数提供了丰富的参数来定制散点图中 Marker 的样式：\n\ns: Marker 的大小，可以是一个标量，也可以是一个数组，用于指定每个散点的大小。\nc: Marker 的颜色，可以是一个颜色名称、RGB 值或 RGBA 值，也可以是一个数组，用于指定每个散点的颜色。\nalpha: Marker 的透明度，取值范围为 0（完全透明）到 1（完全不透明）。\nmarker: Marker 的形状，可以是各种预定义的形状，如 'o' (圆形)、's' (方形)、'^' (三角形) 等。"
  },
  {
    "objectID": "qmd/chapter8.html#自定义-marker实战演练",
    "href": "qmd/chapter8.html#自定义-marker实战演练",
    "title": "信息技术基础 🚀",
    "section": "自定义 Marker：实战演练 ⚔️",
    "text": "自定义 Marker：实战演练 ⚔️\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成随机数据\nN = 60\nnp.random.seed(100)\nx = np.random.rand(N)\ny = np.random.rand(N)\ns = np.pi * (10 * np.random.rand(N))**2  # 使用随机数生成 Marker 的大小\nc = np.random.rand(N)  # 使用随机数生成 Marker 的颜色\nopacity = 0.7\n\n# 绘制散点图\nfig, axe = plt.subplots()\nsc = axe.scatter(x, y, s, c, alpha=opacity, cmap='viridis') # 使用 cmap 参数指定颜色映射\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#自定义-marker实战演练-续",
    "href": "qmd/chapter8.html#自定义-marker实战演练-续",
    "title": "信息技术基础 🚀",
    "section": "自定义 Marker：实战演练 ⚔️（续）",
    "text": "自定义 Marker：实战演练 ⚔️（续）\n\nfig.colorbar(sc) #添加颜色条\n\nplt.show()\n\n在这个例子中，我们使用了 cmap='viridis'，让散点的颜色根据 c 值在 viridis 颜色映射中变化。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制饼图切蛋糕的艺术",
    "href": "qmd/chapter8.html#绘制饼图切蛋糕的艺术",
    "title": "信息技术基础 🚀",
    "section": "绘制饼图：切蛋糕的艺术 🍰",
    "text": "绘制饼图：切蛋糕的艺术 🍰\n饼图用于显示某一类别数据在全部样本数据中所占的百分比，就像切蛋糕一样，可以清晰地展现数据的组成。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 准备数据\nlabels = 'Taxi', 'Metro', 'Walk', 'Bus', 'Bicycle', 'Drive'\nsizes = [10, 30, 5, 25, 5, 25]\nexplode = (0, 0.1, 0, 0, 0, 0)  # 突出显示 \"Metro\"\n\n# 绘制饼图\nfig, axe = plt.subplots()\naxe.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90, colors=['skyblue', 'coral', 'lightgreen', 'gold', 'plum', 'lightsalmon']) # 设置每个扇形的颜色\naxe.axis('equal')  # 确保饼图是圆形的\naxe.set_title('Pie Chart')\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们使用了 pie() 函数绘制了一个饼图。sizes 参数指定了每个扇形的大小，labels 参数指定了每个扇形的标签，explode 参数指定了要突出显示的扇形，autopct 参数指定了百分比的显示格式，shadow 参数指定了是否显示阴影，startangle 参数指定了起始角度。我们还使用了 colors 参数来定制每个扇形的颜色。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制柱状图数据的身高比拼",
    "href": "qmd/chapter8.html#绘制柱状图数据的身高比拼",
    "title": "信息技术基础 🚀",
    "section": "绘制柱状图：数据的“身高”比拼 📏",
    "text": "绘制柱状图：数据的“身高”比拼 📏\n柱状图用于比较不同类别的数据，就像数据的“身高”比拼，可以直观地反映不同类别数据之间的数量差异。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 准备数据\ndata_m = (40, 60, 120, 180, 20, 200)  # 男性\ndata_f = (30, 100, 150, 30, 20, 50)  # 女性\nindex = np.arange(6)\nwidth = 0.35 # 柱子的宽度\nlabels = ('Taxi', 'Metro', 'Walk', 'Bus', 'Bicycle', 'Driving')\n\n# 绘制柱状图\nfig, axe = plt.subplots()\nrects1 = axe.bar(index, data_m, width, color='skyblue', label='Men') # 男性柱子\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#绘制柱状图数据的身高比拼-续",
    "href": "qmd/chapter8.html#绘制柱状图数据的身高比拼-续",
    "title": "信息技术基础 🚀",
    "section": "绘制柱状图：数据的“身高”比拼 📏（续）",
    "text": "绘制柱状图：数据的“身高”比拼 📏（续）\n\nrects2 = axe.bar(index + width, data_f, width, color='coral', label='Women') # 女性柱子\naxe.set_xticks(index + width / 2)\naxe.set_xticklabels(labels)\naxe.legend()\n\n# 添加数据标签\ndef autolabel(rects):\n    \"\"\"在每个柱形顶部添加数据标签\"\"\"\n    for rect in rects:\n        height = rect.get_height()\n        axe.annotate('{}'.format(height),\n                    xy=(rect.get_x() + rect.get_width() / 2, height),\n                    xytext=(0, 3),  # 3 points vertical offset\n                    textcoords=\"offset points\",\n                    ha='center', va='bottom')\n\nautolabel(rects1)\nautolabel(rects2)\n\nplt.show()\n\n在上面的例子中，我们使用了 bar() 函数绘制了一个柱状图。index 参数指定了柱子的横坐标，data_m 和 data_f 参数分别指定了男性和女性柱子的高度，width 参数指定了柱子的宽度，color 参数指定了柱子的颜色，label 参数指定了柱子的标签。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制堆叠柱状图更上一层楼",
    "href": "qmd/chapter8.html#绘制堆叠柱状图更上一层楼",
    "title": "信息技术基础 🚀",
    "section": "绘制堆叠柱状图：更上一层楼 🏢",
    "text": "绘制堆叠柱状图：更上一层楼 🏢\n我们可以在柱状图的基础上绘制堆叠柱状图，将不同类别的数据堆叠在一起，更清晰地展现数据的组成。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 准备数据（与上一个示例相同）\ndata_m = (40, 60, 120, 180, 20, 200)\ndata_f = (30, 100, 150, 30, 20, 50)\nindex = np.arange(6)\nwidth = 0.35\nlabels = ('Taxi', 'Metro', 'Walk', 'Bus', 'Bicycle', 'Driving')\n\n# 绘制堆叠柱状图\nfig, axe = plt.subplots()\naxe.bar(index, data_m, width, color='skyblue', label='Men')\naxe.bar(index, data_f, width, color='coral', bottom=data_m, label='Women')  # 使用 bottom 参数堆叠柱形\naxe.set_xticks(index + width / 2)\naxe.set_xticklabels(labels)\naxe.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们使用了 bottom 参数来指定堆叠柱状图的底部，将女性柱子堆叠在男性柱子之上。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制并排和部分重叠柱状图各显神通",
    "href": "qmd/chapter8.html#绘制并排和部分重叠柱状图各显神通",
    "title": "信息技术基础 🚀",
    "section": "绘制并排和部分重叠柱状图：各显神通 🤼",
    "text": "绘制并排和部分重叠柱状图：各显神通 🤼\n我们还可以绘制并排柱状图或部分重叠柱状图，以不同的方式展示数据的对比。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 准备数据（与上一个示例相同）\ndata_m = (40, 60, 120, 180, 20, 200)\ndata_f = (30, 100, 150, 30, 20, 50)\nindex = np.arange(6)\nwidth = 0.4\nlabels = ('Taxi', 'Metro', 'Walk', 'Bus', 'Bicycle', 'Driving')\n\n# 绘制并排柱状图\nfig, axe = plt.subplots()\naxe.bar(index - width/2, data_m, width, color='skyblue', align='center', label='Men')  # 使用 align='center' 使柱形居中\naxe.bar(index + width/2, data_f, width, color='coral', align='center', label='Women')  # 使用 align='edge' 使柱形部分重叠\naxe.set_xticks(index)\naxe.set_xticklabels(labels)\naxe.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们调整了柱子的横坐标和 align 参数，使得男性和女性的柱子并排显示。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制水平柱状图并添加透明度换个角度看世界",
    "href": "qmd/chapter8.html#绘制水平柱状图并添加透明度换个角度看世界",
    "title": "信息技术基础 🚀",
    "section": "绘制水平柱状图并添加透明度：换个角度看世界 🔄",
    "text": "绘制水平柱状图并添加透明度：换个角度看世界 🔄\n我们还可以绘制水平柱状图，并添加透明度，让图表更具层次感。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 准备数据（与上一个示例相同）\ndata_m = (40, 60, 120, 180, 20, 200)\ndata_f = (30, 100, 150, 30, 20, 50)\nindex = np.arange(6)\nwidth = 0.35\nopacity = 0.7 #设置透明度\nlabels = ('Taxi', 'Metro', 'Walk', 'Bus', 'Bicycle', 'Driving')\n\n# 绘制水平柱状图\nfig, axe = plt.subplots()\naxe.barh(index, data_m, width, color='skyblue', align='center', alpha=opacity, label='Men')  # 使用 barh() 绘制水平柱状图\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#绘制水平柱状图并添加透明度换个角度看世界-续",
    "href": "qmd/chapter8.html#绘制水平柱状图并添加透明度换个角度看世界-续",
    "title": "信息技术基础 🚀",
    "section": "绘制水平柱状图并添加透明度：换个角度看世界 🔄（续）",
    "text": "绘制水平柱状图并添加透明度：换个角度看世界 🔄（续）\n\naxe.barh(index + width, data_f, width, color='coral', align='center', alpha=opacity, label='Women')\naxe.set_yticks(index +width / 2)\naxe.set_yticklabels(labels)\naxe.legend()\n\nplt.show()\n\n在这个例子中，我们使用了 barh() 函数来绘制水平柱状图，并使用 alpha 参数设置了柱子的透明度。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制折线图数据的心电图",
    "href": "qmd/chapter8.html#绘制折线图数据的心电图",
    "title": "信息技术基础 🚀",
    "section": "绘制折线图：数据的“心电图” 💓",
    "text": "绘制折线图：数据的“心电图” 💓\n折线图用于显示数据随时间变化的趋势，就像数据的“心电图”，可以清晰地展示数据的变化规律。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成随机数据\nnp.random.seed(100)\nx = np.arange(0, 10, 1)\ny1 = np.random.rand(10)\ny2 = np.random.rand(10)\n\n# 绘制折线图\nfig, axe = plt.subplots()\naxe.plot(x, y1, '-o', color='skyblue', label='Line 1')  # 使用 '-o' 绘制带圆点的实线\naxe.plot(x, y2, '--o', color='coral', label='Line 2')  # 使用 '--o' 绘制带圆点的虚线\naxe.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们使用了 plot() 函数绘制了两条折线图。x 参数指定了横坐标，y1 和 y2 参数分别指定了两条折线的纵坐标。我们还使用了 '-o' 和 '--o' 来指定线型和标记，并使用 color 参数设置了线条颜色。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制表格数据一目了然",
    "href": "qmd/chapter8.html#绘制表格数据一目了然",
    "title": "信息技术基础 🚀",
    "section": "绘制表格：数据一目了然 📃",
    "text": "绘制表格：数据一目了然 📃\ntable() 函数可以在图表中显示表格数据，让数据更加清晰易读。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 准备数据（与柱状图示例相同）\ndata_m = (40, 60, 120, 180, 20, 200)\ndata_f = (30, 100, 150, 30, 20, 50)\nindex = np.arange(6)\nwidth = 0.4\ncolumns = ('Taxi', 'Metro', 'Walk', 'Bus', 'Bicycle', 'Driving')\nrows = ('Male', 'Female')\ndata = (data_m, data_f)\n\n# 绘制柱状图（可选）\nfig, axe = plt.subplots()\naxe.bar(index, data_m, width, color='skyblue', label='Men')\naxe.bar(index, data_f, width, color='coral', bottom=data_m, label='Women')\naxe.set_xticks([])  # 隐藏 x 轴刻度\naxe.legend()\n\n# 添加表格\naxe.table(cellText=data, rowLabels=rows, colLabels=columns, loc='bottom', bbox=[0, -0.5, 1, 0.3])  # 使用 bbox 参数调整表格位置\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n上述代码中，bbox=[0, -0.5, 1, 0.3] 的含义是：\n\n0: 表格左边缘的 x 坐标（相对于 Axes 宽度）。\n-0.5: 表格下边缘的 y 坐标（相对于 Axes 高度）。\n1: 表格的宽度（相对于 Axes 宽度）。\n0.3: 表格的高度（相对于 Axes 高度）。"
  },
  {
    "objectID": "qmd/chapter8.html#不同坐标系下的图像世界不止一面",
    "href": "qmd/chapter8.html#不同坐标系下的图像世界不止一面",
    "title": "信息技术基础 🚀",
    "section": "不同坐标系下的图像：世界不止一面 🌐",
    "text": "不同坐标系下的图像：世界不止一面 🌐\n除了常见的平面直角坐标系外，Matplotlib 还支持在其他坐标系下绘制图像，例如极坐标系。\n\n极坐标方程: 在极坐标系中，点的坐标由半径 (ρ) 和角度 (θ) 表示，而不是平面直角坐标系中的 (x, y)。\n双纽线: 一种具有特殊形状的曲线，其极坐标方程为 ρ² = a²cos(2θ)。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制极坐标系下的双纽线展现曲线之美",
    "href": "qmd/chapter8.html#绘制极坐标系下的双纽线展现曲线之美",
    "title": "信息技术基础 🚀",
    "section": "绘制极坐标系下的双纽线：展现曲线之美 🌀",
    "text": "绘制极坐标系下的双纽线：展现曲线之美 🌀\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成角度数据\ntheta_list = np.arange(0, 2 * np.pi, 0.01)\n\n# 计算半径数据\nr = [2 * np.cos(2 * theta) for theta in theta_list]\n\n# 创建极坐标系\naxe = plt.subplot(projection='polar')  # 使用 projection='polar' 创建极坐标系\n\n# 绘制双纽线\naxe.plot(theta_list, r, color='skyblue', linewidth=2)\n\n# 隐藏半径刻度\naxe.set_rticks([])\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们首先使用 np.arange() 函数生成了一系列角度值，然后根据双纽线的极坐标方程计算了对应的半径值。接着，我们使用 plt.subplot(projection='polar') 创建了一个极坐标系，并使用 plot() 函数绘制了双纽线。最后，我们使用 set_rticks([]) 隐藏了半径刻度。"
  },
  {
    "objectID": "qmd/chapter8.html#matplotlib-3d立体世界触手可及",
    "href": "qmd/chapter8.html#matplotlib-3d立体世界触手可及",
    "title": "信息技术基础 🚀",
    "section": "Matplotlib 3D：立体世界，触手可及 🌍",
    "text": "Matplotlib 3D：立体世界，触手可及 🌍\n除了二维图表外，Matplotlib 还提供了绘制三维图表的功能，让你可以从多个角度观察数据，发现更多隐藏的信息。\n\nmpl_toolkits.mplot3d: Matplotlib 的一个工具包，提供了绘制三维图表的类和函数。\nAxes3D: 用于创建三维坐标系的类，是绘制三维图表的基础。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制-3d-散点图-使用-axes3d星辰大海",
    "href": "qmd/chapter8.html#绘制-3d-散点图-使用-axes3d星辰大海",
    "title": "信息技术基础 🚀",
    "section": "绘制 3D 散点图 (使用 Axes3D)：星辰大海 ✨",
    "text": "绘制 3D 散点图 (使用 Axes3D)：星辰大海 ✨\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 生成随机数据\nN = 60\nnp.random.seed(100)\nx = np.random.rand(N)\ny = np.random.rand(N)\nz = np.random.rand(N)\n\n# 创建 3D 坐标系\nfig = plt.figure()\naxe = Axes3D(fig, auto_add_to_figure=False)  # 使用 Axes3D 创建 3D 坐标系\nfig.add_axes(axe)\n\n# 绘制 3D 散点图\naxe.scatter(x, y, z, c='skyblue', marker='o')\n\n# 设置坐标轴标签\naxe.set_xlabel('X')\naxe.set_ylabel('Y')\naxe.set_zlabel('Z')\n\nplt.show()\n\n\n\n\n\n\n\n\n在上面的例子中，我们首先导入了 mpl_toolkits.mplot3d 中的 Axes3D 类。然后，我们使用 Axes3D(fig) 创建了一个三维坐标系，并使用 scatter() 函数绘制了三维散点图。最后，我们使用 set_xlabel()、set_ylabel() 和 set_zlabel() 方法设置了坐标轴标签。 &gt; 注意：在较新的matplotlib版本中，创建Axes3D对象时，需要设置auto_add_to_figure=False参数，并手动将Axes3D对象添加到figure中。"
  },
  {
    "objectID": "qmd/chapter8.html#绘制-3d-散点图-使用-pyplot殊途同归",
    "href": "qmd/chapter8.html#绘制-3d-散点图-使用-pyplot殊途同归",
    "title": "信息技术基础 🚀",
    "section": "绘制 3D 散点图 (使用 pyplot)：殊途同归 🎯",
    "text": "绘制 3D 散点图 (使用 pyplot)：殊途同归 🎯\n除了使用 Axes3D 类外，我们还可以直接使用 pyplot 模块的 subplot() 函数，并指定 projection='3d' 来创建三维坐标系。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成随机数据（与上一个示例相同）\nN = 60\nnp.random.seed(100)\nx = np.random.rand(N)\ny = np.random.rand(N)\nz = np.random.rand(N)\n\n# 创建 3D 坐标系\nfig = plt.figure()\naxe = plt.subplot(projection='3d')  # 使用 projection='3d' 创建 3D 坐标系\n\n# 绘制 3D 散点图\naxe.scatter(x, y, z, c='coral', marker='^') # 使用不同的颜色和标记\n\n# 设置坐标轴标签\naxe.set_xlabel('X')\naxe.set_ylabel('Y')\naxe.set_zlabel('Z')\n\nplt.show()"
  },
  {
    "objectID": "qmd/chapter8.html#matplotlib-与-jupyter-结合珠联璧合",
    "href": "qmd/chapter8.html#matplotlib-与-jupyter-结合珠联璧合",
    "title": "信息技术基础 🚀",
    "section": "Matplotlib 与 Jupyter 结合：珠联璧合 💎",
    "text": "Matplotlib 与 Jupyter 结合：珠联璧合 💎\n将 Matplotlib 与 Jupyter Notebook 结合使用，可以方便地创建图文并茂、格式精美的文档，让你的数据分析更上一层楼。\n\n丰富的图表 API: Matplotlib 提供了各种图表类型的绘制函数，让你可以轻松创建各种可视化效果。\nLaTeX 数学公式支持: 可以在 Jupyter Notebook 中使用 LaTeX 语法编写数学公式，让你的文档更加专业。\nMarkdown 文本支持: 可以使用 Markdown 语法编写文本内容，让你的文档更加易读。\n\n\n\n\n\n\n\nTip\n\n\n\n文档组成部分 - Markdown Cell: 用于编写文本内容、介绍双纽线的概念、公式和绘图方法。 - Code Cell: 用于编写 Python 代码，生成双纽线的图像。"
  },
  {
    "objectID": "qmd/chapter8.html#总结matplotlib数据可视化的魔法师",
    "href": "qmd/chapter8.html#总结matplotlib数据可视化的魔法师",
    "title": "信息技术基础 🚀",
    "section": "总结：Matplotlib，数据可视化的魔法师 🧙‍",
    "text": "总结：Matplotlib，数据可视化的魔法师 🧙‍\n\nMatplotlib 是一个功能强大且易于使用的 Python 绘图库，是数据可视化的利器。\n掌握 Matplotlib 的基本布局对象 (Figure、Axes、Subplot) 和常用图表类型，让你的数据栩栩如生。\n可以自定义图表的样式和装饰项，创建美观的可视化效果，让你的图表独一无二。\nMatplotlib 与 Jupyter Notebook 结合，可以创建交互式的图文并茂的文档，让你的数据分析更上一层楼。"
  },
  {
    "objectID": "qmd/chapter8.html#思考与讨论",
    "href": "qmd/chapter8.html#思考与讨论",
    "title": "信息技术基础 🚀",
    "section": "思考与讨论 🤔",
    "text": "思考与讨论 🤔\n\n除了本章介绍的图表类型外，Matplotlib 还支持哪些图表类型？ 🤔\n如何使用 Matplotlib 创建交互式图表？ 💡\n在实际的数据分析项目中，你会如何使用 Matplotlib 进行数据可视化？ 🚀\n除了课件中提到的，还有哪些方法可以修改图表的默认样式？ 🎨\n如何将 Matplotlib 绘制的图表保存为图片文件？ 💾\n如何调整图表的大小和分辨率？ 📐"
  },
  {
    "objectID": "qmd/chapter1.html",
    "href": "qmd/chapter1.html",
    "title": "信息技术基础",
    "section": "",
    "text": "🔍 海量数据背后蕴藏的知识\n🔄 数据分析与数据挖掘的关系\n🤖 机器学习与数据分析的关系\n\n\n\n👣 数据分析的基本步骤\n🐍 Python和数据分析"
  },
  {
    "objectID": "qmd/chapter1.html#数据蕴含了大量知识",
    "href": "qmd/chapter1.html#数据蕴含了大量知识",
    "title": "信息技术基础",
    "section": "数据蕴含了大量知识 💡",
    "text": "数据蕴含了大量知识 💡\n\n\n\n\n\n\nflowchart LR\n    A[对象] --&gt;|观察现象| B(数据);\n    B --&gt;|归纳总结| C[规律];\n\n\n\n\nFigure 1: 从数据到知识的转化过程\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n对象（Object）: 我们观察和研究的对象，可以是人、事、物等。"
  },
  {
    "objectID": "qmd/chapter1.html#数据蕴含了大量知识-1",
    "href": "qmd/chapter1.html#数据蕴含了大量知识-1",
    "title": "信息技术基础",
    "section": "数据蕴含了大量知识 💡",
    "text": "数据蕴含了大量知识 💡\n\n\n\n\n\n\nflowchart LR\n    A[对象] --&gt;|观察现象| B(数据);\n    B --&gt;|归纳总结| C[规律];\n\n\n\n\nFigure 2: 从数据到知识的转化过程\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n观察现象 (Observation): 通过各种方式（如传感器、问卷调查、人工记录等）收集关于对象的信息。"
  },
  {
    "objectID": "qmd/chapter1.html#数据蕴含了大量知识-2",
    "href": "qmd/chapter1.html#数据蕴含了大量知识-2",
    "title": "信息技术基础",
    "section": "数据蕴含了大量知识 💡",
    "text": "数据蕴含了大量知识 💡\n\n\n\n\n\n\nflowchart LR\n    A[对象] --&gt;|观察现象| B(数据);\n    B --&gt;|归纳总结| C[规律];\n\n\n\n\nFigure 3: 从数据到知识的转化过程\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n数据 (Data): 对观察到的现象进行量化或编码后的结果。例如，温度传感器记录的温度值、问卷调查中的选项、文本记录中的关键词等。"
  },
  {
    "objectID": "qmd/chapter1.html#数据蕴含了大量知识-3",
    "href": "qmd/chapter1.html#数据蕴含了大量知识-3",
    "title": "信息技术基础",
    "section": "数据蕴含了大量知识 💡",
    "text": "数据蕴含了大量知识 💡\n\n\n\n\n\n\nflowchart LR\n    A[对象] --&gt;|观察现象| B(数据);\n    B --&gt;|归纳总结| C[规律];\n\n\n\n\nFigure 4: 从数据到知识的转化过程\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n归纳总结 (Induction & Summarization): 对数据进行分析、处理，找出其中的规律、模式、趋势等。"
  },
  {
    "objectID": "qmd/chapter1.html#数据蕴含了大量知识-4",
    "href": "qmd/chapter1.html#数据蕴含了大量知识-4",
    "title": "信息技术基础",
    "section": "数据蕴含了大量知识 💡",
    "text": "数据蕴含了大量知识 💡\n\n\n\n\n\n\nflowchart LR\n    A[对象] --&gt;|观察现象| B(数据);\n    B --&gt;|归纳总结| C[规律];\n\n\n\n\nFigure 5: 从数据到知识的转化过程\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n规律 (Pattern/Rule): 从数据中提炼出的可重复、可验证的知识。"
  },
  {
    "objectID": "qmd/chapter1.html#数据蕴含了大量知识-5",
    "href": "qmd/chapter1.html#数据蕴含了大量知识-5",
    "title": "信息技术基础",
    "section": "数据蕴含了大量知识 💡",
    "text": "数据蕴含了大量知识 💡\n举例：\n一家电商公司（对象）通过用户浏览记录、购买记录等（观察现象）收集了大量的用户行为数据（数据）。通过对这些数据进行分析（归纳总结），发现用户在晚上8点到10点之间购买量最大（规律）。"
  },
  {
    "objectID": "qmd/chapter1.html#规律可用于",
    "href": "qmd/chapter1.html#规律可用于",
    "title": "信息技术基础",
    "section": "规律可用于",
    "text": "规律可用于\n\n解释当前发生的事情 🧐\n\n案例: 通过分析历史销售数据，发现某款产品在夏季销量最高，可以解释为什么当前该产品销量很好。\n\n预测未来的情况 🔮\n\n案例: 利用历史股票价格数据，可以构建模型预测未来股票价格的走势。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析的意义案例分析",
    "href": "qmd/chapter1.html#数据分析的意义案例分析",
    "title": "信息技术基础",
    "section": "数据分析的意义：案例分析",
    "text": "数据分析的意义：案例分析\n\n案例1：电商推荐系统 🛍️\n\n背景: 电商平台每天都会产生大量的用户浏览、搜索、购买等数据。\n目标: 通过分析这些数据，了解用户的兴趣偏好，为用户推荐他们可能感兴趣的商品，提高用户满意度和销售额。\n方法: 使用协同过滤、内容推荐等算法，分析用户的历史行为，找到与用户兴趣相似的其他用户或商品，进行推荐。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析的意义案例分析-1",
    "href": "qmd/chapter1.html#数据分析的意义案例分析-1",
    "title": "信息技术基础",
    "section": "数据分析的意义：案例分析",
    "text": "数据分析的意义：案例分析\n\n案例2：金融风控 🏦\n\n背景: 金融机构需要评估贷款申请人的信用风险，决定是否批准贷款以及贷款的利率。\n目标: 通过分析申请人的个人信息、信用记录、财务状况等数据，预测申请人违约的可能性。\n方法: 使用逻辑回归、决策树、支持向量机等机器学习算法，构建信用评分模型，对申请人进行风险评估。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析的意义案例分析-2",
    "href": "qmd/chapter1.html#数据分析的意义案例分析-2",
    "title": "信息技术基础",
    "section": "数据分析的意义：案例分析",
    "text": "数据分析的意义：案例分析\n\n案例3：医疗诊断 🩺\n\n背景: 医院每天都会产生大量的病人病历、检查报告、影像资料等数据。\n目标: 通过分析这些数据，辅助医生进行疾病诊断，提高诊断的准确性和效率。\n方法: 使用自然语言处理技术分析病历文本，使用图像识别技术分析医学影像，结合机器学习算法，构建疾病诊断模型。"
  },
  {
    "objectID": "qmd/chapter1.html#统计分析的含义",
    "href": "qmd/chapter1.html#统计分析的含义",
    "title": "信息技术基础",
    "section": "统计分析的含义",
    "text": "统计分析的含义\n\n\n\n\n\n\nTip\n\n\n\n在已定假设、先验约束上，对数据进行整理、筛选和加工，并得到信息的过程。"
  },
  {
    "objectID": "qmd/chapter1.html#统计分析的含义-1",
    "href": "qmd/chapter1.html#统计分析的含义-1",
    "title": "信息技术基础",
    "section": "统计分析的含义",
    "text": "统计分析的含义\n\n已定假设、先验约束: 指在分析之前，已经有了一些关于数据的假设或预期。\n整理、筛选和加工: 对数据进行清洗、转换、选择等操作，去除噪声、异常值，提取有用的特征。"
  },
  {
    "objectID": "qmd/chapter1.html#统计分析的含义-2",
    "href": "qmd/chapter1.html#统计分析的含义-2",
    "title": "信息技术基础",
    "section": "统计分析的含义",
    "text": "统计分析的含义\n\n\n\n\n\n\nTip\n\n\n\n信息: 从数据得出的一些初步结论和结果。例如：平均值、方差、相关性等。"
  },
  {
    "objectID": "qmd/chapter1.html#统计分析的含义-3",
    "href": "qmd/chapter1.html#统计分析的含义-3",
    "title": "信息技术基础",
    "section": "统计分析的含义",
    "text": "统计分析的含义\n举例： 假设我们已经知道，用户年龄和购买金额可能存在正相关。那么，我们就可以选择年龄和购买金额这两个feature，计算它们的相关系数。如果相关系数为正，说明两者确实存在正相关，验证了我们的假设。"
  },
  {
    "objectID": "qmd/chapter1.html#数据挖掘的含义",
    "href": "qmd/chapter1.html#数据挖掘的含义",
    "title": "信息技术基础",
    "section": "数据挖掘的含义",
    "text": "数据挖掘的含义\n\n\n\n\n\n\nTip\n\n\n\n在数据分析得到信息的基础上进一步获得认知，转为有效的预测和决策。"
  },
  {
    "objectID": "qmd/chapter1.html#数据挖掘的含义-1",
    "href": "qmd/chapter1.html#数据挖掘的含义-1",
    "title": "信息技术基础",
    "section": "数据挖掘的含义",
    "text": "数据挖掘的含义\n\n认知: 对数据背后更深层次的规律、模式的理解。"
  },
  {
    "objectID": "qmd/chapter1.html#数据挖掘的含义-2",
    "href": "qmd/chapter1.html#数据挖掘的含义-2",
    "title": "信息技术基础",
    "section": "数据挖掘的含义",
    "text": "数据挖掘的含义\n\n\n\n\n\n\nTip\n\n\n\n有效的预测和决策: 基于认知，可以对未来进行预测，或做出更明智的决策。"
  },
  {
    "objectID": "qmd/chapter1.html#数据挖掘的含义-3",
    "href": "qmd/chapter1.html#数据挖掘的含义-3",
    "title": "信息技术基础",
    "section": "数据挖掘的含义",
    "text": "数据挖掘的含义\n举例： 在统计分析得出用户年龄和购买金额存在正相关的结论后，我们可以使用线性回归等算法，建立一个预测模型。输入用户的年龄，预测其购买金额。这样就将信息转化为了认知和预测能力。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析-统计分析-数据挖掘",
    "href": "qmd/chapter1.html#数据分析-统计分析-数据挖掘",
    "title": "信息技术基础",
    "section": "数据分析 = 统计分析 + 数据挖掘",
    "text": "数据分析 = 统计分析 + 数据挖掘\n\n\n\n\n\n\nflowchart LR\n    A[数据] --&gt;|统计分析| B(信息);\n    B --&gt;|数据挖掘| C[知识];\n\n\n\n\nFigure 6: 数据分析、统计分析与数据挖掘的关系"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析-统计分析-数据挖掘-1",
    "href": "qmd/chapter1.html#数据分析-统计分析-数据挖掘-1",
    "title": "信息技术基础",
    "section": "数据分析 = 统计分析 + 数据挖掘",
    "text": "数据分析 = 统计分析 + 数据挖掘\n\n统计分析：数据预处理阶段 🧹\n\n主要关注数据的基本特征、分布、相关性等。\n常用的方法包括描述性统计、假设检验、方差分析等。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析-统计分析-数据挖掘-2",
    "href": "qmd/chapter1.html#数据分析-统计分析-数据挖掘-2",
    "title": "信息技术基础",
    "section": "数据分析 = 统计分析 + 数据挖掘",
    "text": "数据分析 = 统计分析 + 数据挖掘\n\n数据挖掘：知识发现阶段 🕵️‍♀️\n\n主要关注从数据中发现更深层次的模式、规律。\n常用的方法包括聚类分析、分类分析、关联分析、预测建模等。"
  },
  {
    "objectID": "qmd/chapter1.html#机器学习的含义",
    "href": "qmd/chapter1.html#机器学习的含义",
    "title": "信息技术基础",
    "section": "机器学习的含义",
    "text": "机器学习的含义\n\n\n\n\n\n\nImportant\n\n\n\n利用经验来改善计算机系统自身的性能。"
  },
  {
    "objectID": "qmd/chapter1.html#机器学习的含义-1",
    "href": "qmd/chapter1.html#机器学习的含义-1",
    "title": "信息技术基础",
    "section": "机器学习的含义",
    "text": "机器学习的含义\n\n经验在计算机系统中主要以数据形式存在."
  },
  {
    "objectID": "qmd/chapter1.html#机器学习的含义-2",
    "href": "qmd/chapter1.html#机器学习的含义-2",
    "title": "信息技术基础",
    "section": "机器学习的含义",
    "text": "机器学习的含义\n\n计算机程序通过分析数据，学习数据中的规律，从而在面对新的数据时，能够做出更准确的判断或预测。"
  },
  {
    "objectID": "qmd/chapter1.html#机器学习的含义-3",
    "href": "qmd/chapter1.html#机器学习的含义-3",
    "title": "信息技术基础",
    "section": "机器学习的含义",
    "text": "机器学习的含义\n案例：垃圾邮件过滤\n\n经验：大量的已标记为垃圾邮件或非垃圾邮件的邮件数据。\n学习：机器学习算法（如朴素贝叶斯、支持向量机等）分析这些邮件数据，学习垃圾邮件和非垃圾邮件的特征（如关键词、发件人等）。\n性能改善：学习后的模型可以自动识别新的邮件是否为垃圾邮件，准确率会随着训练数据的增加而提高。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析的含义再强调",
    "href": "qmd/chapter1.html#数据分析的含义再强调",
    "title": "信息技术基础",
    "section": "数据分析的含义（再强调）",
    "text": "数据分析的含义（再强调）\n\n\n\n\n\n\nImportant\n\n\n\n识别出巨量数据中有效的、新颖的、潜在有用的、最终可理解的模式的非平凡过程，即从海量数据中找到有用的知识。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析的含义再强调-1",
    "href": "qmd/chapter1.html#数据分析的含义再强调-1",
    "title": "信息技术基础",
    "section": "数据分析的含义（再强调）",
    "text": "数据分析的含义（再强调）\n\n有效的（Valid）：发现的模式必须在新的数据上也能成立，具有泛化能力。\n新颖的（Novel）：发现的模式是以前未知的，能够带来新的洞见。\n潜在有用的（Potentially Useful）：发现的模式能够用于实际的应用场景，解决实际问题。\n最终可理解的（Ultimately Understandable）：发现的模式必须是人类可以理解的，不能是黑盒子。"
  },
  {
    "objectID": "qmd/chapter1.html#两者之间的关系",
    "href": "qmd/chapter1.html#两者之间的关系",
    "title": "信息技术基础",
    "section": "两者之间的关系",
    "text": "两者之间的关系\n\n机器学习是数据分析的重要工具。数据分析过程经常需要利用机器学习算法来发现数据中的模式。\n数据分析为机器学习提供数据和问题。机器学习算法需要大量的数据进行训练，而数据分析可以帮助我们理解数据、提出问题，为机器学习提供方向。"
  },
  {
    "objectID": "qmd/chapter1.html#数据收集",
    "href": "qmd/chapter1.html#数据收集",
    "title": "信息技术基础",
    "section": "1. 数据收集 📦",
    "text": "1. 数据收集 📦\n\n数据来源:\n\n内部数据: 企业自身的业务数据，如销售记录、用户行为数据、生产数据等。\n外部数据: 来自第三方的数据，如行业报告、市场调研数据、公开数据集等。\n公开数据：政府、研究机构等发布的公开数据。\n网络爬虫：从网页上抓取数据。"
  },
  {
    "objectID": "qmd/chapter1.html#数据收集-1",
    "href": "qmd/chapter1.html#数据收集-1",
    "title": "信息技术基础",
    "section": "1. 数据收集 📦",
    "text": "1. 数据收集 📦\n\n数据类型:\n\n结构化数据: 具有固定格式的数据，如数据库中的表格数据。\n非结构化数据: 没有固定格式的数据，如文本、图片、音频、视频等。\n半结构化数据: 介于结构化和非结构化之间的数据，如XML、JSON格式的数据。"
  },
  {
    "objectID": "qmd/chapter1.html#数据收集-2",
    "href": "qmd/chapter1.html#数据收集-2",
    "title": "信息技术基础",
    "section": "1. 数据收集 📦",
    "text": "1. 数据收集 📦\n\n大数据特点:\n\n大量 (Volume): 数据量巨大。\n多样 (Variety): 数据类型多样。\n高速 (Velocity): 数据产生和处理速度快。\n价值 (Value): 数据中蕴含着巨大的价值，但价值密度较低。\n真实性（Veracity）: 数据的质量和可信度。"
  },
  {
    "objectID": "qmd/chapter1.html#数据预处理",
    "href": "qmd/chapter1.html#数据预处理",
    "title": "信息技术基础",
    "section": "2. 数据预处理 🧹",
    "text": "2. 数据预处理 🧹\n\n目标: 将原始数据转化为高质量的数据，为后续的分析和建模做准备。"
  },
  {
    "objectID": "qmd/chapter1.html#数据预处理-1",
    "href": "qmd/chapter1.html#数据预处理-1",
    "title": "信息技术基础",
    "section": "2. 数据预处理 🧹",
    "text": "2. 数据预处理 🧹\n\n主要任务:\n\n数据清洗:\n\n缺失值处理: 填充缺失值（如均值、中位数、众数、模型预测值等）或删除缺失值。\n异常值处理: 检测和处理异常值（如删除、替换、分箱等）。\n重复值处理: 检测和删除重复值。"
  },
  {
    "objectID": "qmd/chapter1.html#数据预处理-2",
    "href": "qmd/chapter1.html#数据预处理-2",
    "title": "信息技术基础",
    "section": "2. 数据预处理 🧹",
    "text": "2. 数据预处理 🧹\n\n主要任务:\n\n数据转换:\n\n标准化/归一化: 将不同量纲的数据缩放到同一范围。\n离散化: 将连续数据划分为若干区间。\n特征编码: 将非数值型特征转换为数值型特征（如One-Hot编码、Label编码等）。"
  },
  {
    "objectID": "qmd/chapter1.html#数据预处理-3",
    "href": "qmd/chapter1.html#数据预处理-3",
    "title": "信息技术基础",
    "section": "2. 数据预处理 🧹",
    "text": "2. 数据预处理 🧹\n\n主要任务:\n\n数据选择:\n\n特征选择: 选择对分析目标有用的特征。\n样本选择: 选择具有代表性的样本。\n数据抽样：为了减少计算量，对数据进行抽样。\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n数据预处理是数据分析中非常重要的环节，数据质量的好坏直接影响到后续分析结果的准确性和可靠性。通常会占到整个数据分析流程60%以上的时间。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析与知识发现",
    "href": "qmd/chapter1.html#数据分析与知识发现",
    "title": "信息技术基础",
    "section": "3. 数据分析与知识发现 🕵️‍♀️",
    "text": "3. 数据分析与知识发现 🕵️‍♀️\n\n将预处理后的数据进行进一步的分析，完成信息到认知的过程。"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析与知识发现-1",
    "href": "qmd/chapter1.html#数据分析与知识发现-1",
    "title": "信息技术基础",
    "section": "3. 数据分析与知识发现 🕵️‍♀️",
    "text": "3. 数据分析与知识发现 🕵️‍♀️\n\n方法分类\n\n有监督学习：\n\n分类（Classification）：预测数据的类别标签。如：判断一封邮件是否为垃圾邮件、判断一张图片中的物体是什么。\n\n常用算法：\n\n逻辑回归（Logistic Regression）\n决策树（Decision Tree）\n支持向量机（Support Vector Machine）\n朴素贝叶斯（Naive Bayes）\n随机森林（Random Forest）\nK近邻（K-Nearest Neighbors）"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析与知识发现-2",
    "href": "qmd/chapter1.html#数据分析与知识发现-2",
    "title": "信息技术基础",
    "section": "3. 数据分析与知识发现 🕵️‍♀️",
    "text": "3. 数据分析与知识发现 🕵️‍♀️\n\n方法分类\n\n有监督学习：\n\n回归（Regression）：预测数据的连续值。如：预测房价、预测股票价格。\n\n常用算法：\n\n线性回归（Linear Regression）\n多项式回归（Polynomial Regression）\n支持向量回归（Support Vector Regression）\n决策树回归（Decision Tree Regression）\n随机森林回归（Random Forest Regression）"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析与知识发现-3",
    "href": "qmd/chapter1.html#数据分析与知识发现-3",
    "title": "信息技术基础",
    "section": "3. 数据分析与知识发现 🕵️‍♀️",
    "text": "3. 数据分析与知识发现 🕵️‍♀️\n\n方法分类\n\n有监督学习：\n\n关联分析（Association Analysis）：发现数据中项集之间的关联规则。如：购物篮分析，发现哪些商品经常被一起购买。\n\n常用算法：\n\nApriori\nFP-Growth"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析与知识发现-4",
    "href": "qmd/chapter1.html#数据分析与知识发现-4",
    "title": "信息技术基础",
    "section": "3. 数据分析与知识发现 🕵️‍♀️",
    "text": "3. 数据分析与知识发现 🕵️‍♀️\n\n方法分类\n\n无监督学习：\n\n聚类（Clustering）：将数据划分为若干个群组，使得同一群组内的数据相似度较高，不同群组之间的数据相似度较低。如：客户细分、文档聚类。\n\n常用算法：\n\nK-Means\n层次聚类（Hierarchical Clustering）\nDBSCAN"
  },
  {
    "objectID": "qmd/chapter1.html#数据分析与知识发现-5",
    "href": "qmd/chapter1.html#数据分析与知识发现-5",
    "title": "信息技术基础",
    "section": "3. 数据分析与知识发现 🕵️‍♀️",
    "text": "3. 数据分析与知识发现 🕵️‍♀️\n\n方法分类\n\n无监督学习：\n\n异常检测（Anomaly Detection）：识别数据中的异常值或异常模式。如：信用卡欺诈检测、网络入侵检测。\n\n常用算法：\n\n基于统计的方法（如Z-score、箱线图）\n基于距离的方法（如K近邻）\n基于密度的方法（如DBSCAN）\n孤立森林（Isolation Forest）"
  },
  {
    "objectID": "qmd/chapter1.html#数据后处理",
    "href": "qmd/chapter1.html#数据后处理",
    "title": "信息技术基础",
    "section": "4. 数据后处理 📊",
    "text": "4. 数据后处理 📊\n\n结果评估: 对数据分析的结果进行评估，判断其是否有效、可靠。\n\n分类模型评估指标: 准确率、精确率、召回率、F1值、ROC曲线、AUC等。\n回归模型评估指标: 均方误差、均方根误差、平均绝对误差、R方等。\n聚类模型评估指标: 轮廓系数、Calinski-Harabasz指数等。"
  },
  {
    "objectID": "qmd/chapter1.html#数据后处理-1",
    "href": "qmd/chapter1.html#数据后处理-1",
    "title": "信息技术基础",
    "section": "4. 数据后处理 📊",
    "text": "4. 数据后处理 📊\n\n结果呈现: 将数据分析的结果以直观、易懂的方式呈现给用户。\n\n数据可视化: 使用图表、图形等展示数据。\n报告撰写: 将数据分析的过程、结果、结论等以书面形式呈现。"
  },
  {
    "objectID": "qmd/chapter1.html#数据后处理-2",
    "href": "qmd/chapter1.html#数据后处理-2",
    "title": "信息技术基础",
    "section": "4. 数据后处理 📊",
    "text": "4. 数据后处理 📊\n\n结果应用: 将数据分析的结果应用于实际业务场景，解决实际问题。\n\n决策支持: 为决策者提供数据支持，辅助决策。\n模型部署: 将训练好的模型部署到生产环境中，进行实时预测或分类。"
  },
  {
    "objectID": "qmd/chapter1.html#专用数据分析语言",
    "href": "qmd/chapter1.html#专用数据分析语言",
    "title": "信息技术基础",
    "section": "专用数据分析语言",
    "text": "专用数据分析语言\n\nR 语言: 统计分析和数据可视化\nMatlab: 科学计算和工程应用\nSas: 商业分析和数据挖掘\nSpss: 统计分析和社会科学研究"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势面向生产",
    "href": "qmd/chapter1.html#python的优势面向生产",
    "title": "信息技术基础",
    "section": "Python的优势：面向生产",
    "text": "Python的优势：面向生产\n\n大部分数据分析过程需要首先进行实验性研究和原型构建，再移植到生产系统中。"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势面向生产-1",
    "href": "qmd/chapter1.html#python的优势面向生产-1",
    "title": "信息技术基础",
    "section": "Python的优势：面向生产",
    "text": "Python的优势：面向生产\n\nPython 适用于原型构建，且能够直接将分析程序运用到生产系统中。"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势面向生产-2",
    "href": "qmd/chapter1.html#python的优势面向生产-2",
    "title": "信息技术基础",
    "section": "Python的优势：面向生产",
    "text": "Python的优势：面向生产\n\n其他的分析语言，则需要使用其他语言（如C/C++）重写代码，才能部署到生产环境。"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势强大的第三方库",
    "href": "qmd/chapter1.html#python的优势强大的第三方库",
    "title": "信息技术基础",
    "section": "Python的优势：强大的第三方库",
    "text": "Python的优势：强大的第三方库\n\nPython 的强大功能依赖于第三方库实现。"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势强大的第三方库-1",
    "href": "qmd/chapter1.html#python的优势强大的第三方库-1",
    "title": "信息技术基础",
    "section": "Python的优势：强大的第三方库",
    "text": "Python的优势：强大的第三方库\n\n常用数据分析库包括：\n\nNumpy: 提供高性能的数值计算功能。\n\n多维数组对象（ndarray）\n线性代数运算\n随机数生成"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势强大的第三方库-2",
    "href": "qmd/chapter1.html#python的优势强大的第三方库-2",
    "title": "信息技术基础",
    "section": "Python的优势：强大的第三方库",
    "text": "Python的优势：强大的第三方库\n\n常用数据分析库包括：\n\nScipy: 提供科学计算工具，如统计分析、信号处理等。\n\n统计分布和检验\n优化算法\n信号处理\n图像处理"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势强大的第三方库-3",
    "href": "qmd/chapter1.html#python的优势强大的第三方库-3",
    "title": "信息技术基础",
    "section": "Python的优势：强大的第三方库",
    "text": "Python的优势：强大的第三方库\n\n常用数据分析库包括：\n\nPandas: 提供数据处理和分析工具，如数据清洗、转换、聚合等。\n\nSeries 和 DataFrame 数据结构\n数据读取和写入（CSV、Excel、SQL等）\n数据清洗和转换\n数据分组和聚合\n时间序列分析"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势强大的第三方库-4",
    "href": "qmd/chapter1.html#python的优势强大的第三方库-4",
    "title": "信息技术基础",
    "section": "Python的优势：强大的第三方库",
    "text": "Python的优势：强大的第三方库\n\n常用数据分析库包括：\n\nScikit-learn: 提供机器学习算法库，如分类、回归、聚类等。\n\n各种机器学习算法（分类、回归、聚类、降维等）\n模型选择和评估\n数据预处理\n流水线（Pipeline）"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势强大的第三方库-5",
    "href": "qmd/chapter1.html#python的优势强大的第三方库-5",
    "title": "信息技术基础",
    "section": "Python的优势：强大的第三方库",
    "text": "Python的优势：强大的第三方库\n\n常用数据分析库包括：\n\nMatplotlib: 提供数据可视化工具，如绘制各种图表。\n\n折线图、散点图、柱状图、直方图、饼图等\n自定义图表样式\n交互式绘图"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势强大的第三方库-6",
    "href": "qmd/chapter1.html#python的优势强大的第三方库-6",
    "title": "信息技术基础",
    "section": "Python的优势：强大的第三方库",
    "text": "Python的优势：强大的第三方库\n\n常用数据分析库包括：\n\nSeaborn: 基于Matplotlib的高级可视化库\nPlotly: 交互式可视化图表"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势胶水语言特性",
    "href": "qmd/chapter1.html#python的优势胶水语言特性",
    "title": "信息技术基础",
    "section": "Python的优势：胶水语言特性",
    "text": "Python的优势：胶水语言特性\n\nPython 语言的底层可以用 C 语言实现，使用 C 语言实现的算法性能很高。"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势胶水语言特性-1",
    "href": "qmd/chapter1.html#python的优势胶水语言特性-1",
    "title": "信息技术基础",
    "section": "Python的优势：胶水语言特性",
    "text": "Python的优势：胶水语言特性\n\nNumpy 的底层使用 C 实现，其效率比 R 语言更高。"
  },
  {
    "objectID": "qmd/chapter1.html#python的优势胶水语言特性-2",
    "href": "qmd/chapter1.html#python的优势胶水语言特性-2",
    "title": "信息技术基础",
    "section": "Python的优势：胶水语言特性",
    "text": "Python的优势：胶水语言特性\n\nPython可以方便地调用其他语言编写的程序（如C/C++，Java等），可以把其他语言的优势集成进来。\n\n\n\n\n\n\n\nTip\n\n\n\nPython 的胶水语言特性使其能够方便地调用其他语言编写的程序，从而充分利用各种资源，提高开发效率。"
  },
  {
    "objectID": "qmd/chapter7.html",
    "href": "qmd/chapter7.html",
    "title": "信息技术基础",
    "section": "",
    "text": "本章将带你进入数据分析的奇妙世界 🌍！我们将学习如何使用 Python 中两个超级强大的工具：Pandas 和 scikit-learn，来实现各种数据分析任务。\n\n\n\n\n\n\nNote\n\n\n\n内容概要：\n\n🗂️ 分类方法: 像侦探一样🕵️‍♀️，把数据分门别类 (例如：识别不同种类的动物 🐶🐱🐰)\n📈 回归方法: 像预言家一样🔮，预测未来 (例如：预测股票价格 💸)\n🤝 聚类方法: 像组织者一样🧑‍🤝‍🧑，把相似的东西聚集起来 (例如：市场细分，把顾客分成不同的群体 🎯)\n\n\n\n我们将深入探讨这些技术背后的奥秘，并通过有趣的案例来演示它们的神奇应用！"
  },
  {
    "objectID": "qmd/chapter7.html#本章概述",
    "href": "qmd/chapter7.html#本章概述",
    "title": "信息技术基础",
    "section": "",
    "text": "本章将带你进入数据分析的奇妙世界 🌍！我们将学习如何使用 Python 中两个超级强大的工具：Pandas 和 scikit-learn，来实现各种数据分析任务。\n\n\n\n\n\n\nNote\n\n\n\n内容概要：\n\n🗂️ 分类方法: 像侦探一样🕵️‍♀️，把数据分门别类 (例如：识别不同种类的动物 🐶🐱🐰)\n📈 回归方法: 像预言家一样🔮，预测未来 (例如：预测股票价格 💸)\n🤝 聚类方法: 像组织者一样🧑‍🤝‍🧑，把相似的东西聚集起来 (例如：市场细分，把顾客分成不同的群体 🎯)\n\n\n\n我们将深入探讨这些技术背后的奥秘，并通过有趣的案例来演示它们的神奇应用！"
  },
  {
    "objectID": "qmd/chapter7.html#核心概念",
    "href": "qmd/chapter7.html#核心概念",
    "title": "信息技术基础",
    "section": "📚 核心概念",
    "text": "📚 核心概念\n在开始我们的探险之前，让我们先来认识一些重要的伙伴：\n\nPandas: Python 数据分析的瑞士军刀🇨🇭！它提供了 DataFrame 数据结构，让我们可以像操作 Excel 表格一样轻松处理数据。\n\n💡 就像一个超级 Excel 表格，可以进行数据清洗、转换、分析等操作。可以对数据进行排序、筛选、分组、聚合等操作。\n\nscikit-learn: 机器学习的百宝箱🧰！它提供了各种分类、回归、聚类算法，以及模型评估、选择等工具。\n\n🤖️ 就像一个机器学习工具箱，包含了各种常用的算法和工具。可以用来构建预测模型、进行数据挖掘等。"
  },
  {
    "objectID": "qmd/chapter7.html#核心概念-1",
    "href": "qmd/chapter7.html#核心概念-1",
    "title": "信息技术基础",
    "section": "📚 核心概念",
    "text": "📚 核心概念\n\n分类 (Classification): 将数据划分到不同的类别中。\n\n🍎🍊 将水果分成苹果和橘子。\n📧 垃圾邮件识别：将邮件分成垃圾邮件和正常邮件。\n\n回归 (Regression): 预测一个连续值。\n\n📈 预测明天的气温。\n🏠 房价预测：根据房屋的特征（面积、位置等）预测房价。\n\n聚类 (Clustering): 将相似的数据点分组到一起。\n\n👥 将客户分成不同的群体，以便进行更有针对性的营销。\n📰 新闻主题分类：将新闻文章按照主题进行分组。"
  },
  {
    "objectID": "qmd/chapter7.html#核心概念-2",
    "href": "qmd/chapter7.html#核心概念-2",
    "title": "信息技术基础",
    "section": "📚 核心概念",
    "text": "📚 核心概念\n\nPython: 一种流行的编程语言，以其易学性和强大的数据科学生态系统而闻名。\n\n🐍 是一种解释型、高级和通用的编程语言。\nPython 由 Guido van Rossum 创建，并于 1991 年首次发布。\nPython 的设计哲学强调代码的可读性和简洁的语法 (尤其是使用空格缩进来划分代码块，而不是使用大括号或关键字)。\nPython 支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。"
  },
  {
    "objectID": "qmd/chapter7.html#核心概念-3",
    "href": "qmd/chapter7.html#核心概念-3",
    "title": "信息技术基础",
    "section": "📚 核心概念",
    "text": "📚 核心概念\n\n信息技术（Information Technology, IT）：指的是利用计算机、网络、通信等技术来处理、管理和传输信息的领域。广义上，IT涵盖了硬件、软件、数据和通信等多个方面。\n\n🌐 IT是现代社会的基础设施，支持着各行各业的运作。\nIT 的应用非常广泛，包括但不限于：\n\n数据存储和管理\n软件开发和应用\n网络和通信\n信息安全\n人工智能和机器学习"
  },
  {
    "objectID": "qmd/chapter7.html#分类方法",
    "href": "qmd/chapter7.html#分类方法",
    "title": "信息技术基础",
    "section": "7.1 分类方法",
    "text": "7.1 分类方法\n分类方法就像一个智能分类器，能够将不同类型的数据区分开来。让我们来看看有哪些神奇的分类器吧！\n\nLogistic 回归\n\n实现:\n\nsklearn.linear_model.LogisticRegression\n\n支持:\n\n二分类 (binary) 🎯：判断是或否 (例如：是否患病)\n一对多分类 (one vs rest) 🥊：多个类别中选择一个 (例如：识别手写数字 0-9)\n多项式回归 ➕：处理非线性关系\n可以选择 L1 或 L2 正则化 💪：防止模型过拟合\n\n\n\n\nLogistic 回归：概念解释\n\nLogistic Regression: 是一种广义的线性回归分析模型，虽然名字里有“回归”，但实际上是用来解决分类问题的。它通过一个叫做 Sigmoid 的函数，将线性回归的输出映射到 0 到 1 之间，表示属于某一类的概率。\n\n📌 例如：判断一封邮件是否为垃圾邮件。\n\n\n\n\nSigmoid 函数\nSigmoid 函数，也称为逻辑函数，是一个 S 形曲线，其数学表达式为：\n\\[\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\n\\]\n其中：\n\n\\(z\\) 是输入值（可以是任意实数）。\n\\(e\\) 是自然对数的底数（欧拉数，约等于 2.71828）。\n\\(\\sigma(z)\\) 是输出值，范围在 0 到 1 之间。\n\nSigmoid函数的图像如下：\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef sigmoid(x):\n  return 1 / (1 + np.exp(-x))\n\nx = np.linspace(-10, 10, 100)\ny = sigmoid(x)\n\nplt.figure(figsize=(6, 4))\nplt.plot(x, y)\nplt.title('Sigmoid Function')\nplt.xlabel('x')\nplt.ylabel('sigmoid(x)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: Sigmoid 函数图像\n\n\n\n\n\n\n\nSigmoid 函数的性质\n\nS 形曲线: Sigmoid 函数的图形呈 S 形，将输入值映射到 (0, 1) 的区间内。\n概率解释: 输出值可以被解释为概率，表示样本属于某一类的可能性。\n可微性: Sigmoid 函数是可微的，这使得它在梯度下降等优化算法中非常有用。\n非线性: Sigmoid 函数是非线性的，这使得逻辑回归可以处理非线性关系。\n\n\n\nLogistic 回归中的正则化\n\n正则化 (Regularization): 一种防止模型过拟合的技术。模型过拟合指的是模型在训练数据上表现很好，但在新数据上表现很差。\n\nL1 正则化: 倾向于产生稀疏的模型 (很多参数为 0)，可以用来进行特征选择。\n\nL1 正则化通过向损失函数添加参数向量的 L1 范数（绝对值之和）的惩罚项来实现。\n\nL2 正则化: 倾向于产生参数值较小的模型，可以提高模型的泛化能力。\n\nL2 正则化通过向损失函数添加参数向量的 L2 范数（平方和的平方根）的惩罚项来实现。\n\n\n\n\n\n\n\n\n\nLogistic回归solver选择\n\n\n\n\n\n\n\n\n\n\nCase\nSolver\n\n\n\n\nL1 正则\n“liblinear”, “saga”\n\n\n多项式损失 (multinomial loss)\n“lbfgs”, “sag”, “saga”, “newton-cg”\n\n\n大数据集 (n_samples)\n“sag”, “saga”\n\n\n\n\n\n\n\nLogistic回归solver选择\n\nliblinear:\n\n应用了坐标下降算法(Coordinate Descent)，基于 C++ 库实现，速度较快。\n对于小数据集和二分类问题，liblinear 是一个不错的选择。\n不是真正意义上的多分类模型,而是基于“one-vs-rest”思想,为每个类别训练了一个二元分类器。\n\nlbfgs, sag 和 newton-cg:\n\n只支持 L2 惩罚项，对某些高维数据收敛更快。\nlbfgs 是一种拟牛顿法(Quasi-Newton method)，适用于中小型数据集。\nnewton-cg 是一种牛顿法(Newton’s method)，需要计算海森矩阵(Hessian matrix)，适用于特征维度较少的数据集。\nsag (Stochastic Average Gradient) 是一种随机平均梯度下降算法，适用于大型数据集。\n参数 multi_class 设为 “multinomial” 即为真正的分类,其预测比 liblinear 更为准确。\n\n\n\n\nLogistic回归solver选择\n\nsag:\n\n基于平均随机梯度下降算法(Stochastic Average Gradient descent)。\n在大数据集上的表现更快,大数据集指样本量大且特征数多。\n\nsaga:\n\nsag 的变体，它支持非平滑的 L1 正则选项 penalty=\"l1\"。\n对于稀疏多项式 logistic 回归效果较好。\nsaga 也适用于大型数据集。\n\n\n\n\nLogistic回归代码示例\n\nimport numpy as np\nfrom sklearn import linear_model, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 LogisticRegression 对象，并设置 solver 为 'liblinear'\nlog_reg = linear_model.LogisticRegression(solver='liblinear')\n\n# 使用 fit 方法训练模型\nlog_reg.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(log_reg.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n# 预测概率\nprint(log_reg.predict_proba([[5.1, 3.5, 1.4, 0.2]])) # 第一个类别的概率最高\n\n[0]\n[[8.78030305e-01 1.21958900e-01 1.07949250e-05]]\n\n\n\n\nLogistic回归代码示例：代码解释\n\n导入必要的库：\n\nnumpy 用于数值计算。\nsklearn 中的 linear_model 用于逻辑回归。\ndatasets 用于加载示例数据集。\n\n加载 iris 数据集：这是一个常用的数据集，包含了三种不同类型的鸢尾花（Setosa, Versicolour, Virginica）的萼片和花瓣的长度和宽度。\n\n\n\n\n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\ntarget\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n0.0\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\n0.0\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\n0.0\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\n0.0\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\n0.0\nsetosa\n\n\n\n\n\n\n\n\n\nLogistic回归代码示例：代码解释\n\n将数据集分为特征 X (萼片和花瓣的长度和宽度) 和目标 Y (鸢尾花的种类)。\n创建一个 LogisticRegression 对象，并设置 solver 参数为 'liblinear'。\n使用 fit 方法训练模型。\n使用 predict 方法对新的数据点 [5.1, 3.5, 1.4, 0.2] 进行预测。\npredict_proba 方法返回的是一个数组，数组中的每一个数字分别代表属于每一个类别的概率。\n\n\n\nSVM (支持向量机)\n\n实现:\n\nsklearn.svm.SVC()：C-支持向量分类。\nsklearn.svm.NuSVC()：Nu-支持向量分类。\nsklearn.svm.LinearSVC()：线性支持向量分类。\n\n区别:\n\nSVC 与 NuSVC 比较接近，两者参数略有不同。SVC 使用参数 C 来控制正则化强度，而 NuSVC 使用参数 nu 来控制支持向量的数量。\nLinearSVC 仅支持线性核函数的分类，速度更快，适用于大规模数据集。\n\n\n\n\nSVM：概念解释\n\nSVM: 一种强大的分类算法，它试图找到一个最佳的超平面，将不同类别的数据分隔开。这个超平面被称为“决策边界”。\n\n🗂️ 就像在不同类别的数据之间画一条线 (或者在高维空间中画一个平面、超平面)，使得不同类别的数据点到这条线的距离尽可能远。\n\n支持向量 (Support Vectors): 离决策边界最近的那些数据点，它们决定了决策边界的位置。\n\n\n\nSVM：核函数\n\n核函数 (Kernel Function): 将数据映射到更高维空间，使得数据更容易被分隔。常用的核函数有：\n\n线性核函数 (Linear Kernel): 不做任何映射，直接在原始空间中寻找超平面。\n多项式核函数 (Polynomial Kernel): 将数据映射到多项式空间。\n径向基核函数 (RBF Kernel): 将数据映射到无限维空间。\n\n支持向量机的目标是找到能够最大化类别之间边距的超平面，从而提高分类的准确性和鲁棒性。它特别适用于高维空间的数据分类问题。\n\n\n\nSVM 代码示例\n\nimport numpy as np\nfrom sklearn import svm, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 SVC 对象，并设置 kernel 为 'rbf' (径向基核函数)\nclf1 = svm.SVC(kernel='rbf')\n\n# 创建 NuSVC 对象\nclf2 = svm.NuSVC()\n\n# 创建 LinearSVC 对象\nclf3 = svm.LinearSVC(max_iter=10000)\n\n# 使用 fit 方法训练模型\nclf1.fit(X, Y)\nclf2.fit(X, Y)\nclf3.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(clf1.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\nprint(clf2.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\nprint(clf3.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n[0]\n[0]\n[0]\n\n\n\n\nSVM：支持向量的获取\n\nsupport_vectors_: 全部支持向量\nsupport_: 支持向量在原始数据集中的索引\nn_support: 各类别的支持向量的数量 (LinearSVC 不支持)\n\n\n# 获取支持向量\nprint(clf1.support_vectors_)\n\n# 获取支持向量的索引\nprint(clf1.support_)\n\n# 获取各类别的支持向量的数量\nprint(clf1.n_support_)\n\n\n\nNearest Neighbors (最近邻)\n\n实现:\n\nsklearn.neighbors.KNeighborsClassifier()：K-近邻分类器。\nsklearn.neighbors.RadiusNeighborsClassifier()：半径近邻分类器。\n\n区别:\n\nKNeighborsClassifier: 基于每个查询点的 k 个最近邻实现。对于一个新的数据点，找到离它最近的 k 个训练数据点，然后根据这 k 个点的类别进行投票，票数最多的类别就是新数据点的预测类别。\n\nk 是用户指定的整数值，通常需要通过交叉验证等方法来选择最佳的 k 值。\n\nRadiusNeighborsClassifier: 基于每个查询点的固定半径 r 内的邻居数量实现。对于一个新的数据点，找到所有离它距离小于等于 r 的训练数据点，然后根据这些点的类别进行投票，票数最多的类别就是新数据点的预测类别。\n\n其中 r 是用户指定的浮点数值，需要根据数据的分布情况来选择合适的 r 值。\n\n\n\n\n\nNearest Neighbors：概念解释\n\nNearest Neighbors: 一种简单且直观的分类算法，它基于“物以类聚”的思想。对于一个新的数据点，找到离它最近的训练数据点（即“邻居”），然后根据这些邻居的类别来预测新数据点的类别。\n\n🚶 就像根据你周围的人群来判断你属于哪个群体。如果你周围大部分人都是医生，那么你很可能也是医生。\n\n\n\n\nNearest Neighbors 参数\n\nn_neighbors 与 radius 参数：设置 k、r 值\nweights 参数：对近邻进行加权。不同的权重策略会影响预测结果。\n\nuniform: 各个“邻居”权重相等。每个邻居对预测结果的贡献相同。\ndistance: 按照距离给各个“邻居”权重，较近点产生的影响更大。距离越近的邻居对预测结果的贡献越大。\n自定的函数：可以自定义一个函数，根据距离或其他因素来计算权重。\n\nalgorithm 参数：指定查找最近邻算法。不同的算法适用于不同的数据规模和维度。\n\nball_tree: 使用球树 (Ball Tree) 数据结构，适用于高维数据。\nkd_tree: 使用 KD 树 (K-D Tree) 数据结构，适用于低维数据。\nbrute: 使用暴力搜索 (Brute-Force Search)，对每个查询点都计算与所有训练数据点的距离，适用于小规模数据集。\nauto: 自动选择最合适的算法。\n\n\n\n\nNearest Neighbors 代码示例\n\nimport numpy as np\nfrom sklearn import neighbors, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 KNeighborsClassifier 对象，并设置 n_neighbors 为 5\nkclf = neighbors.KNeighborsClassifier(n_neighbors=5)\n\n# 创建 RadiusNeighborsClassifier 对象，并设置 radius 为 1.0\nrclf = neighbors.RadiusNeighborsClassifier(radius=1.0)\n\n# 使用 fit 方法训练模型\nkclf.fit(X, Y)\nrclf.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(kclf.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\nprint(rclf.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n[0]\n[0]\n\n\n\n\nDecision Tree (决策树)\n\n实现:\n\nsklearn.tree.DecisionTreeClassifier()\n\n概念解释:\n\nDecision Tree: 决策树是一种树状结构的分类算法，它通过一系列的 if-else 问题来对数据进行分类。\n\n🌳 就像一棵树，每个内部节点表示一个特征或属性，每个分支代表一个测试输出，每个叶节点代表一个类别。\n从根节点开始，根据数据的特征进行判断，沿着不同的分支向下走，直到到达叶节点，叶节点所代表的类别就是预测结果。\n\n\n\n\n\n决策树：更详细的解释\n\n决策树是一种直观且易于理解的分类方法。它通过递归地将数据集划分为更小的子集，并在每个子集上构建一个决策节点，最终形成一个树状结构。\n优点：\n\n易于理解和解释，可以可视化决策过程。\n可以处理数值型和类别型数据。\n不需要对数据进行预处理（如归一化）。\n\n缺点：\n\n容易过拟合，需要进行剪枝等处理。\n对数据中的噪声比较敏感。\n可能会产生偏向于某些特征的决策树。\n\n\n\n\nDecision Tree 代码示例\n\nimport numpy as np\nfrom sklearn import tree, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 DecisionTreeClassifier 对象\nclf = tree.DecisionTreeClassifier()\n\n# 使用 fit 方法训练模型\nclf.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(clf.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n[0]\n\n\n\n\nStochastic Gradient Descent (随机梯度下降)\n\n实现:\n\nsklearn.linear_model.SGDClassifier()\n\n支持:\n\n多种 loss functions (损失函数)\n多种 penalties for classification (分类处罚)\n\n概念解释:\n\nStochastic Gradient Descent: 随机梯度下降是一种优化算法，常用于训练机器学习模型，尤其是大规模数据集上的线性模型。\n\n🚀 就像一个探险家，每次只看一小步 (随机选择一个样本)，但最终也能到达目的地 (找到最优解)。\n\n\n\n\n\n随机梯度下降：更详细的解释\n\n与传统的梯度下降算法不同，SGD 每次迭代只使用一个样本来计算梯度，并更新模型参数。这样做的好处是可以大大加快训练速度，尤其是在数据集非常大的情况下。\n优点：\n\n训练速度快，适用于大规模数据集。\n可以用于在线学习 (Online Learning)，即模型可以随着新数据的到来不断更新。\n\n缺点：\n\n收敛过程可能不稳定，需要仔细调整学习率等参数。\n容易陷入局部最优解。\n\n\n\n\n随机梯度下降的参数设置\n\nloss 参数：设置损失函数\n\nhinge (默认)：soft-margin SVM，适用于线性 SVM 分类器。\nmodified_huber：平滑的 hinge 损失，对噪声更鲁棒。\nlog：logistic 回归，适用于概率分类。\nhinge、modified_huber 是惰性的，能够提高训练效率\n\nclass_weight 参数：设置分类权重，用于处理类别不平衡问题。\n\n默认所有类别权重相等，均为 1。\n用形如 “{class: weight}” 的 dict 指明权重，可以手动调整每个类别的权重。\n声明为 “balanced” 自动设置各类权重与其出现概率成反比，可以自动平衡类别权重。\n\n\n\n\nStochastic Gradient Descent 代码示例\n\nimport numpy as np\nfrom sklearn import linear_model, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 SGDClassifier 对象，并设置 loss 为 'log_loss' (logistic 回归)\nclf = linear_model.SGDClassifier(loss='log_loss', max_iter=1000, tol=1e-3)\n\n# 使用 fit 方法训练模型\nclf.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(clf.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n[0]\n\n\n\n\n\n\n\n\nTip\n\n\n\n使用时，需要预先打乱训练数据或在声明时将 “shuffle” 参数设置为 “True” (默认即为 “True”) 以在每次迭代后打乱数据\n\n\n\n\nGaussian Process Classification (高斯过程分类)\n\n实现:\n\nsklearn.gaussian_process.GaussianProcessClassifier()\n\n支持多元分类:\n\novr (默认): 每个类都训练一个二元高斯过程分类器，将该类与其余类分开\novo: 每两个类训练一个二元高斯过程分类器，将两个类分开\n对于高斯过程分类，“ovo” 策略可能在计算上更有效，但是不支持预测概率估计。\n\n\n\n\nGaussian Process Classification：概念解释\n\nGaussian Process: 高斯过程是一种概率模型，它假设任意有限个数据点的联合分布都是一个多元高斯分布。\n高斯过程分类是一种基于概率的分类方法。它假设数据点是由一个潜在的高斯过程生成的，并使用贝叶斯推断来估计后验概率。可以用于对函数的分布进行建模。\n\n📊 可以理解为对函数的“函数”进行建模，不仅可以预测函数值，还可以估计预测的不确定性。\n\n优点：\n\n可以提供预测的置信度。\n可以处理非线性关系。\n\n缺点：\n\n计算复杂度较高，不适用于大规模数据集。\n对核函数的选择比较敏感。\n\n\n\n\nGaussian Process Classification 代码示例\n\nimport numpy as np\nfrom sklearn import gaussian_process, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 GaussianProcessClassifier 对象\nclf = gaussian_process.GaussianProcessClassifier()\n\n# 使用 fit 方法训练模型\nclf.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(clf.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n[0]\n\n\n\n\nMultilayer Perceptron (多层感知器 - 神经网络)\n\n实现:\n\nsklearn.neural_network.MLPClassifier()\n\n部分细节:\n\nMLPClassifier 只支持交叉熵损失函数，通过运行 predict_proba 方法进行概率估计\nMLP 算法使用的是反向传播的方式，通过反向传播计算得到的梯度和某种形式的梯度下降来进行训练\n对于分类来说，它最小化交叉熵损失函数，为每个样本给出一个向量形式的概率估计\n\n\n\n\n神经网络：从感知器到多层感知器\n\n感知器 (Perceptron)\n\n起源: 感知器是最早的人工神经元模型，由 Frank Rosenblatt 在 1957 年提出。\n结构: 单层感知器由一个或多个输入节点、一个输出节点和一个激活函数组成。\n工作原理:\n\n输入信号乘以权重。\n对加权后的输入求和。\n将求和结果输入激活函数，产生输出。\n\n激活函数: 通常使用阶跃函数 (Heaviside step function)。\n局限性: 单层感知器只能解决线性可分问题。\n\n\n\n\n多层感知器 (Multilayer Perceptron, MLP)\n\n突破: 为了解决线性不可分问题，引入了多层感知器。\n结构: MLP 是一种前馈神经网络，由多个层组成：\n\n输入层: 接收原始数据。\n隐藏层: 对数据进行非线性变换。可以有多个隐藏层。\n输出层: 输出预测结果。\n\n神经元: 每个层包含多个神经元，神经元之间全连接。\n激活函数: 隐藏层通常使用非线性激活函数，如 Sigmoid、ReLU、tanh 等。\n反向传播 (Backpropagation): 一种用于训练神经网络的算法，它通过计算损失函数对每个参数的梯度，来更新神经网络的权重。\n\n\n\n神经网络的优点和缺点\n\n优点：\n\n可以学习复杂的非线性关系。\n具有较强的泛化能力。\n可以处理高维数据。\n\n缺点：\n\n训练时间较长。\n容易陷入局部最优解。\n需要仔细调整网络结构和参数。\n可解释性较差。\n\n\n\n\n神经网络的应用\n\n图像识别\n语音识别\n自然语言处理\n推荐系统\n金融预测\n…\n\n\n\nMultilayer Perceptron 参数设置\n\nhidden_layer_sizes 参数声明中间层的单元数\n\ntuple 形式，每一项为中间层各层的单元数\n默认为一层中间层，100 个单元\n例如：hidden_layer_sizes=(100,) 表示只有一个隐藏层且这个隐藏层有100个神经元。hidden_layer_sizes=(50, 50) 表示有两个隐藏层，每个隐藏层有50个神经元。\n\n\n\n\nMultilayer Perceptron 代码示例\n\nimport numpy as np\nfrom sklearn import neural_network, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 MLPClassifier 对象，并设置隐藏层为 (100,)，即一个包含 100 个神经元的隐藏层\nclf = neural_network.MLPClassifier(hidden_layer_sizes=(100,), max_iter=1000)\n\n# 使用 fit 方法训练模型\nclf.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(clf.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n# 使用 predict_proba 方法进行概率估计\nprint(clf.predict_proba([[5.1, 3.5, 1.4, 0.2]]))\n\n[0]\n[[9.98842012e-01 1.15798775e-03 5.16392652e-11]]\n\n\n\n\nNaive Bayes (朴素贝叶斯)\n\n实现:\n\nsklearn.naive_bayes.GaussianNB()：高斯朴素贝叶斯，假设特征服从高斯分布。\nsklearn.naive_bayes.MultinomialNB()：多项式朴素贝叶斯，适用于多项式分布的数据，如文本数据 (单词计数)。\nsklearn.naive_bayes.BernoulliNB()：伯努利朴素贝叶斯，适用于二元分布的数据 (特征是二值的)。\n\n注意:\n\n提供 partial_fit 方法用于动态的加载数据以解决大数据量的问题\n首次调用 partial_fit 方法需要传递一个所有期望的类标签的列表\n\n\n\n\nNaive Bayes：概念解释\n\nNaive Bayes: 朴素贝叶斯是一种基于贝叶斯定理的简单概率分类器。“朴素” 的意思是假设特征之间相互独立。\n\n🧮 基于概率的分类器，它假设每个特征对分类结果的影响是独立的。\n\n贝叶斯定理: 一种计算条件概率的公式，即在已知一些条件下，事件发生的概率。\n\nP(A|B) = [P(B|A) * P(A)] / P(B)\n\n优点：\n\n简单、快速、高效。\n适用于高维数据，如文本数据。\n对缺失数据不敏感。\n\n缺点：\n\n“朴素” 的假设在现实中往往不成立，特征之间可能存在相关性。\n对输入数据的表达形式很敏感。\n\n\n\n\nNaive Bayes 代码示例\n\nimport numpy as np\nfrom sklearn import naive_bayes, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\nY = iris.target\n\n# 创建 GaussianNB 对象\ngnb = naive_bayes.GaussianNB()\n\n# 创建 MultinomialNB 对象\nmnb = naive_bayes.MultinomialNB()\n\n# 创建 BernoulliNB 对象\nbnb = naive_bayes.BernoulliNB()\n\n# 使用 fit 方法训练模型\ngnb.fit(X, Y)\nmnb.fit(X, Y)\nbnb.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(gnb.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\nprint(mnb.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\nprint(bnb.predict([[5.1, 3.5, 1.4, 0.2]])) # 预测结果为类别 0 (Setosa)\n\n[0]\n[0]\n[0]"
  },
  {
    "objectID": "qmd/chapter7.html#回归方法",
    "href": "qmd/chapter7.html#回归方法",
    "title": "信息技术基础",
    "section": "7.2 回归方法",
    "text": "7.2 回归方法\n回归方法用于预测连续值，就像一个水晶球🔮，可以帮助我们预测未来！\n\nLinear Regression (最小二乘法)\n\n实现:\n\nsklearn.linear_model.LinearRegression()\n\n概念解释:\n\nLinear Regression: 线性回归是一种最简单、最常用的回归模型，它假设特征和目标变量之间存在线性关系。\n\n📏 就像用一条直线来尽可能地穿过所有的数据点，使得所有数据点到这条直线的距离之和最小。\n\n\n\n\n\nLinear Regression：最小二乘法\n\n最小二乘法: 一种求解线性回归模型参数的方法，目标是找到一条直线，使得所有数据点到这条直线的残差平方和最小。\n线性回归简单、易于理解，并且在许多实际问题中表现良好。\n优点：\n\n简单、易于理解和实现。\n计算效率高。\n可以解释模型参数的意义。\n\n缺点：\n\n假设特征和目标变量之间存在线性关系，可能无法很好地拟合非线性数据。\n对异常值比较敏感。\n\n\n\n\nLinear Regression 代码示例\n\nimport numpy as np\nfrom sklearn import linear_model, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 LinearRegression 对象\nreg = linear_model.LinearRegression()\n\n# 使用 fit 方法训练模型\nreg.fit(X, Y)\n\n# 查看模型系数 (coef_) 和截距 (intercept_)\nprint(reg.coef_)\nprint(reg.intercept_)\n\n[ -10.0098663  -239.81564367  519.84592005  324.3846455  -792.17563855\n  476.73902101  101.04326794  177.06323767  751.27369956   67.62669218]\n152.13348416289597\n\n\n\n\nRidge Regression (岭回归)\n\n实现:\n\nsklearn.linear_model.Ridge()\n\n优化方案: solver 参数指定\n\nauto、svd、cholesky、lsqr、sparse_cg、sag 或 saga，默认为 auto\n\n概念解释:\n\nRidge Regression: 岭回归是一种改进的线性回归模型，它通过添加 L2 正则化项来防止过拟合。\n\n\n\n\nRidge Regression：L2 正则化\n\nL2 正则化: 对模型参数的平方和进行惩罚，使得模型参数不会过大，从而提高模型的泛化能力。\n优点：\n\n可以处理多重共线性问题 (特征之间存在高度相关性)。\n可以提高模型的泛化能力。\n\n缺点：\n\n模型的解释性不如线性回归。\n\n\n\n\nRidge Regression 代码示例\n\nimport numpy as np\nfrom sklearn import linear_model, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 Ridge 对象，并设置 alpha 参数 (正则化强度)\nrid = linear_model.Ridge(alpha=1.0)\n\n# 使用 fit 方法训练模型\nrid.fit(X, Y)\n\n# 查看模型系数\nprint(rid.coef_)\n\n[  29.46611189  -83.15427636  306.35268015  201.62773437    5.90961437\n  -29.51549508 -152.04028006  117.3117316   262.94429001  111.87895644]\n\n\n\n\nLasso\n\n实现:\n\nsklearn.linear_model.Lasso()\n\n概念解释:\n\nLasso: Lasso 回归类似于岭回归，但它使用 L1 正则化项来约束模型参数。\n\n\n\n\nLasso：L1 正则化\n\nL1 正则化: 对模型参数的绝对值之和进行惩罚，倾向于产生稀疏的模型，即许多模型参数为零。这使得 Lasso 回归可以用于特征选择，即选择对目标变量影响最大的特征。\n优点：\n\n可以进行特征选择，得到更简洁、易于解释的模型。\n可以处理多重共线性问题。\n\n缺点：\n\n当特征数量大于样本数量时，Lasso 只能选择最多样本数量个特征。\n对于存在高度相关性的特征，Lasso 可能会随机选择其中一个特征，导致结果不稳定。\n\n\n\n\nLasso 代码示例\n\nimport numpy as np\nfrom sklearn import linear_model, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 Lasso 对象，并设置 alpha 参数 (正则化强度)\nlas = linear_model.Lasso(alpha=1.0)\n\n# 使用 fit 方法训练模型\nlas.fit(X, Y)\n\n# 查看模型系数\nprint(las.coef_)\n\n[  0.          -0.         367.70385976   6.29885756   0.\n   0.          -0.           0.         307.6054181    0.        ]\n\n\n\n\nLassoLars\n\n实现:\n\n使用 LARS (最小角回归)\nsklearn.linear_model.LassoLars()\n\n概念解释：\n\nLARS (Least Angle Regression): 最小角回归是一种逐步向前选择算法，它可以用于求解 Lasso 模型，也可以用于构建其他线性模型。\n优点：\n\n计算效率高，尤其适用于高维数据。\n可以得到 Lasso 模型的完整路径 (不同 alpha 值对应的系数)。\n\n缺点：\n\n对噪声比较敏感。\n\n\n\n\n\nLassoLars 代码示例\n\nimport numpy as np\nfrom sklearn import linear_model, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 LassoLars 对象，并设置 alpha 参数 (正则化强度)\nlarlas = linear_model.LassoLars(alpha=1.0)\n\n# 使用 fit 方法训练模型\nlarlas.fit(X, Y)\n\n# 查看模型系数\nprint(larlas.coef_)\n\n[  0.           0.         367.70162582   6.30970264   0.\n   0.           0.           0.         307.60214746   0.        ]\n\n\n\n\nBayesian Ridge Regression (贝叶斯岭回归)\n\n实现:\n\nsklearn.linear_model.BayesianRidge()\n\n概念解释:\n\nBayesian Ridge Regression: 贝叶斯岭回归是一种贝叶斯版本的岭回归，它将模型参数视为随机变量，并使用先验分布来约束参数。\n贝叶斯方法: 将参数视为随机变量，并结合先验知识和数据来推断参数的后验分布。\n优点：\n\n可以估计模型参数的不确定性。\n可以自动调整正则化强度。\n\n缺点：\n\n计算复杂度较高。\n\n\n\n\n\nBayesian Ridge Regression 代码示例\n\nimport numpy as np\nfrom sklearn import linear_model, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 BayesianRidge 对象\nbyr = linear_model.BayesianRidge()\n\n# 使用 fit 方法训练模型\nbyr.fit(X, Y)\n\n# 查看模型系数\nprint(byr.coef_)\n\n[  -4.23356256 -226.32799122  513.47304015  314.90385885 -182.28434068\n   -4.36854822 -159.20103916  114.63541259  506.82345986   76.25617559]\n\n\n\n\nDecision Tree Regression (决策树回归)\n\n实现:\n\nsklearn.tree.DecisionTreeRegressor()\n\n概念解释:\n\nDecision Tree Regression: 决策树回归与决策树分类类似，但它用于预测连续值。\n决策树回归通过递归地将数据集划分为更小的子集，并在每个子集上计算目标变量的平均值或中位数，最终形成一个树状结构。\n优点：\n\n易于理解和解释，可以可视化决策过程。\n可以处理数值型和类别型数据。\n不需要对数据进行预处理 (如归一化)。\n\n缺点：\n\n容易过拟合，需要进行剪枝。\n对于高维度数据或者有很多类别的数据，决策树可能会非常复杂。\n决策树是基于贪心算法构建的，可能不是全局最优的。\n\n\n\n\n\nDecision Tree Regression 代码示例\n\nimport numpy as np\nfrom sklearn import tree, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 DecisionTreeRegressor 对象\nreg = tree.DecisionTreeRegressor()\n\n# 使用 fit 方法训练模型\nreg.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(reg.predict([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]))\n\n[306.]\n\n\n\n\nGaussian Process Regression (高斯过程回归)\n\n实现:\n\nsklearn.gaussian_process.GaussianProcessRegressor()\n\n概念解释:\n\nGaussian Process Regression: 高斯过程回归是一种基于概率的回归方法，它将目标变量视为高斯过程的样本。与高斯过程分类类似，它可以用于对函数的分布进行建模。\n优点：\n\n可以提供预测的置信度。\n可以处理非线性关系。\n\n缺点：\n\n计算复杂度较高，不适用于大规模数据集。\n对核函数的选择比较敏感。\n\n\n\n\n\nGaussian Process Regression 代码示例\n\nimport numpy as np\nfrom sklearn import gaussian_process, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 GaussianProcessRegressor 对象\ngpr = gaussian_process.GaussianProcessRegressor()\n\n# 使用 fit 方法训练模型\ngpr.fit(X, Y)\n\n# 使用 predict 方法对新的数据点进行预测\nprint(gpr.predict([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]))\n\n[-6.56476509e-53]\n\n\n\n\nNearest Neighbors Regression (最近邻回归)\n\n实现:\n\nsklearn.neighbors.KNeighborsRegressor()：K-近邻回归器。\nsklearn.neighbors.RadiusNeighborsRegressor()：半径近邻回归器。\n\n参数\n\nn_neighbors: 设置 k 值 (KNeighborsRegressor)。\nradius: 设置 r 值 (RadiusNeighborsRegressor)。\nweights: 对近邻进行加权,\n\nuniform：所有邻居权重相同。\ndistance：权重与距离成反比。\n自定函数：可以自定义一个函数来计算权重。\n\n\n概念解释:\n\nNearest Neighbors Regression: 最近邻回归是一种基于“物以类聚”思想的回归方法。对于一个新的数据点，找到离它最近的训练数据点（即“邻居”），然后根据这些邻居的目标变量值来预测新数据点的目标变量值。\n\n🚶 与最近邻分类类似，只是预测的不是类别，而是连续值。\nKNeighborsRegressor：使用 k 个最近邻的目标变量值的平均值 (或加权平均值) 作为预测值。\nRadiusNeighborsRegressor：使用半径 r 内所有邻居的目标变量值的平均值 (或加权平均值) 作为预测值。\n\n\n\n\n\nNearest Neighbors Regression 代码示例\n\nimport numpy as np\nfrom sklearn import neighbors, datasets\n\n# 加载糖尿病数据集\ndiabetes = datasets.load_diabetes()\nX = diabetes.data\nY = diabetes.target\n\n# 创建 KNeighborsRegressor 对象，并设置 n_neighbors 为 5\nkreg = neighbors.KNeighborsRegressor(n_neighbors=5)\n\n# 创建 RadiusNeighborsRegressor 对象，并设置 radius 为 50.0\nrreg = neighbors.RadiusNeighborsRegressor(radius=50.0)\n\n# 使用 fit 方法训练模型\nkreg.fit(X, Y)\nrreg.fit(X, Y)\n\n# 预测\nprint(kreg.predict([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]))\nprint(rreg.predict([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]))\n\n# 可以查看邻居关系图\n# print(kreg.kneighbors_graph(X).toarray())\n# print(rreg.radius_neighbors_graph(X).toarray())\n\n[209.4]\n[152.13348416]"
  },
  {
    "objectID": "qmd/chapter7.html#聚类方法",
    "href": "qmd/chapter7.html#聚类方法",
    "title": "信息技术基础",
    "section": "7.3 聚类方法",
    "text": "7.3 聚类方法\n聚类方法用于将相似的数据点分组到一起，就像一个聪明的组织者🧑‍🤝‍🧑，把相似的东西聚集起来！\n\nK-means\n\n实现:\n\nsklearn.cluster.KMeans()：K-means 聚类。\nsklearn.cluster.MiniBatchKMeans()：Mini-Batch K-means 聚类，适用于大规模数据集。\n\n参数\n\ninit: 指定聚类质心的初始化方法\n\nk-means++ (默认): 使用一种比较智能的方法初始化，各个初始化质心彼此相距较远，能加快收敛速度。这是最常用的初始化方法。\nrandom: 随机选择数据点作为初始质心。\n指定一个 ndarray: 可以手动指定初始质心。\n\nn_init 参数: 算法将初始化 “n_init” 次，并选择结果最好的一次作为最终结果 (默认为 10 次)。多次初始化可以避免陷入局部最优解。\n\n概念解释:\n\nK-means: K-means 是一种常用的聚类算法，它的目标是将数据点划分到 K 个簇中，使得每个数据点都属于离它最近的质心 (centroid) 所对应的簇。\n\n🤝 就像把一群人分成 K 组，每组的中心人物是该组的平均代表。\n质心 (Centroid): 每个簇的中心点，是该簇中所有数据点的平均值。\n\n\n\n\n\nK-means：算法步骤\n\n初始化: 随机选择 K 个数据点作为初始质心。\n分配: 将每个数据点分配到离它最近的质心所对应的簇。\n更新: 重新计算每个簇的质心。\n重复: 重复步骤 2 和 3，直到质心不再变化或达到最大迭代次数。\n\n\n\nK-means：优点与缺点\n\n优点：\n\n简单、快速、高效。\n适用于大规模数据集。\n\n缺点：\n\n需要事先指定簇的数量 K。\n对初始质心的选择比较敏感，可能会陷入局部最优解。\n对异常值比较敏感。\n只能发现球形的簇。\n\n\n\n\nK-means 的参数设置\n\nn_clusters 指定聚类的个数，如不指定则默认为 8\nn_jobs 指定使用的处理器个数\n\n\n\nK-means 代码示例\n\nimport numpy as np\nfrom sklearn import cluster, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\n\n# 创建 KMeans 对象，并设置 n_clusters 为 3 (因为鸢尾花数据集有 3 个类别)\nkms = cluster.KMeans(n_clusters=3, n_init = 'auto')\n\n# 创建 MiniBatchKMeans 对象\nmbk = cluster.MiniBatchKMeans(n_clusters=3, n_init = 'auto')\n\n# 使用 fit 方法训练模型\nkms.fit(X)\nmbk.fit(X)\n\n# 查看聚类中心 (cluster_centers_) 和每个数据点所属的簇 (labels_)\nprint(kms.cluster_centers_)\nprint(kms.labels_)\n# print(mbk.cluster_centers_)\n# print(mbk.labels_)\n\n[[5.006      3.428      1.462      0.246     ]\n [5.9016129  2.7483871  4.39354839 1.43387097]\n [6.85       3.07368421 5.74210526 2.07105263]]\n[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 2 2 2 1 2 2 2 2\n 2 2 1 1 2 2 2 2 1 2 1 2 1 2 2 1 1 2 2 2 2 2 1 2 2 2 2 1 2 2 2 1 2 2 2 1 2\n 2 1]\n\n\n\n\nAffinity Propagation\n\n实现:\n\nsklearn.cluster.AffinityPropagation()\n\n概念解释:\n\nAffinity Propagation: 亲和力传播是一种基于消息传递的聚类算法，它不需要事先指定簇的数量。\n\n💬 就像一群人通过互相交流来找到自己的群体。每个人都可以是潜在的“聚类中心”(exemplar)，通过不断地在数据点之间传递“吸引度”和“归属度”信息，最终会涌现出一些“聚类中心”，数据点会聚集到这些中心周围。\n\n优点：\n\n不需要事先指定簇的数量。\n可以发现不规则形状的簇。\n\n缺点：\n\n计算复杂度较高，不适用于大规模数据集。\n对参数的选择比较敏感。\n\n\n\n\n\nAffinity Propagation 的参数\n\naffinity: 相似度度量方式\n\nprecomputed：使用预先计算好的相似度矩阵。\neuclidean (默认)：使用欧几里得距离。\n\ndamping: 阻尼因子，\n\n0.5~1 之间的浮点数，用于控制算法的收敛速度。\n\npreference: 偏好，值越高的点越可能被选为样本\n\nvector\n\n\n\n\nAffinity Propagation 代码示例\n\nimport numpy as np\nfrom sklearn import cluster, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\n\n# 创建 AffinityPropagation 对象\nap = cluster.AffinityPropagation()\n\n# 使用 fit 方法训练模型\nap.fit(X)\n\n# 查看聚类中心 (cluster_centers_) 和每个数据点所属的簇 (labels_)\nprint(ap.cluster_centers_)\nprint(ap.labels_)\n\n[[4.7 3.2 1.3 0.2]\n [5.3 3.7 1.5 0.2]\n [6.5 2.8 4.6 1.5]\n [5.6 2.5 3.9 1.1]\n [6.  2.7 5.1 1.6]\n [7.6 3.  6.6 2.1]\n [6.8 3.  5.5 2.1]]\n[1 0 0 0 1 1 0 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 0 1 0 0 1 1 1 0 0 1 1 1 0 0 1\n 1 0 1 1 0 0 1 1 0 1 0 1 0 2 2 2 3 2 3 2 3 2 3 3 2 3 2 3 2 4 3 2 3 4 3 4 2\n 2 2 2 2 2 3 3 3 3 4 3 2 2 2 3 3 3 2 3 3 3 3 3 2 3 3 6 4 6 6 6 5 3 5 6 5 6\n 4 6 4 4 6 6 5 5 4 6 4 5 4 6 6 4 4 6 6 5 5 6 4 4 5 6 6 4 6 6 6 4 6 6 6 4 6\n 6 4]\n\n\n\n\nMean-shift\n\n实现:\n\nsklearn.cluster.MeanShift()\n\n概念解释：\n\nMean-shift: 均值漂移是一种基于密度估计的聚类算法，它将数据点沿着密度梯度方向移动，最终聚集到密度较高的区域。\n📈 就像一群人爬山，每个人都朝着最陡峭的方向 (密度梯度) 爬，最终会聚集到山顶 (密度中心)。\n\n\n\n\nMean-shift：算法步骤\n\n初始化: 随机选择一个数据点作为起始点。\n计算均值漂移向量: 计算以当前点为中心的指定半径 (带宽) 内所有数据点的均值，然后计算当前点到均值的向量。\n移动: 将当前点沿着均值漂移向量的方向移动。\n重复: 重复步骤 2 和 3，直到当前点不再移动或达到最大迭代次数。\n聚类: 将所有收敛到同一个点的数据点归为一类。\n\n\n优点：\n\n不需要事先指定簇的数量。\n可以发现任意形状的簇。\n对异常值不敏感。\n\n缺点：\n\n计算复杂度较高，不适用于大规模数据集。\n对带宽参数的选择比较敏感。\n\n参数 bandwidth：\n\n声明浮点数“带宽”限制搜索区域\n默认使用 sklearn.cluster.estimate_bandwidth 函数\n\n\n\n\nMean-shift 代码示例\n\nimport numpy as np\nfrom sklearn import cluster, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\n\n# 创建 MeanShift 对象\nms = cluster.MeanShift()\n\n# 使用 fit 方法训练模型\nms.fit(X)\n\n# 查看聚类中心 (cluster_centers_) 和每个数据点所属的簇 (labels_)\nprint(ms.cluster_centers_)\nprint(ms.labels_)\n\n[[6.21142857 2.89285714 4.85285714 1.67285714]\n [5.01632653 3.45102041 1.46530612 0.24489796]]\n[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n 0 0]\n\n\n\n\nSpectral Clustering\n\n实现:\n\nsklearn.cluster.SpectralClustering()\n\n概念解释：\n\nSpectral Clustering: 谱聚类是一种基于图论的聚类算法，它将数据点视为图中的节点，并通过图的谱分解 (特征值分解) 来进行聚类。\n\n📊 将数据点之间的相似度构建成一个图，然后将聚类问题转化为图的划分问题。\n\n\n\n\n\nSpectral Clustering：算法步骤\n\n构建相似度图: 根据数据点之间的相似度构建一个相似度矩阵 (或邻接矩阵)。\n计算拉普拉斯矩阵: 根据相似度矩阵计算拉普拉斯矩阵。\n特征值分解: 对拉普拉斯矩阵进行特征值分解，得到特征值和特征向量。\n聚类: 使用 K-means 等算法对特征向量进行聚类。\n\n\n优点：\n\n可以发现非凸形状的簇。\n对数据分布的假设较少。\n\n缺点：\n\n计算复杂度较高，不适用于大规模数据集。\n对参数的选择比较敏感。\n\n\n\n\nSpectral Clustering 代码示例\n\nimport numpy as np\nfrom sklearn import cluster, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\n\n# 创建 SpectralClustering 对象\nsc = cluster.SpectralClustering(n_clusters=3)  # 移除 n_init 参数\n\n# 使用 fit 方法训练模型\nsc.fit(X)\n\n# 查看每个数据点所属的簇 (labels_)\nprint(sc.labels_)\n\n[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 0 0 0 0 2 0 0 0 0\n 0 0 2 2 0 0 0 0 2 0 2 0 2 0 0 2 2 0 0 0 0 0 2 2 0 0 0 2 0 0 0 2 0 0 0 2 0\n 0 2]\n\n\n\n\nHierarchical Clustering (层次聚类)\n\n实现:\n\nsklearn.cluster.AgglomerativeClustering()\n\n概念解释：\n\nHierarchical Clustering: 层次聚类是一种构建层次结构的聚类算法，它可以自底向上 (凝聚式) 或自顶向下 (分裂式) 进行。\n\n🌳 就像一棵树，数据点逐渐合并成更大的簇，或者一个大簇逐渐分裂成更小的簇。\n凝聚式层次聚类 (Agglomerative Clustering): 从每个数据点作为一个单独的簇开始，然后逐步合并最相似的簇，直到所有数据点都合并成一个簇。\n分裂式层次聚类 (Divisive Clustering): 从所有数据点都在一个簇开始，然后逐步将簇分裂成更小的簇，直到每个数据点都成为一个单独的簇。\n\n优点：\n\n可以得到数据的层次结构。\n不需要事先指定簇的数量 (可以通过观察层次结构来决定)。\n\n缺点：\n\n计算复杂度较高，不适用于大规模数据集。\n对噪声和异常值比较敏感。\n一旦合并或分裂，就无法撤销。\n\n\n\n\n\nHierarchical Clustering 代码示例\n\nimport numpy as np\nfrom sklearn import cluster, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\n\n# 创建 AgglomerativeClustering 对象，并设置 n_clusters 为 3\nag = cluster.AgglomerativeClustering(n_clusters=3)\n\n# 使用 fit 方法训练模型\nag.fit(X)\n\n# 查看每个数据点所属的簇 (labels_)\nprint(ag.labels_)\n\n[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 2 2 2 0 2 2 2 2\n 2 2 0 0 2 2 2 2 0 2 0 2 0 2 2 0 0 2 2 2 2 2 0 0 2 2 2 0 2 2 2 0 2 2 2 0 2\n 2 0]\n\n\n\n\nDBSCAN\n\n实现:\n\nsklearn.cluster.DBSCAN()\n\n概念解释：\n\nDBSCAN (Density-Based Spatial Clustering of Applications with Noise): 基于密度的空间聚类算法，它可以发现任意形状的簇，并能识别噪声点。\n\n🌌 就像在星空中寻找星系，密集的地方就是一个星系 (簇)，稀疏的地方就是噪声。\n\n\n\n\n\nDBSCAN：核心概念\n\n核心点 (Core Point): 在指定半径 (eps) 内，邻居数量 (包括自身) 超过指定阈值 (min_samples) 的数据点。\n边界点 (Border Point): 在指定半径 (eps) 内，邻居数量少于指定阈值 (min_samples)，但落在某个核心点的邻域内的数据点。\n噪声点 (Noise Point): 既不是核心点，也不是边界点的数据点。\n\n\n\nDBSCAN：算法步骤\n\n寻找核心点: 遍历所有数据点，找到所有核心点。\n连接核心点: 将相互之间距离小于 eps 的核心点连接起来，形成一个簇。\n合并边界点: 将边界点分配到与其相邻的核心点所在的簇。\n识别噪声点: 将不属于任何簇的数据点标记为噪声点。\n\n\n优点：\n\n可以发现任意形状的簇。\n可以识别噪声点。\n不需要事先指定簇的数量。\n\n缺点：\n\n对参数 (eps 和 min_samples) 的选择比较敏感。\n对于密度差异较大的数据集，聚类效果可能不好。\n\n\n\n\nDBSCAN 代码示例\n\nimport numpy as np\nfrom sklearn import cluster, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\n\n# 创建 DBSCAN 对象，并设置 eps (邻域半径) 和 min_samples (最小邻居数)\ndb = cluster.DBSCAN(eps=0.5, min_samples=5)\n\n# 使用 fit 方法训练模型\ndb.fit(X)\n\n# 查看每个数据点所属的簇 (labels_)，-1 表示噪声点\nprint(db.labels_)\n\n[ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0\n  0  0  1  1  1  1  1  1  1 -1  1  1 -1  1  1  1  1  1  1  1 -1  1  1  1\n  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 -1  1  1  1  1  1 -1  1  1\n  1  1 -1  1  1  1  1  1  1 -1 -1  1 -1 -1  1  1  1  1  1  1  1 -1 -1  1\n  1  1 -1  1  1  1  1  1  1  1  1 -1  1  1 -1 -1  1  1  1  1  1  1  1  1\n  1  1  1  1  1  1]\n\n\n\n\nBirch\n\n实现:\n\nsklearn.cluster.Birch()\n\n概念解释：\n\nBirch (Balanced Iterative Reducing and Clustering using Hierarchies): 一种适用于大规模数据集的层次聚类算法。\n\n🌲 它通过构建一个叫做 CF 树 (Clustering Feature Tree) 的树状结构来存储数据的摘要信息，从而减少计算量。\n\n\n\n\n\nBirch：CF 树\n\nCF (Clustering Feature): 簇特征，包含簇中数据点的个数、数据点的线性和、数据点的平方和。\nCF 树: 一种平衡树，每个节点包含多个 CF 条目。\n\n\n\nBirch：算法步骤\n\n构建 CF 树: 扫描数据集，将数据点插入到 CF 树中。\n调整 CF 树: 对 CF 树进行调整，使其满足内存限制。\n全局聚类: 对 CF 树的叶节点进行聚类。\n聚类优化: 对聚类结果进行优化 (可选)。\n\n\n优点：\n\n适用于大规模数据集。\n计算效率高。\n可以处理噪声数据。\n\n缺点：\n\n对参数的选择比较敏感。\n只能发现球形的簇。\n\n\n\n\nBirch 代码示例\n\nimport numpy as np\nfrom sklearn import cluster, datasets\n\n# 加载鸢尾花数据集\niris = datasets.load_iris()\nX = iris.data\n\n# 创建 Birch 对象，并设置 n_clusters 为 3\nbir = cluster.Birch(n_clusters=3)\n\n# 使用 fit 方法训练模型\nbir.fit(X)\n\n# 查看每个数据点所属的簇 (labels_)\nprint(bir.labels_)\n\n[2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n 2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 1 0 0 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 0 0\n 0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 1 1 0 1 1 1 1 1 0 1 1 0 0 0 0 0 0 1 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n 0 0]"
  },
  {
    "objectID": "qmd/chapter7.html#总结",
    "href": "qmd/chapter7.html#总结",
    "title": "信息技术基础",
    "section": "总结",
    "text": "总结\n\n本章介绍了使用 Pandas 和 scikit-learn 进行数据分析的各种方法，包括：\n\n分类：Logistic 回归, SVM, 最近邻, 决策树, 随机梯度下降, 高斯过程分类, 多层感知器, 朴素贝叶斯\n\n🔑 这些方法就像不同的钥匙🔑，可以打开不同类型的数据宝箱📦。\n\n回归：线性回归, 岭回归, Lasso, LassoLars, 贝叶斯岭回归, 决策树回归, 高斯过程回归, 最近邻回归\n\n🔮 这些方法就像不同的水晶球🔮，可以预测未来。\n\n聚类：K-means, Affinity Propagation, Mean-shift, Spectral Clustering, 层次聚类, DBSCAN, Birch\n\n🧑‍🤝‍🧑 这些方法就像不同的组织者🧑‍🤝‍🧑，可以将相似的数据聚集起来。\n\n\nPandas 提供了强大的数据处理和分析工具，就像一个超级 Excel 表格。\nscikit-learn 提供了各种机器学习算法和工具，就像一个机器学习百宝箱🧰。\n通过结合使用这两个库，我们可以轻松地实现各种数据分析任务，探索数据的奥秘🔬！"
  },
  {
    "objectID": "qmd/chapter7.html#思考与讨论",
    "href": "qmd/chapter7.html#思考与讨论",
    "title": "信息技术基础",
    "section": "思考与讨论",
    "text": "思考与讨论\n\n🤔️ 不同的分类、回归、聚类算法分别适用于哪些场景？\n\n例如：什么时候应该选择 SVM，什么时候应该选择决策树？\n\n🛠️ 如何选择合适的算法和参数？\n\n例如：如何确定 K-means 中的 K 值？如何调整 SVM 中的核函数和参数？\n\n📈 如何评估模型的性能？\n\n例如：如何判断一个分类模型的好坏？如何判断一个回归模型的预测是否准确？\n\n💡 如何将这些技术应用到实际问题中？\n\n例如：如何使用聚类算法来进行客户细分？如何使用回归算法来预测房价？\n\n📚️ 还有哪些其他的数据分析方法和技术？\n\n例如：降维、特征工程、集成学习等。"
  },
  {
    "objectID": "index.html#ppt",
    "href": "index.html#ppt",
    "title": "信息技术基础",
    "section": "ppt",
    "text": "ppt\n 第一章 \n 第二章 \n 第三章 \n 第四章 \n 第五章 \n 第六章 \n 第七章 \n 第八章"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "我是邱飞，这是我的个人网站，\n用于分享一些数据分析文章，还有个人的记录和资料。"
  },
  {
    "objectID": "qmd/chapter2.html",
    "href": "qmd/chapter2.html",
    "title": "信息技术基础 🧐",
    "section": "",
    "text": "为什么要学习Python？🤔\nPython 的基本概念和应用 💡\n如何安装和配置 Python 环境 ⚙️\n重要的 Python 库介绍 📦\nJupyter Notebook 的使用 📝"
  },
  {
    "objectID": "qmd/chapter2.html#本章概述",
    "href": "qmd/chapter2.html#本章概述",
    "title": "信息技术基础 🧐",
    "section": "",
    "text": "为什么要学习Python？🤔\nPython 的基本概念和应用 💡\n如何安装和配置 Python 环境 ⚙️\n重要的 Python 库介绍 📦\nJupyter Notebook 的使用 📝"
  },
  {
    "objectID": "qmd/chapter2.html#为什么选择-python-13",
    "href": "qmd/chapter2.html#为什么选择-python-13",
    "title": "信息技术基础 🧐",
    "section": "为什么选择 Python？🐍 (1/3)",
    "text": "为什么选择 Python？🐍 (1/3)\n易学易用 👍:\n\nPython的语法设计得非常简洁和清晰，就像读英语一样自然。\n这使得Python对编程初学者非常友好，可以更快地上手并开始编写代码。"
  },
  {
    "objectID": "qmd/chapter2.html#为什么选择-python-23",
    "href": "qmd/chapter2.html#为什么选择-python-23",
    "title": "信息技术基础 🧐",
    "section": "为什么选择 Python？🐍 (2/3)",
    "text": "为什么选择 Python？🐍 (2/3)\n应用广泛 🌍:\nPython在许多领域都有广泛的应用，包括但不限于：\n\n数据分析 📊: Python可以帮助你处理、清洗和分析各种类型的数据，从中提取有价值的信息。\n机器学习 🤖: 你可以使用Python构建智能模型，进行预测、分类和聚类等任务，实现自动化决策。\nWeb 开发 🌐: Python可以用于搭建网站和开发Web应用程序，提供各种在线服务。"
  },
  {
    "objectID": "qmd/chapter2.html#为什么选择-python-33",
    "href": "qmd/chapter2.html#为什么选择-python-33",
    "title": "信息技术基础 🧐",
    "section": "为什么选择 Python？🐍 (3/3)",
    "text": "为什么选择 Python？🐍 (3/3)\n应用广泛 🌍 (续):\n\n自动化脚本 ⚙️: 你可以编写Python脚本来自动执行各种重复性的任务，提高工作效率。\n科学计算 🔬: Python可以进行复杂的数学运算、模拟实验等科学计算任务。\n更多领域…"
  },
  {
    "objectID": "qmd/chapter2.html#python-社区与职业发展",
    "href": "qmd/chapter2.html#python-社区与职业发展",
    "title": "信息技术基础 🧐",
    "section": "Python 社区与职业发展",
    "text": "Python 社区与职业发展\n社区强大 💪:\n\nPython拥有一个庞大而活跃的开发者社区。\n这意味着你可以轻松地找到各种Python库、工具和技术支持。\n遇到问题时，你可以方便地在社区中寻求帮助或找到解决方案。\n\n需求量大 💼:\n\nPython是目前最热门的编程语言之一，在各行各业都有广泛的应用。\n掌握Python可以为你带来更多的职业发展机会。"
  },
  {
    "objectID": "qmd/chapter2.html#python-语言的特性",
    "href": "qmd/chapter2.html#python-语言的特性",
    "title": "信息技术基础 🧐",
    "section": "Python 语言的特性",
    "text": "Python 语言的特性\nPython 是一种解释型、面向对象、动态数据类型的高级程序设计语言。\n\n解释型语言：代码在运行时由解释器逐行翻译成机器码并执行，无需事先编译。\n面向对象：支持面向对象编程（OOP）范式，提高了代码的可重用性和可维护性。\n动态数据类型：变量类型在运行时自动确定，使代码更简洁，但也需注意类型错误。"
  },
  {
    "objectID": "qmd/chapter2.html#python-解释器工作原理",
    "href": "qmd/chapter2.html#python-解释器工作原理",
    "title": "信息技术基础 🧐",
    "section": "Python 解释器工作原理 ⚙️",
    "text": "Python 解释器工作原理 ⚙️\n解释型语言如 Python，代码在执行时会被解释器逐行翻译成机器码。\n工作流程：\n\n读取代码：解释器读取 Python 代码文件（通常是 .py 文件）。\n词法分析：解释器将代码分解成一个个的标记（Token），例如关键字、标识符、运算符、字面量等。\n语法分析：解释器根据 Python 的语法规则，将标记组合成语法树（Parse Tree）。语法树表示了代码的结构。"
  },
  {
    "objectID": "qmd/chapter2.html#python解释器与编译型语言的区别",
    "href": "qmd/chapter2.html#python解释器与编译型语言的区别",
    "title": "信息技术基础 🧐",
    "section": "Python解释器与编译型语言的区别",
    "text": "Python解释器与编译型语言的区别\n与编译型语言的区别：\n\n编译型语言（如 C++、Java）：源代码首先被编译器一次性编译成机器码（可执行文件），然后直接运行。\n解释型语言（如 Python、JavaScript）：源代码在运行时由解释器逐行翻译执行。"
  },
  {
    "objectID": "qmd/chapter2.html#编译型语言-vs.-解释型语言",
    "href": "qmd/chapter2.html#编译型语言-vs.-解释型语言",
    "title": "信息技术基础 🧐",
    "section": "编译型语言 vs. 解释型语言",
    "text": "编译型语言 vs. 解释型语言\n优缺点比较：\n\n\n\n\n\n\n\n\n\n编译型语言\n解释型语言\n\n\n\n\n优点\n执行速度快\n开发速度快，跨平台性好\n\n\n缺点\n开发效率低，调试麻烦，跨平台性差\n执行速度相对较慢"
  },
  {
    "objectID": "qmd/chapter2.html#python-面向对象编程oop-13",
    "href": "qmd/chapter2.html#python-面向对象编程oop-13",
    "title": "信息技术基础 🧐",
    "section": "Python 面向对象编程（OOP）🏠 (1/3)",
    "text": "Python 面向对象编程（OOP）🏠 (1/3)\n面向对象编程 (OOP) 是一种编程范式，它使用“对象”来设计应用程序和程序。对象可以包含数据（称为属性或字段）和操作这些数据的代码（称为方法）。\n核心概念：\n\n类 (Class)：类是对象的蓝图或模板。它定义了对象将具有的属性和方法。\n\n例如，你可以定义一个 Dog 类，它具有 name、breed 和 age 等属性，以及 bark() 和 fetch() 等方法。"
  },
  {
    "objectID": "qmd/chapter2.html#python-面向对象编程oop-23",
    "href": "qmd/chapter2.html#python-面向对象编程oop-23",
    "title": "信息技术基础 🧐",
    "section": "Python 面向对象编程（OOP）🏠 (2/3)",
    "text": "Python 面向对象编程（OOP）🏠 (2/3)\n\n对象 (Object)：对象是类的实例。创建类的一个实例就是创建一个具有该类属性和方法的对象。\n\n例如，你可以创建两个 Dog 对象：my_dog 和 your_dog，它们各自有不同的名字、品种和年龄。\n\n属性 (Attribute)：属性是对象的数据。\n\n例如，my_dog 对象的 name 属性可能是 “Buddy”。\n\n方法 (Method)：方法是对象可以执行的操作。\n\n例如，my_dog 对象可以调用 bark() 方法来发出叫声。"
  },
  {
    "objectID": "qmd/chapter2.html#python-面向对象编程oop-33",
    "href": "qmd/chapter2.html#python-面向对象编程oop-33",
    "title": "信息技术基础 🧐",
    "section": "Python 面向对象编程（OOP）🏠 (3/3)",
    "text": "Python 面向对象编程（OOP）🏠 (3/3)\n\n封装 (Encapsulation)：将数据（属性）和操作数据的代码（方法）捆绑在一起，形成一个独立的实体（对象）。\n\n封装可以隐藏对象的内部实现细节，只暴露必要的接口。\n\n继承 (Inheritance)：允许一个类（子类）继承另一个类（父类）的属性和方法。\n\n子类可以重用父类的代码，并添加或修改自己的特性。\n例如，你可以创建一个 Poodle 类，它继承自 Dog 类，并添加一个 groom() 方法。\n\n多态 (Polymorphism)：允许不同类的对象对同一消息做出响应。\n\n例如，Dog 类和 Cat 类都可以有一个 make_sound() 方法，但它们的实现方式不同。"
  },
  {
    "objectID": "qmd/chapter2.html#oop的优势",
    "href": "qmd/chapter2.html#oop的优势",
    "title": "信息技术基础 🧐",
    "section": "OOP的优势",
    "text": "OOP的优势\n优势：\n\n模块化：代码被组织成更易于管理和理解的模块。\n可重用性：通过继承和组合，可以重用现有的代码。\n可维护性：更容易修改和扩展代码，而不会影响其他部分。\n可扩展性：更容易添加新功能。"
  },
  {
    "objectID": "qmd/chapter2.html#python-动态数据类型-12",
    "href": "qmd/chapter2.html#python-动态数据类型-12",
    "title": "信息技术基础 🧐",
    "section": "Python 动态数据类型 ❓ (1/2)",
    "text": "Python 动态数据类型 ❓ (1/2)\n在Python中，你不需要在声明变量时指定其数据类型。变量的类型在运行时根据你赋给它的值自动确定。\n示例：\n\nx = 10       # x 是整数类型 (int)\nprint(type(x))\n\nx = \"Hello\"  # 现在 x 是字符串类型 (str)\nprint(type(x))\n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;"
  },
  {
    "objectID": "qmd/chapter2.html#python-动态数据类型-22",
    "href": "qmd/chapter2.html#python-动态数据类型-22",
    "title": "信息技术基础 🧐",
    "section": "Python 动态数据类型 ❓ (2/2)",
    "text": "Python 动态数据类型 ❓ (2/2)\n\nx = 3.14     # 现在 x 是浮点数类型 (float)\nprint(type(x))\n\nx = [1, 2, 3] # 现在 x 是列表类型 (list)\nprint(type(x))\n\n&lt;class 'float'&gt;\n&lt;class 'list'&gt;"
  },
  {
    "objectID": "qmd/chapter2.html#动态数据类型的优势与注意点",
    "href": "qmd/chapter2.html#动态数据类型的优势与注意点",
    "title": "信息技术基础 🧐",
    "section": "动态数据类型的优势与注意点",
    "text": "动态数据类型的优势与注意点\n优势：\n\n代码简洁：不需要显式地声明变量类型，使代码更简洁易读。\n灵活性：变量可以在运行时改变类型，提供了更大的灵活性。\n\n需要注意的点：\n\n类型错误：由于变量类型是动态的，如果在运行时进行了不兼容的操作，可能会导致类型错误。\n代码可读性：虽然不需要显式声明类型，但良好的代码风格仍然建议在适当的地方添加注释或使用类型提示来提高代码的可读性和可维护性。"
  },
  {
    "objectID": "qmd/chapter2.html#python-类型提示-type-hints",
    "href": "qmd/chapter2.html#python-类型提示-type-hints",
    "title": "信息技术基础 🧐",
    "section": "Python 类型提示 (Type Hints)",
    "text": "Python 类型提示 (Type Hints)\n类型提示 (Type Hints)：\n\ndef greet(name: str) -&gt; str:\n    return \"Hello, \" + name\n\nprint(greet(\"World\"))\n\nHello, World"
  },
  {
    "objectID": "qmd/chapter2.html#python-发展史-12",
    "href": "qmd/chapter2.html#python-发展史-12",
    "title": "信息技术基础 🧐",
    "section": "Python 发展史 📜 (1/2)",
    "text": "Python 发展史 📜 (1/2)\n\n1989 年圣诞节 🎄:\n\nGuido van Rossum，一位荷兰的数学家和计算机学家，为了打发圣诞节的无聊时间，开始开发 Python 语言。\nPython 的名字来源于他喜欢的一个喜剧团体 “Monty Python’s Flying Circus”。"
  },
  {
    "objectID": "qmd/chapter2.html#python-发展史-22",
    "href": "qmd/chapter2.html#python-发展史-22",
    "title": "信息技术基础 🧐",
    "section": "Python 发展史 📜 (2/2)",
    "text": "Python 发展史 📜 (2/2)\n\n1991 年 🎉:\n\nPython 的第一个公开发行版问世，标志着 Python 语言的正式诞生。"
  },
  {
    "objectID": "qmd/chapter2.html#python-2.0-的里程碑",
    "href": "qmd/chapter2.html#python-2.0-的里程碑",
    "title": "信息技术基础 🧐",
    "section": "Python 2.0 的里程碑",
    "text": "Python 2.0 的里程碑\n\n2000 年 10 月 2️⃣:\n\nPython 2.0 版本发布，这是一个重要的里程碑。\nPython 2.0 引入了许多新的特性：\n\n垃圾回收机制：解决了程序员手动管理内存的难题，减少了内存泄漏的风险。\nUnicode 支持：使得 Python 可以更好地处理多语言文本，为国际化应用提供了基础。\n列表推导式等。"
  },
  {
    "objectID": "qmd/chapter2.html#python-3.0-的重大升级",
    "href": "qmd/chapter2.html#python-3.0-的重大升级",
    "title": "信息技术基础 🧐",
    "section": "Python 3.0 的重大升级",
    "text": "Python 3.0 的重大升级\n\n2008 年 12 月 3️⃣:\n\nPython 3.0 版本发布，这是 Python 语言的一次重大升级。\nPython 3.0 对语言进行了一些不兼容的改进，旨在去除一些冗余和过时的特性，使 Python 更加简洁、规范和一致。\n重要提示：Python 3 与 Python 2 不完全兼容。"
  },
  {
    "objectID": "qmd/chapter2.html#为什么-python-3-不完全兼容-python-2-12",
    "href": "qmd/chapter2.html#为什么-python-3-不完全兼容-python-2-12",
    "title": "信息技术基础 🧐",
    "section": "为什么 Python 3 不完全兼容 Python 2？🤔 (1/2)",
    "text": "为什么 Python 3 不完全兼容 Python 2？🤔 (1/2)\nPython 3 的设计者认为，为了保持语言的长期健康发展，有必要进行一些不兼容的更改，以解决 Python 2 中存在的一些设计缺陷和历史遗留问题。\n主要原因：\n\nUnicode：\n\nPython 2 使用 ASCII 作为默认编码，对非英文字符的支持不够好。\nPython 3 将 Unicode 作为默认编码，更好地支持多语言文本。\n这一变化导致了字符串处理方式的不同，是 Python 2 和 Python 3 之间最主要的不兼容之处。"
  },
  {
    "objectID": "qmd/chapter2.html#为什么-python-3-不完全兼容-python-2-22",
    "href": "qmd/chapter2.html#为什么-python-3-不完全兼容-python-2-22",
    "title": "信息技术基础 🧐",
    "section": "为什么 Python 3 不完全兼容 Python 2？🤔 (2/2)",
    "text": "为什么 Python 3 不完全兼容 Python 2？🤔 (2/2)\n\nprint 语句：\n\nPython 2 中，print 是一个语句。\nPython 3 中，print 变成了一个函数。\n这使得 print 的使用更加灵活，但也导致了不兼容。\n\n整数除法：\n\nPython 2 中，整数除法的结果仍然是整数（向下取整）。\nPython 3 中，整数除法的结果是浮点数。\n这使得除法运算的结果更符合预期，但也导致了不兼容。"
  },
  {
    "objectID": "qmd/chapter2.html#python2和python3的其他不兼容之处",
    "href": "qmd/chapter2.html#python2和python3的其他不兼容之处",
    "title": "信息技术基础 🧐",
    "section": "Python2和Python3的其他不兼容之处",
    "text": "Python2和Python3的其他不兼容之处\n\n异常处理：\n\nPython 2 和 Python 3 在异常处理的语法上有一些细微的差别。\n\n其他：\n\nPython 3 还进行了一些其他的改进，例如：\n\nrange() 和 xrange() 的合并。\n迭代器行为的改变。\n一些标准库模块的重组和重命名。"
  },
  {
    "objectID": "qmd/chapter2.html#python-3-的优势",
    "href": "qmd/chapter2.html#python-3-的优势",
    "title": "信息技术基础 🧐",
    "section": "Python 3 的优势",
    "text": "Python 3 的优势\n总结：\n虽然 Python 3 的不兼容性给迁移带来了一些麻烦，但从长远来看，这些改进使得 Python 成为了一种更强大、更一致、更易于使用的语言。"
  },
  {
    "objectID": "qmd/chapter2.html#python-版本进化-垃圾回收机制-12",
    "href": "qmd/chapter2.html#python-版本进化-垃圾回收机制-12",
    "title": "信息技术基础 🧐",
    "section": "Python 版本进化 🔄 💡 垃圾回收机制 (1/2)",
    "text": "Python 版本进化 🔄 💡 垃圾回收机制 (1/2)\n垃圾回收 (Garbage Collection, GC) 是一种自动内存管理机制。当程序不再需要某些内存块（对象）时，垃圾回收器会自动检测并释放这些内存，避免内存泄漏，提高程序运行效率。\n工作原理：\n\n对象创建： 当你在Python中创建对象时，Python解释器会为这些对象分配内存空间。\n引用计数（主要机制）： Python使用引用计数作为垃圾回收的主要机制。每个对象都有一个引用计数，记录有多少个变量或数据结构引用了该对象。"
  },
  {
    "objectID": "qmd/chapter2.html#垃圾回收机制22",
    "href": "qmd/chapter2.html#垃圾回收机制22",
    "title": "信息技术基础 🧐",
    "section": "垃圾回收机制（2/2）",
    "text": "垃圾回收机制（2/2）\n\n引用增加： 当你将一个对象赋值给一个变量、将对象添加到列表、或将对象作为参数传递给函数时，该对象的引用计数会增加。\n引用减少： 当变量被重新赋值、离开作用域、或从列表中删除时，相应对象的引用计数会减少。\n垃圾回收触发： 当一个对象的引用计数变为0时，意味着没有任何变量或数据结构引用该对象，该对象就变成了“垃圾”。Python的垃圾回收器会自动释放该对象占用的内存。"
  },
  {
    "objectID": "qmd/chapter2.html#垃圾回收机制循环引用",
    "href": "qmd/chapter2.html#垃圾回收机制循环引用",
    "title": "信息技术基础 🧐",
    "section": "垃圾回收机制：循环引用",
    "text": "垃圾回收机制：循环引用\n\n循环引用处理（辅助机制）\n\n引用计数无法处理循环引用的情况。循环引用是指两个或多个对象相互引用，形成一个闭环，导致它们的引用计数永远不会变为0。\n为了解决循环引用问题，Python还使用了标记-清除（Mark and Sweep）和分代回收（Generational Garbage Collection）等辅助机制。\n标记-清除： 定期扫描内存中的所有对象，标记可达对象，然后清除未标记的对象。\n分代回收： 将对象分为不同的代，新创建的对象属于“年轻代”，经历过多次垃圾回收仍然存活的对象会晋升到“老年代”。垃圾回收器会更频繁地扫描年轻代。"
  },
  {
    "objectID": "qmd/chapter2.html#垃圾回收机制的好处",
    "href": "qmd/chapter2.html#垃圾回收机制的好处",
    "title": "信息技术基础 🧐",
    "section": "垃圾回收机制的好处",
    "text": "垃圾回收机制的好处\n好处：\n\n简化了程序员的内存管理工作，无需手动释放内存。\n减少了内存泄漏的风险，提高了程序的稳定性。"
  },
  {
    "objectID": "qmd/chapter2.html#python-及相关包的安装-12",
    "href": "qmd/chapter2.html#python-及相关包的安装-12",
    "title": "信息技术基础 🧐",
    "section": "Python 及相关包的安装 🛠️ (1/2)",
    "text": "Python 及相关包的安装 🛠️ (1/2)\n\nPython 的安装\n\nWindows 环境 💻\n\n访问 Python 官网：https://www.python.org/\n下载适用于 Windows 的 Python 安装程序（通常是 .exe 文件）。\n运行安装程序，按照提示进行安装。\n\n注意：在安装过程中，务必勾选 “Add Python to PATH” 选项，这样可以在命令行中直接运行 Python。"
  },
  {
    "objectID": "qmd/chapter2.html#python-及相关包的安装-22",
    "href": "qmd/chapter2.html#python-及相关包的安装-22",
    "title": "信息技术基础 🧐",
    "section": "Python 及相关包的安装 🛠️ (2/2)",
    "text": "Python 及相关包的安装 🛠️ (2/2)\n\nPython 的安装（续）\n\nMac 环境 🍎\n\n方法一：与 Windows 类似，从 Python 官网下载安装程序进行安装。\n方法二：使用 Homebrew（macOS 上的软件包管理器）安装。\n\nHomebrew 简介：Homebrew 可以让你方便地在 macOS 上安装、更新和管理各种软件。\n\n安装完成后，打开命令提示符（CMD）或 PowerShell，输入 python --version，如果看到 Python 版本号，说明安装成功。"
  },
  {
    "objectID": "qmd/chapter2.html#使用-homebrew-安装-python-macos-12",
    "href": "qmd/chapter2.html#使用-homebrew-安装-python-macos-12",
    "title": "信息技术基础 🧐",
    "section": "使用 Homebrew 安装 Python (macOS) 🍺 (1/2)",
    "text": "使用 Homebrew 安装 Python (macOS) 🍺 (1/2)\n\n安装 Homebrew：\n\n打开终端（Terminal）应用程序。\n复制并粘贴以下命令到终端，然后按回车键执行：\n\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
  },
  {
    "objectID": "qmd/chapter2.html#使用-homebrew-安装-python-macos-22",
    "href": "qmd/chapter2.html#使用-homebrew-安装-python-macos-22",
    "title": "信息技术基础 🧐",
    "section": "使用 Homebrew 安装 Python (macOS) 🍺 (2/2)",
    "text": "使用 Homebrew 安装 Python (macOS) 🍺 (2/2)\n\n按照屏幕上的提示完成安装过程。\n\n\n使用 Homebrew 安装 Python：\n\n安装完 Homebrew 后，在终端中输入以下命令：\n\nbrew install python\n\nHomebrew 会自动下载并安装最新版本的 Python。\n\n验证安装：\n\n安装完成后，输入 python3 --version 或 python --version，如果看到 Python 版本号，说明安装成功。"
  },
  {
    "objectID": "qmd/chapter2.html#相关包的安装-12",
    "href": "qmd/chapter2.html#相关包的安装-12",
    "title": "信息技术基础 🧐",
    "section": "相关包的安装 📦 (1/2)",
    "text": "相关包的安装 📦 (1/2)\n\n使用 pip 进行安装\n\npip 是 Python 的包管理工具，它就像一个应用商店，可以让你轻松地安装、卸载和管理各种 Python 包（库）。\n常用命令：\n\npip install &lt;package_name&gt;: 安装指定的包。例如：pip install pandas。\npip install &lt;package_name&gt;==&lt;version&gt;: 安装指定版本的包。例如：pip install pandas==1.5.0\npip uninstall &lt;package_name&gt;: 卸载指定的包。"
  },
  {
    "objectID": "qmd/chapter2.html#相关包的安装-22",
    "href": "qmd/chapter2.html#相关包的安装-22",
    "title": "信息技术基础 🧐",
    "section": "相关包的安装 📦 (2/2)",
    "text": "相关包的安装 📦 (2/2)\n\n使用 pip 进行安装（续） - pip list: 列出已安装的所有包。 - pip show &lt;package_name&gt;: 显示指定包的详细信息。 - pip install --upgrade &lt;package_name&gt;: 升级包到最新的版本。"
  },
  {
    "objectID": "qmd/chapter2.html#pip-更换源",
    "href": "qmd/chapter2.html#pip-更换源",
    "title": "信息技术基础 🧐",
    "section": "pip 更换源",
    "text": "pip 更换源\n\n更换 pip 源（可选）：\n\n由于网络原因，有时从默认的 PyPI 源下载包可能会很慢。\n可以更换为国内的镜像源，提高下载速度。\n常用的国内镜像源：\n\n清华大学：https://pypi.tuna.tsinghua.edu.cn/simple\n阿里云：https://mirrors.aliyun.com/pypi/simple/\n豆瓣：https://pypi.douban.com/simple/\n\n临时更换：在 pip install 命令后加上 -i &lt;镜像源地址&gt;。例如：pip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple"
  },
  {
    "objectID": "qmd/chapter2.html#pip-永久更换源的方法",
    "href": "qmd/chapter2.html#pip-永久更换源的方法",
    "title": "信息技术基础 🧐",
    "section": "pip 永久更换源的方法",
    "text": "pip 永久更换源的方法\n\n更换 pip 源（可选）：\n永久更换：\n\nWindows: 在 %APPDATA% 目录下创建 pip 文件夹，然后在 pip 文件夹中创建 pip.ini 文件，写入内容（见下页）。\nLinux/macOS: 在 ~/.pip/ 目录下创建 pip.conf 文件（如果目录不存在，则创建），写入内容（见后续页）。"
  },
  {
    "objectID": "qmd/chapter2.html#pip-永久更换国内源windows-12",
    "href": "qmd/chapter2.html#pip-永久更换国内源windows-12",
    "title": "信息技术基础 🧐",
    "section": "pip 永久更换国内源（Windows）🪟 (1/2)",
    "text": "pip 永久更换国内源（Windows）🪟 (1/2)\n在 Windows 系统中永久更换 pip 源，可以按照以下步骤操作：\n\n打开文件资源管理器。\n在地址栏输入 %APPDATA%，然后按回车键。\n\n这将打开当前用户的应用程序数据目录。\n\n在该目录下创建一个名为 pip 的新文件夹。\n\n如果 pip 文件夹已存在，则跳过此步骤。"
  },
  {
    "objectID": "qmd/chapter2.html#pip-永久更换国内源windows-22",
    "href": "qmd/chapter2.html#pip-永久更换国内源windows-22",
    "title": "信息技术基础 🧐",
    "section": "pip 永久更换国内源（Windows）🪟 (2/2)",
    "text": "pip 永久更换国内源（Windows）🪟 (2/2)\n\n进入 pip 文件夹。\n在 pip 文件夹中创建一个名为 pip.ini 的新文件。\n\n如果 pip.ini 文件已存在，则跳过此步骤。\n你可以使用记事本或其他文本编辑器创建该文件。\n\n用文本编辑器打开 pip.ini 文件，并将以下内容复制粘贴到文件中：\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n\n这里以清华大学的镜像源为例，你也可以选择其他国内镜像源。\n\n保存并关闭 pip.ini 文件。"
  },
  {
    "objectID": "qmd/chapter2.html#pip-永久更换国内源-linuxmacos-12",
    "href": "qmd/chapter2.html#pip-永久更换国内源-linuxmacos-12",
    "title": "信息技术基础 🧐",
    "section": "pip 永久更换国内源 (Linux/macOS) 🍎 (1/2)",
    "text": "pip 永久更换国内源 (Linux/macOS) 🍎 (1/2)\n在 Linux 或 macOS 系统中永久更换 pip 源，可以按照以下步骤操作：\n\n打开终端。\n创建或编辑 ~/.pip/pip.conf 文件。\n\n如果 ~/.pip 目录不存在，则先创建该目录：\n\nmkdir ~/.pip"
  },
  {
    "objectID": "qmd/chapter2.html#pip-永久更换国内源-linuxmacos-22",
    "href": "qmd/chapter2.html#pip-永久更换国内源-linuxmacos-22",
    "title": "信息技术基础 🧐",
    "section": "pip 永久更换国内源 (Linux/macOS) 🍎 (2/2)",
    "text": "pip 永久更换国内源 (Linux/macOS) 🍎 (2/2)\n\n然后创建或编辑 pip.conf 文件：\n\nnano ~/.pip/pip.conf  # 或者使用你喜欢的文本编辑器，如 vim\n\n将以下内容复制粘贴到 pip.conf 文件中：\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n\n这里以清华大学的镜像源为例，你也可以选择其他国内镜像源。\n\n保存并关闭 pip.conf 文件。\n\n如果你使用的是 nano 编辑器，按 Ctrl + O 保存，然后按 Ctrl + X 退出。"
  },
  {
    "objectID": "qmd/chapter2.html#安装常用数据分析包",
    "href": "qmd/chapter2.html#安装常用数据分析包",
    "title": "信息技术基础 🧐",
    "section": "安装常用数据分析包",
    "text": "安装常用数据分析包\n\n常用数据分析包\n\nPandas: 用于数据处理和分析的强大工具。\nScikit-learn: 包含各种机器学习算法和模型的库。\nMatplotlib: 用于绘制各种图表的库。\n\n\n\n💡如何安装Pandas，Scikit-learn，Matplotlib\n打开CMD或者Powershell这样的终端，在终端中输入：\npip install pandas scikit-learn matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple\n等待安装完毕即可。这里使用了清华的镜像源加速下载。"
  },
  {
    "objectID": "qmd/chapter2.html#使用科学计算发行版-12",
    "href": "qmd/chapter2.html#使用科学计算发行版-12",
    "title": "信息技术基础 🧐",
    "section": "使用科学计算发行版 🧪 (1/2)",
    "text": "使用科学计算发行版 🧪 (1/2)\n\n科学计算发行版 Python\n\n通常包含一个标准版本的 Python，以及预装的多个科学计算、数据分析相关的包。\n可以省去手动安装各个包的麻烦，一次安装，即可拥有完整的科学计算环境。\n非常适合初学者和需要快速搭建环境的用户。\n\n流行的科学计算发行版 Python\n\nAnaconda 🐍\n\nAnaconda官网\n功能强大，包含 Python 和数百个常用的科学计算、数据分析库。"
  },
  {
    "objectID": "qmd/chapter2.html#使用科学计算发行版-22",
    "href": "qmd/chapter2.html#使用科学计算发行版-22",
    "title": "信息技术基础 🧐",
    "section": "使用科学计算发行版 🧪 (2/2)",
    "text": "使用科学计算发行版 🧪 (2/2)\n\n流行的科学计算发行版 Python（续）\n\nAnaconda 🐍 (续)\n\n提供 Conda 包管理工具。\n\nConda 简介：Conda 不仅可以管理 Python 包，还可以创建和管理多个独立的 Python 环境。\n虚拟环境：虚拟环境可以隔离不同项目的依赖，避免包之间的冲突。\n\nAnaconda Navigator：图形化界面，方便管理环境和包。\n\nWinPython 🪟\n\nWinPython官网\n专门为 Windows 系统设计的发行版。\n便携性好，可以放在 U 盘中随身携带。"
  },
  {
    "objectID": "qmd/chapter2.html#anaconda-虚拟环境-12",
    "href": "qmd/chapter2.html#anaconda-虚拟环境-12",
    "title": "信息技术基础 🧐",
    "section": "Anaconda 虚拟环境 📦 (1/2)",
    "text": "Anaconda 虚拟环境 📦 (1/2)\n\n💡 什么是虚拟环境？\n\n虚拟环境是 Python 项目的独立、隔离的运行环境。\n每个虚拟环境都有自己的 Python 解释器和安装的包，与其他虚拟环境互不干扰。\n\n\n\n为什么要使用虚拟环境？\n\n隔离项目依赖：不同的项目可能需要不同版本的 Python 包。使用虚拟环境可以避免包之间的版本冲突。\n保持全局环境干净：避免将所有项目的包都安装在全局 Python 环境中，导致全局环境臃肿、混乱。"
  },
  {
    "objectID": "qmd/chapter2.html#anaconda-虚拟环境-22",
    "href": "qmd/chapter2.html#anaconda-虚拟环境-22",
    "title": "信息技术基础 🧐",
    "section": "Anaconda 虚拟环境 📦 (2/2)",
    "text": "Anaconda 虚拟环境 📦 (2/2)\n\n为什么要使用虚拟环境？（续）\n\n可重现性：可以轻松地创建和共享项目的虚拟环境，确保其他人在相同的环境中运行你的代码。\n\n\n\n如何使用 Anaconda 创建虚拟环境？(1/2)\n\n打开 Anaconda Prompt（Windows）或 终端（macOS/Linux）。\n创建虚拟环境：\n\nconda create -n myenv python=3.8  # 将 myenv 替换为你想要的环境名称\n-   `-n` 选项指定虚拟环境的名称。\n-   `python=3.8` 指定虚拟环境中 Python 的版本。你可以根据需要更改版本号。"
  },
  {
    "objectID": "qmd/chapter2.html#anaconda创建虚拟环境22",
    "href": "qmd/chapter2.html#anaconda创建虚拟环境22",
    "title": "信息技术基础 🧐",
    "section": "Anaconda创建虚拟环境(2/2)",
    "text": "Anaconda创建虚拟环境(2/2)\n\n激活虚拟环境：\n\nWindows:\n\nconda activate myenv\n\nmacOS/Linux:\n\nsource activate myenv\n在虚拟环境中安装包：\npip install pandas scikit-learn matplotlib\n退出虚拟环境：\nconda deactivate"
  },
  {
    "objectID": "qmd/chapter2.html#python-基础知识求斐波那契数列-13",
    "href": "qmd/chapter2.html#python-基础知识求斐波那契数列-13",
    "title": "信息技术基础 🧐",
    "section": "Python 基础知识：求斐波那契数列 🔢 (1/3)",
    "text": "Python 基础知识：求斐波那契数列 🔢 (1/3)\n\n# Fibonacci sequence\n\n\"\"\"\n斐波那契数列\n输入：项数n\n输出：前n项\n\"\"\"\n\nimport os  # 导入 os 模块\n\ndef fibo(num):                    # 定义名为 fibo 的函数，参数为 num\n    numbers = [1, 1]             # 初始化列表，包含前两项\n    for i in range(num - 2):     # 循环计算剩余的项\n        numbers.append(numbers[i] + numbers[i + 1])  # 计算新项并添加到列表\n    return numbers                # 返回计算结果"
  },
  {
    "objectID": "qmd/chapter2.html#python-基础知识求斐波那契数列-23",
    "href": "qmd/chapter2.html#python-基础知识求斐波那契数列-23",
    "title": "信息技术基础 🧐",
    "section": "Python 基础知识：求斐波那契数列 🔢 (2/3)",
    "text": "Python 基础知识：求斐波那契数列 🔢 (2/3)\n\nanswer = fibo(10)              # 调用 fibo 函数，计算前 10 项\nprint(answer)                   # 打印结果\n\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]"
  },
  {
    "objectID": "qmd/chapter2.html#python-基础知识求斐波那契数列-33",
    "href": "qmd/chapter2.html#python-基础知识求斐波那契数列-33",
    "title": "信息技术基础 🧐",
    "section": "Python 基础知识：求斐波那契数列 🔢 (3/3)",
    "text": "Python 基础知识：求斐波那契数列 🔢 (3/3)\n\nif not os.path.exists('result'):  # 检查名为 'result' 的目录是否存在\n    os.mkdir('result')            # 如果不存在，则创建该目录\n\nfile = open('result/fibo.txt', 'w')  # 以写入模式打开文件 'result/fibo.txt'\nfor num in answer:                # 遍历计算结果\n    file.write(str(num) + ' ')     # 将每个数字转换为字符串并写入文件，用空格分隔\nfile.close()                      # 关闭文件"
  },
  {
    "objectID": "qmd/chapter2.html#斐波那契数列代码解释-13",
    "href": "qmd/chapter2.html#斐波那契数列代码解释-13",
    "title": "信息技术基础 🧐",
    "section": "斐波那契数列：代码解释 (1/3)",
    "text": "斐波那契数列：代码解释 (1/3)\n💡 代码详细解释\n\n注释:\n\n# 开头的是单行注释，用于解释单行代码的作用。\n\"\"\" 包围的是多行注释（文档字符串），用于描述函数的功能、输入和输出。\n\n引入包:\n\nimport os 引入了 os 模块，该模块提供了与操作系统交互的功能，如文件和目录操作。\n\n函数定义:\n\ndef fibo(num): 定义了一个名为 fibo 的函数。\ndef 是定义函数的关键字。\nfibo 是函数名。\n(num) 表示函数接受一个参数 num。"
  },
  {
    "objectID": "qmd/chapter2.html#斐波那契数列代码解释-23",
    "href": "qmd/chapter2.html#斐波那契数列代码解释-23",
    "title": "信息技术基础 🧐",
    "section": "斐波那契数列：代码解释 (2/3)",
    "text": "斐波那契数列：代码解释 (2/3)\n\n函数体:\n\n缩进的代码块是函数体，执行具体的操作。\nnumbers = [1, 1]：初始化一个列表 numbers，包含斐波那契数列的前两项 1 和 1。\nfor i in range(num - 2):：循环 num - 2 次。\n\nrange(num - 2) 生成一个从 0 到 num - 3 的整数序列。\nfor 循环用于遍历这个序列，每次迭代将当前的整数赋值给变量 i。\n\nnumbers.append(numbers[i] + numbers[i + 1])：计算新的斐波那契数，并将其添加到 numbers 列表的末尾。\n\nnumbers[i] 表示列表 numbers 中索引为 i 的元素。\nnumbers[i] + numbers[i + 1] 计算当前项和下一项的和。\nappend() 是列表的方法，用于在列表末尾添加元素。\n\nreturn numbers：返回计算好的斐波那契数列列表。"
  },
  {
    "objectID": "qmd/chapter2.html#斐波那契数列代码解释-33",
    "href": "qmd/chapter2.html#斐波那契数列代码解释-33",
    "title": "信息技术基础 🧐",
    "section": "斐波那契数列：代码解释 (3/3)",
    "text": "斐波那契数列：代码解释 (3/3)\n\n函数调用:\n\nanswer = fibo(10) 调用了 fibo 函数，传入参数 10。\nfibo(10) 的返回值（一个列表）被赋值给变量 answer。\n\n打印结果:\n\nprint(answer) 将变量 answer 的值打印到控制台。\n\n条件语句:\n\nif not os.path.exists('result'):：判断名为 result 的目录是否存在。\n\nos.path.exists() 是 os 模块中的函数，用于检查文件或目录是否存在。\nnot 表示取反。\n\nos.mkdir('result')：如果 result 目录不存在，则创建该目录。\n\n文件操作 :\n\nfile = open('result/fibo.txt', 'w'): 以写入模式打开文件 ‘result/fibo.txt’。\n\nopen() 函数返回一个文件对象，赋值给变量 file。\n\nfor num in answer:：遍历 answer 列表中的每个数字。\nfile.write(str(num) + ' ')：将当前数字转换为字符串，并在末尾添加一个空格，然后写入文件。\n\nstr(num) 将数字 num 转换为字符串。\n+ 用于连接字符串。\nfile.write() 是文件对象的方法，用于向文件中写入内容。\n\nfile.close()：关闭文件。关闭文件可以释放资源，并确保写入的内容被保存到磁盘。"
  },
  {
    "objectID": "qmd/chapter2.html#斐波那契数列的数学背景-12",
    "href": "qmd/chapter2.html#斐波那契数列的数学背景-12",
    "title": "信息技术基础 🧐",
    "section": "斐波那契数列的数学背景 ➗ (1/2)",
    "text": "斐波那契数列的数学背景 ➗ (1/2)\n💡 数学公式\n斐波那契数列由以下递推关系定义：\n\n\\(F(0) = 1\\)\n\\(F(1) = 1\\)\n\\(F(n) = F(n-1) + F(n-2)\\) (当 \\(n &gt; 1\\) 时)\n\n其中，\\(F(n)\\) 表示斐波那契数列的第 \\(n\\) 项。\n通项公式\n斐波那契数列的通项公式为：\n\\[\nF(n) = \\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]\n\\]"
  },
  {
    "objectID": "qmd/chapter2.html#斐波那契数列的数学背景-22",
    "href": "qmd/chapter2.html#斐波那契数列的数学背景-22",
    "title": "信息技术基础 🧐",
    "section": "斐波那契数列的数学背景 ➗ (2/2)",
    "text": "斐波那契数列的数学背景 ➗ (2/2)\n与黄金分割的关系\n斐波那契数列与黄金分割（\\(\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618\\)）密切相关。随着项数的增加，斐波那契数列中相邻两项的比值会越来越接近黄金分割。\n\\[\n\\lim_{n\\to\\infty} \\frac{F(n+1)}{F(n)} = \\phi\n\\]\n应用\n斐波那契数列在自然界和人类社会中有很多有趣的出现，例如：\n\n植物的花瓣数、树枝的分叉数、松果的螺线数等。\n艺术作品、建筑设计等。\n在计算机科学中，斐波那契数列可用于某些算法的设计和分析。"
  },
  {
    "objectID": "qmd/chapter2.html#python-基础知识缩进-12",
    "href": "qmd/chapter2.html#python-基础知识缩进-12",
    "title": "信息技术基础 🧐",
    "section": "Python 基础知识：缩进 📏 (1/2)",
    "text": "Python 基础知识：缩进 📏 (1/2)\n\n缩进的重要性\n\n在 Python 中，缩进不仅仅是为了美观，它决定了代码的结构和逻辑。\nPython 使用缩进来区分代码块，而不是像 C++、Java 等语言那样使用花括号 {}。\n同一级别的代码块必须有相同的缩进量。\n通常使用 4 个空格作为标准缩进（强烈建议）。"
  },
  {
    "objectID": "qmd/chapter2.html#python-基础知识缩进-22",
    "href": "qmd/chapter2.html#python-基础知识缩进-22",
    "title": "信息技术基础 🧐",
    "section": "Python 基础知识：缩进 📏 (2/2)",
    "text": "Python 基础知识：缩进 📏 (2/2)\n\n不同类型的语句块\n\n分支结构（if, elif, else）：\n\nif 语句后面的代码块需要缩进。\nelif 和 else 语句后面的代码块也需要缩进，并且与对应的 if 语句对齐。\n\n\n\n\nif condition1:\n     # 如果 condition1 为真，执行这里的代码\n    statement1\nelif condition2:\n    # 如果 condition2 为真，执行这里的代码\n    statement2\nelse:\n    # 如果以上条件都不为真，执行这里的代码\n    statement3"
  },
  {
    "objectID": "qmd/chapter2.html#python-缩进循环结构",
    "href": "qmd/chapter2.html#python-缩进循环结构",
    "title": "信息技术基础 🧐",
    "section": "Python 缩进：循环结构",
    "text": "Python 缩进：循环结构\n\n不同类型的语句块 (续)\n\n循环结构 (for, while):\n\n循环体内的代码需要缩进。\n\n\n\n\nfor item in iterable:\n    # 对于 iterable 中的每个元素，执行这里的代码\n    statement1\n    \nwhile condition:\n    # 当 condition 为真时，重复执行这里的代码\n    statement2"
  },
  {
    "objectID": "qmd/chapter2.html#python-缩进函数",
    "href": "qmd/chapter2.html#python-缩进函数",
    "title": "信息技术基础 🧐",
    "section": "Python 缩进：函数",
    "text": "Python 缩进：函数\n\n不同类型的语句块 (续)\n函数体 (def):\n\n函数体内的代码需要缩进。\n\n\n\ndef function_name(parameters):\n    # 函数体，执行函数的具体操作\n    statement1\n    statement2\n    return value  # 可选的返回值"
  },
  {
    "objectID": "qmd/chapter2.html#python-缩进常见错误-12",
    "href": "qmd/chapter2.html#python-缩进常见错误-12",
    "title": "信息技术基础 🧐",
    "section": "Python 缩进：常见错误 ⚠️ (1/2)",
    "text": "Python 缩进：常见错误 ⚠️ (1/2)\n\n缩进不一致：\n\n在同一个代码块中，有的行缩进了 4 个空格，有的行缩进了 2 个空格，或者使用了 Tab 键。\n\n\n\n# 错误示例\ndef my_function():\n    print(\"Hello\")\nprint(\"World\")  # 缩进不一致"
  },
  {
    "objectID": "qmd/chapter2.html#python-缩进常见错误-22",
    "href": "qmd/chapter2.html#python-缩进常见错误-22",
    "title": "信息技术基础 🧐",
    "section": "Python 缩进：常见错误 ⚠️ (2/2)",
    "text": "Python 缩进：常见错误 ⚠️ (2/2)\n\n缩进级别错误：\n\n代码块的缩进没有正确地反映其逻辑结构。\n\n\n\n# 错误示例\nif x &gt; 0:\nprint(\"x is positive\")  # 缩进错误\nelse:\n    print(\"x is non-positive\")"
  },
  {
    "objectID": "qmd/chapter2.html#python缩进缺少缩进",
    "href": "qmd/chapter2.html#python缩进缺少缩进",
    "title": "信息技术基础 🧐",
    "section": "Python缩进：缺少缩进",
    "text": "Python缩进：缺少缩进\n\n缺少缩进：\n\n应该缩进的代码块没有缩进。\n\n\n\n    # 错误示例\nfor i in range(10):\nprint(i)  # 缺少缩进"
  },
  {
    "objectID": "qmd/chapter2.html#python-缩进最佳实践",
    "href": "qmd/chapter2.html#python-缩进最佳实践",
    "title": "信息技术基础 🧐",
    "section": "Python 缩进：最佳实践 ✅",
    "text": "Python 缩进：最佳实践 ✅\n\n始终使用 4 个空格进行缩进。\n\n这是 Python 社区的推荐做法（PEP 8），大多数 IDE 和文本编辑器都支持。\n\n保持缩进一致。\n\n在同一个代码块中，始终使用相同数量的空格进行缩进。\n\n使用 IDE 或文本编辑器的自动缩进功能。\n注意代码块的嵌套。\n\n内层代码块的缩进要比外层代码块多 4 个空格。"
  },
  {
    "objectID": "qmd/chapter2.html#python缩进最佳实践续",
    "href": "qmd/chapter2.html#python缩进最佳实践续",
    "title": "信息技术基础 🧐",
    "section": "Python缩进：最佳实践（续）",
    "text": "Python缩进：最佳实践（续）\n\n在函数、类、条件语句、循环等后面使用冒号 :，然后换行并缩进。\n避免过深的嵌套。\n\n如果代码嵌套层级过多，会难以阅读和理解。"
  },
  {
    "objectID": "qmd/chapter2.html#python-基础知识模块化-12",
    "href": "qmd/chapter2.html#python-基础知识模块化-12",
    "title": "信息技术基础 🧐",
    "section": "Python 基础知识：模块化 🧩 (1/2)",
    "text": "Python 基础知识：模块化 🧩 (1/2)\n\n模块化的系统\n\nPython 是一种高度模块化的语言。\n可以将代码组织成多个模块（.py 文件），每个模块包含相关的函数、类和变量。\n模块化的好处：\n\n代码复用：可以将常用的功能封装成模块，在不同的程序中重复使用。\n可维护性：将代码分解成更小的部分，易于理解、修改和调试。\n命名空间：不同的模块可以有相同的变量名或函数名，避免命名冲突。"
  },
  {
    "objectID": "qmd/chapter2.html#python-基础知识模块化-22",
    "href": "qmd/chapter2.html#python-基础知识模块化-22",
    "title": "信息技术基础 🧐",
    "section": "Python 基础知识：模块化 🧩 (2/2)",
    "text": "Python 基础知识：模块化 🧩 (2/2)\n\n模块化的系统 (续)\n\nPython 拥有庞大而丰富的标准库和第三方库，提供了各种各样的功能，无需从头编写所有代码。\n\n标准库 (Standard Library)\n\nPython 自带的一组模块，提供了各种常用的功能。\n无需额外安装，可以直接使用。\n常用标准库模块：os, time, datetime, sys, math, random, re, json, urllib等。"
  },
  {
    "objectID": "qmd/chapter2.html#python第三方库",
    "href": "qmd/chapter2.html#python第三方库",
    "title": "信息技术基础 🧐",
    "section": "Python第三方库",
    "text": "Python第三方库\n\n第三方库 (Third-party Libraries)\n\n由 Python 社区开发的各种库，提供了标准库之外的更丰富的功能。\n通常需要使用 pip 安装后才能使用。\n常用第三方库： scipy, scikit-learn等。"
  },
  {
    "objectID": "qmd/chapter2.html#python-标准库示例os-模块-13",
    "href": "qmd/chapter2.html#python-标准库示例os-模块-13",
    "title": "信息技术基础 🧐",
    "section": "Python 标准库示例：os 模块 📁 (1/3)",
    "text": "Python 标准库示例：os 模块 📁 (1/3)\nos 模块提供了与操作系统交互的功能，例如：\n\n文件和目录操作：\n\nos.getcwd(): 获取当前工作目录。\nos.chdir(path): 改变当前工作目录。\nos.listdir(path): 列出指定目录下的文件和子目录。\nos.mkdir(path): 创建目录。"
  },
  {
    "objectID": "qmd/chapter2.html#python-标准库示例os-模块-23",
    "href": "qmd/chapter2.html#python-标准库示例os-模块-23",
    "title": "信息技术基础 🧐",
    "section": "Python 标准库示例：os 模块 📁 (2/3)",
    "text": "Python 标准库示例：os 模块 📁 (2/3)\n\n文件和目录操作（续）：\n\nos.makedirs(path): 递归创建目录。\nos.remove(path): 删除文件。\nos.rmdir(path): 删除空目录。\nos.removedirs(path): 递归删除空目录。\nos.rename(src, dst): 重命名文件或目录。"
  },
  {
    "objectID": "qmd/chapter2.html#python-标准库示例os-模块-33",
    "href": "qmd/chapter2.html#python-标准库示例os-模块-33",
    "title": "信息技术基础 🧐",
    "section": "Python 标准库示例：os 模块 📁 (3/3)",
    "text": "Python 标准库示例：os 模块 📁 (3/3)\n\n文件和目录操作 (续)：\n\nos.path.exists(path): 判断文件或目录是否存在。\nos.path.isfile(path): 判断是否为文件。\nos.path.isdir(path): 判断是否为目录。\nos.path.join(path1, path2, ...): 拼接路径。\nos.path.split(path): 分割路径为目录和文件名。\nos.path.splitext(path): 分割文件名为文件名和扩展名。"
  },
  {
    "objectID": "qmd/chapter2.html#os模块进程管理和其他",
    "href": "qmd/chapter2.html#os模块进程管理和其他",
    "title": "信息技术基础 🧐",
    "section": "os模块：进程管理和其他",
    "text": "os模块：进程管理和其他\n\n进程管理：\n\nos.system(command): 执行系统命令。\nos.popen(command): 执行系统命令并返回输出。\nos.getpid(): 获取当前进程 ID。\nos.getppid(): 获取父进程 ID。\n\n环境变量：\n\nos.environ: 获取所有环境变量。\nos.getenv(key): 获取指定环境变量的值。\nos.putenv(key, value): 设置环境变量。\n\n其他：\n\nos.name: 获取操作系统名称。\nos.sep: 获取路径分隔符。"
  },
  {
    "objectID": "qmd/chapter2.html#os-模块示例代码",
    "href": "qmd/chapter2.html#os-模块示例代码",
    "title": "信息技术基础 🧐",
    "section": "os 模块示例代码",
    "text": "os 模块示例代码\n示例：\n\nimport os\n\n# 获取当前工作目录\ncurrent_dir = os.getcwd()\nprint(f\"当前工作目录：{current_dir}\")\n\n# 创建目录\nif not os.path.exists('mydir'):\n    os.mkdir('mydir')\n    print(\"创建目录：mydir\")\n\n# 列出目录内容\nfiles = os.listdir('.')\nprint(f\"当前目录下的文件和子目录：{files}\")\n\n当前工作目录：/home/runner/work/web-slide-python-visual/web-slide-python-visual/qmd\n创建目录：mydir\n当前目录下的文件和子目录：['_quarto.yml', 'result', 'chapter2.qmd', 'chapter2.quarto_ipynb', 'zwu_logo.png', 'chapter7.qmd', 'mydir', 'chapter3.qmd', '.gitignore', 'chapter1.qmd', 'chapter5.qmd', 'chapter8.qmd', 'chapter6.qmd', 'chapter4.qmd', 'my.css']"
  },
  {
    "objectID": "qmd/chapter2.html#python-标准库示例datetime-模块-12",
    "href": "qmd/chapter2.html#python-标准库示例datetime-模块-12",
    "title": "信息技术基础 🧐",
    "section": "Python 标准库示例：datetime 模块 📅 (1/2)",
    "text": "Python 标准库示例：datetime 模块 📅 (1/2)\ndatetime 模块提供了处理日期和时间的类和函数。\n主要类：\n\ndate: 表示日期（年、月、日）。\ntime: 表示时间（时、分、秒、微秒）。\ndatetime: 表示日期和时间（年、月、日、时、分、秒、微秒）。"
  },
  {
    "objectID": "qmd/chapter2.html#python-标准库示例datetime-模块-22",
    "href": "qmd/chapter2.html#python-标准库示例datetime-模块-22",
    "title": "信息技术基础 🧐",
    "section": "Python 标准库示例：datetime 模块 📅 (2/2)",
    "text": "Python 标准库示例：datetime 模块 📅 (2/2)\n主要类（续）：\n\ntimedelta: 表示时间间隔。\ntimezone: 表示时区。"
  },
  {
    "objectID": "qmd/chapter2.html#datetime模块创建对象",
    "href": "qmd/chapter2.html#datetime模块创建对象",
    "title": "信息技术基础 🧐",
    "section": "datetime模块：创建对象",
    "text": "datetime模块：创建对象\n常用操作：\n\n创建日期和时间对象：\n\n\nfrom datetime import date, time, datetime, timedelta\n\n# 创建日期对象\ntoday = date.today()\nprint(f\"今天的日期：{today}\")\n\n# 创建时间对象\nnow = time(10, 30, 0)  # 10:30:00\nprint(f\"当前时间：{now}\")\n\n# 创建日期时间对象\nnow = datetime.now()\nprint(f\"当前日期和时间：{now}\")\n\n今天的日期：2025-02-17\n当前时间：10:30:00\n当前日期和时间：2025-02-17 16:40:19.199198"
  },
  {
    "objectID": "qmd/chapter2.html#datetime模块指定日期时间",
    "href": "qmd/chapter2.html#datetime模块指定日期时间",
    "title": "信息技术基础 🧐",
    "section": "datetime模块：指定日期时间",
    "text": "datetime模块：指定日期时间\n\n# 指定日期和时间\ndt = datetime(2023, 10, 27, 15, 0, 0)  # 2023-10-27 15:00:00\nprint(f\"指定日期和时间：{dt}\")\n\n指定日期和时间：2023-10-27 15:00:00"
  },
  {
    "objectID": "qmd/chapter2.html#datetime-模块获取信息",
    "href": "qmd/chapter2.html#datetime-模块获取信息",
    "title": "信息技术基础 🧐",
    "section": "datetime 模块：获取信息",
    "text": "datetime 模块：获取信息\n\n获取日期和时间的组成部分：\n\n\n# 获取年、月、日、时、分、秒\nyear = now.year\nmonth = now.month\nday = now.day\nhour = now.hour\nminute = now.minute\nsecond = now.second\n\nprint(f\"年：{year}, 月：{month}, 日：{day}, 时：{hour}, 分：{minute}, 秒：{second}\")\n\n年：2025, 月：2, 日：17, 时：16, 分：40, 秒：19"
  },
  {
    "objectID": "qmd/chapter2.html#datetime模块日期时间运算",
    "href": "qmd/chapter2.html#datetime模块日期时间运算",
    "title": "信息技术基础 🧐",
    "section": "datetime模块：日期时间运算",
    "text": "datetime模块：日期时间运算\n\n日期和时间运算：\n\n\n# 计算时间间隔\ndelta = timedelta(days=7)  # 7 天\nprint(f\"7 天后的日期：{today + delta}\")\n\n# 计算两个日期之间的差值\ndiff = date(2024, 1, 1) - today\nprint(f\"距离 2024 年 1 月 1 日还有：{diff.days} 天\")\n\n7 天后的日期：2025-02-24\n距离 2024 年 1 月 1 日还有：-413 天"
  },
  {
    "objectID": "qmd/chapter2.html#datetime-模块格式化",
    "href": "qmd/chapter2.html#datetime-模块格式化",
    "title": "信息技术基础 🧐",
    "section": "datetime 模块：格式化",
    "text": "datetime 模块：格式化\n\n格式化日期和时间：\n\n\n# 将日期时间对象格式化为字符串\nformatted_date = now.strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"格式化后的日期和时间：{formatted_date}\")\n\n# 将字符串解析为日期时间对象\ndate_str = \"2023-10-27\"\nparsed_date = datetime.strptime(date_str, \"%Y-%m-%d\").date()\nprint(f\"解析后的日期：{parsed_date}\")\n\n格式化后的日期和时间：2025-02-17 16:40:19\n解析后的日期：2023-10-27"
  },
  {
    "objectID": "qmd/chapter2.html#datetime模块时区处理",
    "href": "qmd/chapter2.html#datetime模块时区处理",
    "title": "信息技术基础 🧐",
    "section": "datetime模块：时区处理",
    "text": "datetime模块：时区处理\n\n时区处理：\n\ndatetime 模块本身不提供完善的时区处理功能。\n可以使用第三方库 pytz 或 dateutil 来处理时区相关的操作。"
  },
  {
    "objectID": "qmd/chapter2.html#重要的-python-库pandas-12",
    "href": "qmd/chapter2.html#重要的-python-库pandas-12",
    "title": "信息技术基础 🧐",
    "section": "重要的 Python 库：Pandas 🐼 (1/2)",
    "text": "重要的 Python 库：Pandas 🐼 (1/2)\n\nPandas\n\n构建在 NumPy 之上的高性能数据分析库。\n提供了两种主要的数据结构：\n\nSeries：一维带标签数组，类似于带索引的列表。\nDataFrame：二维表格型数据结构，类似于 Excel 表格或 SQL 表。\n\n可以方便地进行数据清洗、转换、分析和可视化。"
  },
  {
    "objectID": "qmd/chapter2.html#重要的-python-库pandas-22",
    "href": "qmd/chapter2.html#重要的-python-库pandas-22",
    "title": "信息技术基础 🧐",
    "section": "重要的 Python 库：Pandas 🐼 (2/2)",
    "text": "重要的 Python 库：Pandas 🐼 (2/2)\n\nPandas (续)\n\n支持各种数据操作，如：\n\n数据读取和写入：可以读取和写入各种格式的数据。\n数据清洗：处理缺失值、重复值、异常值等。\n数据转换：修改数据类型、重塑数据结构、数据透视等。\n数据选择和过滤：根据条件选择数据、筛选数据。\n数据分组和聚合：按列分组，计算分组统计量。\n数据合并和连接：将多个数据集按指定条件合并。\n排序、分组、归并\n统计计算：求和、求均值、求中位数、求标准差、协方差矩阵计算等。"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-series-示例-13",
    "href": "qmd/chapter2.html#pandas-series-示例-13",
    "title": "信息技术基础 🧐",
    "section": "Pandas Series 示例 📝 (1/3)",
    "text": "Pandas Series 示例 📝 (1/3)\n💡 什么是 Series？\n\nSeries 是 Pandas 中一维带标签的数组。\n可以看作是带有索引的列表或一列数据。\n每个 Series 对象都有一个索引（index）和一个值（values）数组。\n\n创建 Series\n\nimport pandas as pd\n\n# 从列表创建\ndata = [10, 20, 30, 40, 50]\ns = pd.Series(data)\nprint(s)\n\n0    10\n1    20\n2    30\n3    40\n4    50\ndtype: int64"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-series-示例-23",
    "href": "qmd/chapter2.html#pandas-series-示例-23",
    "title": "信息技术基础 🧐",
    "section": "Pandas Series 示例 📝 (2/3)",
    "text": "Pandas Series 示例 📝 (2/3)\n\n# 从字典创建\ndata = {'a': 10, 'b': 20, 'c': 30}\ns = pd.Series(data)\nprint(s)\n\na    10\nb    20\nc    30\ndtype: int64"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-series-示例-33",
    "href": "qmd/chapter2.html#pandas-series-示例-33",
    "title": "信息技术基础 🧐",
    "section": "Pandas Series 示例 📝 (3/3)",
    "text": "Pandas Series 示例 📝 (3/3)\n\n# 指定索引\ndata = [10, 20, 30]\nindex = ['x', 'y', 'z']\ns = pd.Series(data, index=index)\nprint(s)\n\nx    10\ny    20\nz    30\ndtype: int64"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-series访问元素-12",
    "href": "qmd/chapter2.html#pandas-series访问元素-12",
    "title": "信息技术基础 🧐",
    "section": "Pandas Series：访问元素 (1/2)",
    "text": "Pandas Series：访问元素 (1/2)\n访问 Series 中的元素\n\n# 通过位置访问\nprint(s[0])  # 10\n\n# 通过标签访问\nprint(s['x'])  # 10\n\n10\n10\n\n\n/tmp/ipykernel_2637/971424159.py:2: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  print(s[0])  # 10"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-series访问元素-22",
    "href": "qmd/chapter2.html#pandas-series访问元素-22",
    "title": "信息技术基础 🧐",
    "section": "Pandas Series：访问元素 (2/2)",
    "text": "Pandas Series：访问元素 (2/2)\n\n# 切片\nprint(s[1:3])  # 获取索引为 1 和 2 的元素\nprint(s['y':'z'])  # 获取标签为 'y' 和 'z' 的元素\n\ny    20\nz    30\ndtype: int64\ny    20\nz    30\ndtype: int64"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-series运算-12",
    "href": "qmd/chapter2.html#pandas-series运算-12",
    "title": "信息技术基础 🧐",
    "section": "Pandas Series：运算 (1/2)",
    "text": "Pandas Series：运算 (1/2)\n\nimport pandas as pd\ndata = [10, 20, 30]\nindex = ['x', 'y', 'z']\ns = pd.Series(data, index=index)\n\n# 与标量运算\nprint(s * 2)  # 每个元素乘以 2\n\nx    20\ny    40\nz    60\ndtype: int64"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-series运算-22",
    "href": "qmd/chapter2.html#pandas-series运算-22",
    "title": "信息技术基础 🧐",
    "section": "Pandas Series：运算 (2/2)",
    "text": "Pandas Series：运算 (2/2)\n\n# 与另一个 Series 运算\ns1 = pd.Series([1, 2, 3], index=['x', 'y', 'z'])\ns2 = pd.Series([4, 5, 6], index=['x', 'y', 'z'])\nprint(s1 + s2)  # 对应元素相加\n\n# 常用统计方法\nprint(s.mean())  # 平均值\nprint(s.sum())  # 求和\nprint(s.max())  # 最大值\nprint(s.min())  # 最小值\n\nx    5\ny    7\nz    9\ndtype: int64\n20.0\n60\n30\n10"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe-示例-12",
    "href": "qmd/chapter2.html#pandas-dataframe-示例-12",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame 示例 📊 (1/2)",
    "text": "Pandas DataFrame 示例 📊 (1/2)\n💡 什么是 DataFrame？\n\nDataFrame 是 Pandas 中二维表格型数据结构。\n可以看作是由多个 Series 对象组成的表格，每个 Series 对象代表一列。\n每个 DataFrame 对象都有一个行索引（index）和一个列索引（columns）。\n\n创建 DataFrame\n\nimport pandas as pd\n\n# 从字典创建\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35],\n    'city': ['New York', 'London', 'Paris']\n}\ndf = pd.DataFrame(data)\nprint(df)\n\n      name  age      city\n0    Alice   25  New York\n1      Bob   30    London\n2  Charlie   35     Paris"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe-示例-22",
    "href": "qmd/chapter2.html#pandas-dataframe-示例-22",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame 示例 📊 (2/2)",
    "text": "Pandas DataFrame 示例 📊 (2/2)\n\n# 从列表的列表创建\ndata = [\n    ['Alice', 25, 'New York'],\n    ['Bob', 30, 'London'],\n    ['Charlie', 35, 'Paris']\n]\ncolumns = ['name', 'age', 'city']\ndf = pd.DataFrame(data, columns=columns)\nprint(df)\n\n      name  age      city\n0    Alice   25  New York\n1      Bob   30    London\n2  Charlie   35     Paris"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe-获取列",
    "href": "qmd/chapter2.html#pandas-dataframe-获取列",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame: 获取列",
    "text": "Pandas DataFrame: 获取列\n访问 DataFrame 中的数据\n\n# 获取列\nprint(df['name'])  # 获取 'name' 列\nprint(df.age)  # 另一种获取列的方式\n\n0      Alice\n1        Bob\n2    Charlie\nName: name, dtype: object\n0    25\n1    30\n2    35\nName: age, dtype: int64"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe-获取行",
    "href": "qmd/chapter2.html#pandas-dataframe-获取行",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame: 获取行",
    "text": "Pandas DataFrame: 获取行\n\n# 获取行\nprint(df.loc[0])  # 获取第一行（索引为 0）\nprint(df.iloc[0])  # 另一种获取第一行的方式\n\nname       Alice\nage           25\ncity    New York\nName: 0, dtype: object\nname       Alice\nage           25\ncity    New York\nName: 0, dtype: object"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe获取特定单元格",
    "href": "qmd/chapter2.html#pandas-dataframe获取特定单元格",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame：获取特定单元格",
    "text": "Pandas DataFrame：获取特定单元格\n\n# 获取特定单元格\nprint(df.loc[0, 'name'])  # 获取第一行 'name' 列的值\nprint(df.iloc[0, 0])  # 另一种获取方式\n\nAlice\nAlice"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe切片",
    "href": "qmd/chapter2.html#pandas-dataframe切片",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame：切片",
    "text": "Pandas DataFrame：切片\n\n# 切片\nprint(df[0:2])  # 获取前两行\nprint(df[['name', 'age']])  # 获取 'name' 和 'age' 列\n\n    name  age      city\n0  Alice   25  New York\n1    Bob   30    London\n      name  age\n0    Alice   25\n1      Bob   30\n2  Charlie   35"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe-常用操作12",
    "href": "qmd/chapter2.html#pandas-dataframe-常用操作12",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame 常用操作(1/2)",
    "text": "Pandas DataFrame 常用操作(1/2)\n\n# 添加列\ndf['salary'] = [50000, 60000, 70000]\n\n# 筛选数据\nprint(df[df['age'] &gt; 30])  # 获取年龄大于 30 的行\n\n      name  age   city  salary\n2  Charlie   35  Paris   70000"
  },
  {
    "objectID": "qmd/chapter2.html#pandas-dataframe-常用操作22",
    "href": "qmd/chapter2.html#pandas-dataframe-常用操作22",
    "title": "信息技术基础 🧐",
    "section": "Pandas DataFrame 常用操作(2/2)",
    "text": "Pandas DataFrame 常用操作(2/2)\n\n# 排序\nprint(df.sort_values('age'))  # 按年龄升序排序\n\n# 分组统计\nprint(df.groupby('name')['salary'].mean())  # 按姓名分组，计算平均薪资\n\n      name  age      city  salary\n0    Alice   25  New York   50000\n1      Bob   30    London   60000\n2  Charlie   35     Paris   70000\nname\nAlice      50000.0\nBob        60000.0\nCharlie    70000.0\nName: salary, dtype: float64"
  },
  {
    "objectID": "qmd/chapter2.html#重要的-python-库scikit-learn-12",
    "href": "qmd/chapter2.html#重要的-python-库scikit-learn-12",
    "title": "信息技术基础 🧐",
    "section": "重要的 Python 库：Scikit-learn 🤖 (1/2)",
    "text": "重要的 Python 库：Scikit-learn 🤖 (1/2)\n\nScikit-learn\n\n构建在 NumPy、SciPy 和 Matplotlib 上的机器学习库。\n提供了各种经典和常用的机器学习算法和模型，涵盖了监督学习、无监督学习、模型选择、数据预处理等方面。\n\n\n\n\n\nScikit-learn Logo"
  },
  {
    "objectID": "qmd/chapter2.html#重要的-python-库scikit-learn-22",
    "href": "qmd/chapter2.html#重要的-python-库scikit-learn-22",
    "title": "信息技术基础 🧐",
    "section": "重要的 Python 库：Scikit-learn 🤖 (2/2)",
    "text": "重要的 Python 库：Scikit-learn 🤖 (2/2)\n\nScikit-learn (续)\n\n主要功能：\n\n分类 (Classification)：预测数据的类别标签。常用算法有：SVM、k-NN、朴素贝叶斯、决策树、随机森林、逻辑回归。\n回归 (Regression)：预测连续值的目标变量。常用算法有：线性回归、岭回归、Lasso 回归、SVR。\n聚类 (Clustering)：将数据划分为不同的簇。常用算法有：K 均值聚类、层次聚类、DBSCAN。\n降维 (Dimensionality Reduction)：减少数据的特征数量。常用算法有：PCA、LDA、t-SNE。\n模型选择 (Model Selection)：选择最佳的模型和参数。常用方法有：交叉验证、网格搜索、随机搜索。\n预处理 (Preprocessing)：对数据进行预处理，提高模型性能。常用方法有：特征缩放、特征编码、特征选择、缺失值处理。\n\nScikit-learn 简单易用，文档齐全，非常适合快速构建和评估机器学习模型。"
  },
  {
    "objectID": "qmd/chapter2.html#scikit-learn-示例线性回归-13",
    "href": "qmd/chapter2.html#scikit-learn-示例线性回归-13",
    "title": "信息技术基础 🧐",
    "section": "Scikit-learn 示例：线性回归 📈 (1/3)",
    "text": "Scikit-learn 示例：线性回归 📈 (1/3)\n💡 什么是线性回归？\n\n线性回归是一种用于预测连续值目标变量的监督学习算法。\n它假设目标变量与特征之间存在线性关系。\n线性回归的目标是找到一条最佳拟合直线（或超平面），使得预测值与真实值之间的误差最小。\n\n线性回归的数学模型\n\n简单线性回归（单变量）：\n\n\\(y = wx + b\\)\n其中，\\(y\\) 是目标变量，\\(x\\) 是特征，\\(w\\) 是权重，\\(b\\) 是偏置。"
  },
  {
    "objectID": "qmd/chapter2.html#scikit-learn-示例线性回归-23",
    "href": "qmd/chapter2.html#scikit-learn-示例线性回归-23",
    "title": "信息技术基础 🧐",
    "section": "Scikit-learn 示例：线性回归 📈 (2/3)",
    "text": "Scikit-learn 示例：线性回归 📈 (2/3)\n\n线性回归的数学模型 (续)\n\n多元线性回归（多变量）：\n\n\\(y = w_1x_1 + w_2x_2 + ... + w_nx_n + b\\)\n其中，\\(y\\) 是目标变量，\\(x_1, x_2, ..., x_n\\) 是特征，\\(w_1, w_2, ..., w_n\\) 是权重，\\(b\\) 是偏置。"
  },
  {
    "objectID": "qmd/chapter2.html#scikit-learn-示例线性回归-33",
    "href": "qmd/chapter2.html#scikit-learn-示例线性回归-33",
    "title": "信息技术基础 🧐",
    "section": "Scikit-learn 示例：线性回归 📈 (3/3)",
    "text": "Scikit-learn 示例：线性回归 📈 (3/3)\n\n线性回归的数学模型 (续)\n\n矩阵形式：\n\n\\(y = Xw + b\\)\n其中，\\(y\\) 是目标变量向量，\\(X\\) 是特征矩阵，\\(w\\) 是权重向量，\\(b\\) 是偏置向量。"
  },
  {
    "objectID": "qmd/chapter2.html#scikit-learn-线性回归代码示例-12",
    "href": "qmd/chapter2.html#scikit-learn-线性回归代码示例-12",
    "title": "信息技术基础 🧐",
    "section": "Scikit-learn 线性回归代码示例 (1/2)",
    "text": "Scikit-learn 线性回归代码示例 (1/2)\n\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\n\n# 1. 准备数据\nX = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])  # 特征\ny = np.dot(X, np.array([1, 2])) + 3  # 目标变量\n\n# 2. 划分训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 3. 创建模型\nmodel = LinearRegression()\n\n# 4. 训练模型\nmodel.fit(X_train, y_train)\n\nLinearRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LinearRegression?Documentation for LinearRegressioniFittedLinearRegression()"
  },
  {
    "objectID": "qmd/chapter2.html#scikit-learn-线性回归代码示例-22",
    "href": "qmd/chapter2.html#scikit-learn-线性回归代码示例-22",
    "title": "信息技术基础 🧐",
    "section": "Scikit-learn 线性回归代码示例 (2/2)",
    "text": "Scikit-learn 线性回归代码示例 (2/2)\n\n# 5. 预测\ny_pred = model.predict(X_test)\n\n# 6. 评估模型\nmse = mean_squared_error(y_test, y_pred)\nprint(f\"均方误差：{mse}\")\n\n# 7. 查看模型参数\nprint(f\"权重：{model.coef_}\")\nprint(f\"偏置：{model.intercept_}\")\n\n均方误差：3.1554436208840472e-30\n权重：[1. 2.]\n偏置：2.9999999999999956"
  },
  {
    "objectID": "qmd/chapter2.html#重要的-python-库matplotlib-12",
    "href": "qmd/chapter2.html#重要的-python-库matplotlib-12",
    "title": "信息技术基础 🧐",
    "section": "重要的 Python 库：Matplotlib 📊 (1/2)",
    "text": "重要的 Python 库：Matplotlib 📊 (1/2)\n\nMatplotlib\n\nPython 中最常用的绘图库，用于创建各种静态、动态、交互式的图表。\n可以绘制各种图形，如：折线图、散点图、直方图、条形图、饼图、箱线图、等高线图、3D 图形、图像、甚至是动画。\n可以自定义图表的各种属性，如颜色、线型、标记、标题、坐标轴标签、图例等。\n\n\n\n\n\nMatplotlib Logo"
  },
  {
    "objectID": "qmd/chapter2.html#重要的-python-库matplotlib-22",
    "href": "qmd/chapter2.html#重要的-python-库matplotlib-22",
    "title": "信息技术基础 🧐",
    "section": "重要的 Python 库：Matplotlib 📊 (2/2)",
    "text": "重要的 Python 库：Matplotlib 📊 (2/2)\n\nMatplotlib (续)\n\nMatplotlib 提供了两种主要的绘图接口：\n\n基于 MATLAB 风格的接口：使用全局函数来创建和修改图表。\n面向对象的接口：使用 Figure 和 Axes 对象来创建和控制图表。"
  },
  {
    "objectID": "qmd/chapter2.html#matplotlib-示例折线图-13",
    "href": "qmd/chapter2.html#matplotlib-示例折线图-13",
    "title": "信息技术基础 🧐",
    "section": "Matplotlib 示例：折线图 📉 (1/3)",
    "text": "Matplotlib 示例：折线图 📉 (1/3)\n💡 如何使用 Matplotlib 绘制折线图？\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 1. 准备数据\nx = np.linspace(0, 10, 100)  # 生成 0 到 10 之间的 100 个等间距点\ny = np.sin(x)  # 计算正弦值\n\n# 2. 创建图表\nplt.figure(figsize=(8, 6))  # 创建一个 8x6 英寸的图表\n\n&lt;Figure size 768x576 with 0 Axes&gt;\n\n\n&lt;Figure size 768x576 with 0 Axes&gt;"
  },
  {
    "objectID": "qmd/chapter2.html#matplotlib-示例折线图-23",
    "href": "qmd/chapter2.html#matplotlib-示例折线图-23",
    "title": "信息技术基础 🧐",
    "section": "Matplotlib 示例：折线图 📉 (2/3)",
    "text": "Matplotlib 示例：折线图 📉 (2/3)\n\n# 3. 绘制折线图\nplt.plot(x, y, label='sin(x)', color='blue', linestyle='-', linewidth=2)\n\n# 4. 添加标题和标签\nplt.title('Sine Wave')\nplt.xlabel('x')\nplt.ylabel('sin(x)')\n\nText(0, 0.5, 'sin(x)')"
  },
  {
    "objectID": "qmd/chapter2.html#matplotlib-示例折线图-33",
    "href": "qmd/chapter2.html#matplotlib-示例折线图-33",
    "title": "信息技术基础 🧐",
    "section": "Matplotlib 示例：折线图 📉 (3/3)",
    "text": "Matplotlib 示例：折线图 📉 (3/3)\n\n# 5. 添加图例\nplt.legend()\n\n# 6. 添加网格线\nplt.grid(True)\n\n# 7. 显示图表\nplt.show()\n\n/tmp/ipykernel_2637/1043465315.py:2: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()"
  },
  {
    "objectID": "qmd/chapter2.html#matplotlib折线图代码解释12",
    "href": "qmd/chapter2.html#matplotlib折线图代码解释12",
    "title": "信息技术基础 🧐",
    "section": "Matplotlib折线图代码解释(1/2)",
    "text": "Matplotlib折线图代码解释(1/2)\n\nplt.figure(): 创建一个图表对象。\n\nfigsize: 指定图表的大小（英寸）。\n\nplt.plot(): 绘制折线图。\n\nx: x 轴数据。\ny: y 轴数据。\nlabel: 曲线标签（用于图例）。\ncolor: 曲线颜色。"
  },
  {
    "objectID": "qmd/chapter2.html#matplotlib折线图代码解释22",
    "href": "qmd/chapter2.html#matplotlib折线图代码解释22",
    "title": "信息技术基础 🧐",
    "section": "Matplotlib折线图代码解释(2/2)",
    "text": "Matplotlib折线图代码解释(2/2)\n\nplt.plot(): 绘制折线图。（续）\n\nlinestyle: 曲线线型。\nlinewidth: 曲线线宽。\n\nplt.title(): 设置图表标题。\nplt.xlabel(): 设置 x 轴标签。\nplt.ylabel(): 设置 y 轴标签。\nplt.legend(): 显示图例。\nplt.grid(): 显示网格线。\nplt.show(): 显示图表。"
  },
  {
    "objectID": "qmd/chapter2.html#其他重要的-python-库-12",
    "href": "qmd/chapter2.html#其他重要的-python-库-12",
    "title": "信息技术基础 🧐",
    "section": "其他重要的 Python 库 (1/2)",
    "text": "其他重要的 Python 库 (1/2)\n\nNumPy (Numerical Python):\n\nPython 科学计算的基础库。\n提供了高性能的多维数组对象 (ndarray)。\n提供了各种数组操作和数学函数，如矩阵运算、线性代数、傅里叶变换等。\n是许多其他科学计算库的基础。\n\nSciPy (Scientific Python):\n\n构建在 NumPy 之上，提供了更多高级的科学计算功能。\n包含许多数学、科学和工程计算中常用的模块。"
  },
  {
    "objectID": "qmd/chapter2.html#其他重要的-python-库-22",
    "href": "qmd/chapter2.html#其他重要的-python-库-22",
    "title": "信息技术基础 🧐",
    "section": "其他重要的 Python 库 (2/2)",
    "text": "其他重要的 Python 库 (2/2)\n\nScrapy:\n\n强大的网络爬虫框架，用于快速构建网络爬虫应用。\n可以自动抓取网页数据、提取结构化信息、存储数据等。\n\nBeautiful Soup:\n\n网页解析库，可以从 HTML 或 XML 文件中提取数据。\n可以方便地解析网页结构、查找特定标签、提取文本内容等。\n常与 Requests 库一起使用，用于爬取网页数据。"
  },
  {
    "objectID": "qmd/chapter2.html#其他重要的python库补充12",
    "href": "qmd/chapter2.html#其他重要的python库补充12",
    "title": "信息技术基础 🧐",
    "section": "其他重要的Python库补充(1/2)",
    "text": "其他重要的Python库补充(1/2)\n\nNLTK (Natural Language Toolkit):\n\n自然语言处理库，用于文本分析、处理和理解。\n提供了各种自然语言处理工具。\n\nStatsmodels:\n\n统计学计算库，提供各种统计模型和方法。\n可以进行各种统计分析。"
  },
  {
    "objectID": "qmd/chapter2.html#其他重要的python库补充22",
    "href": "qmd/chapter2.html#其他重要的python库补充22",
    "title": "信息技术基础 🧐",
    "section": "其他重要的Python库补充(2/2)",
    "text": "其他重要的Python库补充(2/2)\n\nRequests:\n\n简洁易用的 HTTP 库，用于发送 HTTP 请求，与 Web 服务交互。\n可以方便地发送各种类型的 HTTP 请求，获取响应数据。"
  },
  {
    "objectID": "qmd/chapter2.html#jupyter-notebook-12",
    "href": "qmd/chapter2.html#jupyter-notebook-12",
    "title": "信息技术基础 🧐",
    "section": "Jupyter Notebook 📝 (1/2)",
    "text": "Jupyter Notebook 📝 (1/2)\n\nJupyter Notebook\n\n交互式的数据科学与科学计算开发环境。\n基于 Web 的 Python 编辑器。\n支持 Python、R、Julia、Scala 等在内的超过 40 多种编程语言。\n可以将代码、运行结果、文本、图像、公式、视频等内容整合到一个文档中 (.ipynb 文件)。\n非常适合数据分析、机器学习、科学计算等需要交互式探索和展示结果的场景。"
  },
  {
    "objectID": "qmd/chapter2.html#jupyter-notebook-22",
    "href": "qmd/chapter2.html#jupyter-notebook-22",
    "title": "信息技术基础 🧐",
    "section": "Jupyter Notebook 📝 (2/2)",
    "text": "Jupyter Notebook 📝 (2/2)\n\nJupyter Notebook (续)\n\n主要特点：\n\n交互式编程：可以逐个单元格执行代码，并立即查看结果。\n富文本支持：可以使用 Markdown 语法编写格式丰富的文本。\n代码和结果并存：代码和运行结果都保存在同一个文档中。\n可视化支持：可以直接在 Notebook 中显示图表、图像等。\n可扩展性：支持各种插件和扩展。\n导出功能: 可以将notebook导出为多种格式。\n\n\nJupyterLab\n\nJupyter Notebook的下一代产品，提供更强大的功能和更灵活的界面。"
  },
  {
    "objectID": "qmd/chapter2.html#如何启动jupyter-notebook",
    "href": "qmd/chapter2.html#如何启动jupyter-notebook",
    "title": "信息技术基础 🧐",
    "section": "如何启动Jupyter Notebook",
    "text": "如何启动Jupyter Notebook\n💡 如何启动Jupyter Notebook？\n\n打开命令行或终端。\n导航到你想要保存 Notebook 文件的目录 (可选，但建议这样做)。\n\n使用 cd 命令切换目录。\n\n输入以下命令并按回车键：\n\njupyter notebook\n\n稍等片刻，Jupyter Notebook 会自动在你的默认浏览器中打开。\n在 Jupyter Notebook 界面中，你可以创建新的 Notebook 文件，或者打开已有的文件。"
  },
  {
    "objectID": "qmd/chapter2.html#jupyter-notebook-使用示例-12",
    "href": "qmd/chapter2.html#jupyter-notebook-使用示例-12",
    "title": "信息技术基础 🧐",
    "section": "Jupyter Notebook 使用示例 📈 (1/2)",
    "text": "Jupyter Notebook 使用示例 📈 (1/2)\n\n这是一个绘制双纽线的例子，展示了如何在 Jupyter Notebook 中结合代码、解释文本和图形来清晰地展示数据分析过程。"
  },
  {
    "objectID": "qmd/chapter2.html#jupyter-notebook-使用示例-22",
    "href": "qmd/chapter2.html#jupyter-notebook-使用示例-22",
    "title": "信息技术基础 🧐",
    "section": "Jupyter Notebook 使用示例 📈 (2/2)",
    "text": "Jupyter Notebook 使用示例 📈 (2/2)\n💡 代码详细解释\n这段代码使用了 matplotlib 库在极坐标系中绘制双纽线。\n\n导入库：\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n生成数据：\n\ntheta_list = np.arange(0, 2*np.pi, 0.01)：生成一组角度值。\n\nnp.arange() 是 numpy 中的函数，用于生成等差数列。\nnp.pi 是 numpy 中的常量，表示圆周率 π。"
  },
  {
    "objectID": "qmd/chapter2.html#jupyter-notebook-使用示例-22-1",
    "href": "qmd/chapter2.html#jupyter-notebook-使用示例-22-1",
    "title": "信息技术基础 🧐",
    "section": "Jupyter Notebook 使用示例 📈 (2/2)",
    "text": "Jupyter Notebook 使用示例 📈 (2/2)\n\n生成数据（续）：\n\nr = [2*np.cos(2*theta) for theta in theta_list]：根据双纽线的极坐标方程计算对应的半径值。\n\n这是一个列表推导式。\nnp.cos() 是 numpy 中的函数，用于计算余弦值。\n\n\n\n\n创建图表：\n\naxe = plt.subplot(projection='polar')：创建一个极坐标子图。\n\nplt.subplot() 用于创建子图。\nprojection='polar' 指定子图的类型为极坐标。\n返回的 axe 对象代表这个子图。\n\n\n绘制曲线：\n\naxe.plot(theta_list, r)：在极坐标子图中绘制双纽线。\n\naxe.plot() 是 Axes 对象的方法，用于绘制曲线。\n\n\n设置图表属性：\n\naxe.set_rticks([])：隐藏半径刻度。\n\n显示图表：\n\nplt.show()：显示绘制好的图表。"
  },
  {
    "objectID": "qmd/chapter2.html#双纽线的数学背景-12",
    "href": "qmd/chapter2.html#双纽线的数学背景-12",
    "title": "信息技术基础 🧐",
    "section": "双纽线的数学背景 ➗ (1/2)",
    "text": "双纽线的数学背景 ➗ (1/2)\n💡 数学公式\n双纽线的极坐标方程为：\n\\[\nr^2 = a^2 \\cos(2\\theta)\n\\]\n或\n\\[\nr = \\pm a\\sqrt{\\cos(2\\theta)}\n\\]\n其中，\\(r\\) 是极径，\\(\\theta\\) 是极角，\\(a\\) 是一个常数。"
  },
  {
    "objectID": "qmd/chapter2.html#双纽线的数学背景-22",
    "href": "qmd/chapter2.html#双纽线的数学背景-22",
    "title": "信息技术基础 🧐",
    "section": "双纽线的数学背景 ➗ (2/2)",
    "text": "双纽线的数学背景 ➗ (2/2)\n💡 直角坐标方程\n双纽线的直角坐标方程为：\n\\[\n(x^2 + y^2)^2 = a^2(x^2 - y^2)\n\\]\n💡 参数方程\n双纽线的参数方程为：\n\\[\nx = a\\sqrt{\\cos(2t)}\\cos(t)\n\\]\n\\[\ny = a\\sqrt{\\cos(2t)}\\sin(t)\n\\]\n其中，\\(t\\) 是参数。"
  },
  {
    "objectID": "qmd/chapter2.html#双纽线的性质",
    "href": "qmd/chapter2.html#双纽线的性质",
    "title": "信息技术基础 🧐",
    "section": "双纽线的性质",
    "text": "双纽线的性质\n💡 性质\n\n双纽线关于原点对称。\n双纽线有两个环，分别位于 x 轴的两侧。\n双纽线的形状类似于阿拉伯数字 “8” 或无限符号 “∞”。"
  },
  {
    "objectID": "qmd/chapter2.html#总结",
    "href": "qmd/chapter2.html#总结",
    "title": "信息技术基础 🧐",
    "section": "总结 🎉",
    "text": "总结 🎉\n\nPython 是一种功能强大、应用广泛的编程语言，非常适合数据分析和机器学习。\n\n易学易用、社区强大、库丰富。\n\n掌握 Python 的基本语法、常用库和工具，是进行数据分析的基础。\n\n缩进、模块化、数据类型、控制流等。\nPandas、NumPy、Matplotlib、Scikit-learn 等。\n\nJupyter Notebook 是一个强大的交互式开发环境，可以帮助你更好地探索和展示数据分析结果。\n\n交互式编程、富文本、可视化、代码和结果并存。\n\n不断学习和实践，才能更好地掌握 Python 数据分析技能。💪"
  },
  {
    "objectID": "qmd/chapter2.html#思考与讨论-12",
    "href": "qmd/chapter2.html#思考与讨论-12",
    "title": "信息技术基础 🧐",
    "section": "思考与讨论 🤔 (1/2)",
    "text": "思考与讨论 🤔 (1/2)\n\nPython 还有哪些其他的应用领域？\n\n游戏开发 (Pygame)\n网络编程 (Socket, Twisted)\n图形用户界面 (GUI) 开发 (Tkinter, PyQt, wxPython)"
  },
  {
    "objectID": "qmd/chapter2.html#思考与讨论-22",
    "href": "qmd/chapter2.html#思考与讨论-22",
    "title": "信息技术基础 🧐",
    "section": "思考与讨论 🤔 (2/2)",
    "text": "思考与讨论 🤔 (2/2)\n\n除了本章介绍的库，你还了解哪些常用的 Python 库？它们有什么作用？\n\nTensorFlow, PyTorch: 深度学习框架\nSeaborn: 基于 Matplotlib 的高级绘图库\nBokeh, Plotly: 交互式可视化库\nSQLAlchemy: 数据库 ORM (Object-Relational Mapper)\nFlask, Django: Web 开发框架"
  },
  {
    "objectID": "qmd/chapter2.html#如何利用-jupyter-notebook-提高效率",
    "href": "qmd/chapter2.html#如何利用-jupyter-notebook-提高效率",
    "title": "信息技术基础 🧐",
    "section": "如何利用 Jupyter Notebook 提高效率？",
    "text": "如何利用 Jupyter Notebook 提高效率？\n\n如何利用 Jupyter Notebook 提高你的数据分析效率？\n\n交互式探索数据\n快速原型验证\n编写可重复的分析流程\n制作数据分析报告\n分享和协作"
  },
  {
    "objectID": "qmd/chapter2.html#如何进一步学习python数据分析",
    "href": "qmd/chapter2.html#如何进一步学习python数据分析",
    "title": "信息技术基础 🧐",
    "section": "如何进一步学习Python数据分析？",
    "text": "如何进一步学习Python数据分析？\n\n如何进一步学习和提升 Python 数据分析能力？\n\n阅读官方文档\n学习在线教程\n参与开源项目\n参加数据分析竞赛 (Kaggle)\n阅读相关书籍\n多做项目，多实践"
  },
  {
    "objectID": "qmd/chapter3.html",
    "href": "qmd/chapter3.html",
    "title": "信息技术基础",
    "section": "",
    "text": "我们将围绕以下四个方面展开：\n\n了解数据：数据的分类、特征以及如何描述数据。\n数据质量评估：评估数据的完整性、一致性、准确性和及时性。\n数据清洗：处理缺失值、噪声、不一致和异常数据。\n特征工程：从原始数据中提取有用的特征。"
  },
  {
    "objectID": "qmd/chapter3.html#目录",
    "href": "qmd/chapter3.html#目录",
    "title": "信息技术基础",
    "section": "",
    "text": "我们将围绕以下四个方面展开：\n\n了解数据：数据的分类、特征以及如何描述数据。\n数据质量评估：评估数据的完整性、一致性、准确性和及时性。\n数据清洗：处理缺失值、噪声、不一致和异常数据。\n特征工程：从原始数据中提取有用的特征。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据",
    "href": "qmd/chapter3.html#了解数据",
    "title": "信息技术基础",
    "section": "了解数据 🔎",
    "text": "了解数据 🔎\n首先，深入了解数据。我们需要知道数据有哪些类型，以及如何描述数据的特征。这就像认识一个新朋友 🧑‍🤝‍🧑，要了解他的基本信息和性格特点。😊"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---数据的分类",
    "href": "qmd/chapter3.html#了解数据---数据的分类",
    "title": "信息技术基础",
    "section": "了解数据 - 数据的分类 📊",
    "text": "了解数据 - 数据的分类 📊\n\n\n\n\n\nflowchart TD\n    A[数据 📦] --&gt; B(定量数据 🔢)\n    A --&gt; C(定性数据 🔤)\n    B --&gt; D(离散变量 🎲)\n    B --&gt; E(连续变量 📏)\n    C --&gt; F(定序变量 🥇🥈🥉)\n    C --&gt; G(名义变量 ♂️♀️)"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---数据的分类-续",
    "href": "qmd/chapter3.html#了解数据---数据的分类-续",
    "title": "信息技术基础",
    "section": "了解数据 - 数据的分类 (续)",
    "text": "了解数据 - 数据的分类 (续)\n数据 (Data) 📦 是我们进行分析的基础。就像建筑师需要了解不同类型的建筑材料🧱、木材🪵、钢筋🔩一样，数据分析师也需要了解不同类型的数据。\n在数据分析中，我们通常将数据分为两大类：定量数据和定性数据。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---定量数据",
    "href": "qmd/chapter3.html#了解数据---定量数据",
    "title": "信息技术基础",
    "section": "了解数据 - 定量数据 🔢",
    "text": "了解数据 - 定量数据 🔢\n\n\n\n\n\nflowchart TD\n    A[数据 📦] --&gt; B(定量数据 🔢)\n    B --&gt; D(离散变量 🎲)\n    B --&gt; E(连续变量 📏)\n\n\n\n\n\n\n\n可以测量，用数字表示。\n就像测量身高📏和体重⚖️一样，可以得到具体的数值。\n可参与数学运算，如计算平均值、标准差等。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---定量数据细分",
    "href": "qmd/chapter3.html#了解数据---定量数据细分",
    "title": "信息技术基础",
    "section": "了解数据 - 定量数据：细分",
    "text": "了解数据 - 定量数据：细分\n定量数据又可以分为两种：\n\n离散变量 (Discrete Variable) 🎲\n连续变量 (Continuous Variable) 📏"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散变量",
    "href": "qmd/chapter3.html#了解数据---离散变量",
    "title": "信息技术基础",
    "section": "了解数据 - 离散变量 🎲",
    "text": "了解数据 - 离散变量 🎲\n\n\n\n\n\nflowchart TD\n    B(定量数据 🔢) --&gt; D(离散变量 🎲)\n\n\n\n\n\n\n\n取值有限或可数，通常是整数。\n就像掷骰子🎲，结果只能是1、2、3、4、5、6。\n例如：客户数量、产品数量。\n举例：商店一天卖出的苹果数量🍎可能是10个、25个，但不会是10.5个。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---连续变量",
    "href": "qmd/chapter3.html#了解数据---连续变量",
    "title": "信息技术基础",
    "section": "了解数据 - 连续变量 📏",
    "text": "了解数据 - 连续变量 📏\n\n\n\n\n\nflowchart TD\n    B(定量数据 🔢) --&gt; E(连续变量 📏)\n\n\n\n\n\n\n\n取值可以是区间内的任意值，通常带小数点。\n就像测量身高📏，可以精确到毫米。\n例如：身高、体重、温度。\n举例：身高🧍可能是1.75米，体重可能是68.5公斤。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---定性数据",
    "href": "qmd/chapter3.html#了解数据---定性数据",
    "title": "信息技术基础",
    "section": "了解数据 - 定性数据 🔤",
    "text": "了解数据 - 定性数据 🔤\n\n\n\n\n\nflowchart TD\n    A[数据 📦] --&gt; C(定性数据 🔤)\n    C --&gt; F(定序变量 🥇🥈🥉)\n    C --&gt; G(名义变量 ♂️♀️)\n\n\n\n\n\n\n\n描述性质或类别，通常用文字表示。\n就像描述性格😎或爱好🎨。\n通常不能直接参与数学运算。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---定性数据细分",
    "href": "qmd/chapter3.html#了解数据---定性数据细分",
    "title": "信息技术基础",
    "section": "了解数据 - 定性数据：细分",
    "text": "了解数据 - 定性数据：细分\n定性数据也可以分为两种：\n\n定序变量 (Ordinal Variable) 🥇🥈🥉\n名义变量 (Nominal Variable) ♂️♀️"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---定序变量",
    "href": "qmd/chapter3.html#了解数据---定序变量",
    "title": "信息技术基础",
    "section": "了解数据 - 定序变量 🥇🥈🥉",
    "text": "了解数据 - 定序变量 🥇🥈🥉\n\n\n\n\n\nflowchart TD\n    C(定性数据 🔤) --&gt; F(定序变量 🥇🥈🥉)\n\n\n\n\n\n\n\n类别间有顺序关系，但不能进行数值运算。\n例如：教育程度、满意度。\n举例：比赛奖牌🏅有金牌、银牌、铜牌，有等级顺序，但不能说金牌比银牌“好多少”。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---名义变量",
    "href": "qmd/chapter3.html#了解数据---名义变量",
    "title": "信息技术基础",
    "section": "了解数据 - 名义变量 ♂️♀️",
    "text": "了解数据 - 名义变量 ♂️♀️\n\n\n\n\n\nflowchart TD\n    C(定性数据 🔤) --&gt; G(名义变量 ♂️♀️)\n\n\n\n\n\n\n\n类别间无顺序关系，也不能进行数值运算。\n就像性别🚹🚺，只有类别之分，没有等级。\n例如：性别、颜色、血型。\n举例：性别🚹🚺有男和女，没有等级或顺序关系。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---数据分类总结",
    "href": "qmd/chapter3.html#了解数据---数据分类总结",
    "title": "信息技术基础",
    "section": "了解数据 - 数据分类：总结 📝",
    "text": "了解数据 - 数据分类：总结 📝\n理解数据的分类有助于我们选择合适的分析方法。就像选择合适的工具🛠️来修理不同的东西一样。\n\n\n\n\n\n\n\n\n\n数据类型\n子类型\n特点\n举例\n\n\n\n\n定量数据 🔢\n离散变量 🎲\n取值有限或可数，通常为整数\n客户数量、产品数量\n\n\n\n连续变量 📏\n取值可为区间内任意值，通常带小数点\n身高、体重、收入\n\n\n定性数据 🔤\n定序变量 🥇🥈🥉\n类别间有顺序关系，但不能进行数值运算\n教育程度、满意度\n\n\n\n名义变量 ♂️♀️\n类别间无顺序关系，也不能进行数值运算\n性别、颜色、血型"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---数据的特征",
    "href": "qmd/chapter3.html#了解数据---数据的特征",
    "title": "信息技术基础",
    "section": "了解数据 - 数据的特征 🌟",
    "text": "了解数据 - 数据的特征 🌟\n了解数据的分类后，我们再来看看如何描述数据的特征。就像描述一个人的外貌🧔和性格😎一样。\n首先是集中趋势，描述数据集中在哪个位置。就像射箭🎯，看箭是否集中在靶心🎯。常用测度有均值、中位数和众数。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---数据的特征集中趋势---定性数据",
    "href": "qmd/chapter3.html#了解数据---数据的特征集中趋势---定性数据",
    "title": "信息技术基础",
    "section": "了解数据 - 数据的特征：集中趋势 - 定性数据📊",
    "text": "了解数据 - 数据的特征：集中趋势 - 定性数据📊\n对于定性数据：\n\n均值、中位数通常无意义。\n定序变量：中位数和众数能反映一定含义。\n名义变量：仅众数有意义，但不能代表该特征占多数。\n名义变量中的二分变量：若取值合适，均值可解释。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---集中趋势均值",
    "href": "qmd/chapter3.html#了解数据---集中趋势均值",
    "title": "信息技术基础",
    "section": "了解数据 - 集中趋势：均值 ➕➖",
    "text": "了解数据 - 集中趋势：均值 ➕➖\n均值 (Mean)：\n\n所有数据值的总和除以数据个数。\n就像求平均分。\n公式： \\[\n\\bar{x} = \\frac{\\sum_{i=1}^{n} x_i}{n}\n\\]\n优点：易计算，考虑所有值。\n缺点：易受极端值影响。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---集中趋势中位数",
    "href": "qmd/chapter3.html#了解数据---集中趋势中位数",
    "title": "信息技术基础",
    "section": "了解数据 - 集中趋势：中位数 🧍",
    "text": "了解数据 - 集中趋势：中位数 🧍\n中位数 (Median)：\n\n数据按大小排序后，位于中间位置的数值。\n就像按身高排队🧍🧍🧍，中间人的身高。\n若数据个数为偶数，则为中间两个值的平均值。\n优点：不受极端值影响。\n缺点：不能反映所有数据值信息。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---集中趋势众数",
    "href": "qmd/chapter3.html#了解数据---集中趋势众数",
    "title": "信息技术基础",
    "section": "了解数据 - 集中趋势：众数 🙋",
    "text": "了解数据 - 集中趋势：众数 🙋\n众数 (Mode)：\n\n数据中出现次数最多的数值。\n就像投票🗳️，得票最多的选项。\n优点：不受极端值影响，适用所有类型。\n缺点：可能多众数或无众数，不能反映所有值信息。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---集中趋势总结",
    "href": "qmd/chapter3.html#了解数据---集中趋势总结",
    "title": "信息技术基础",
    "section": "了解数据 - 集中趋势：总结 📝",
    "text": "了解数据 - 集中趋势：总结 📝\n\n\n\n\n\n\n\n\n\n\n测度\n定义\n适用数据类型\n优点\n缺点\n\n\n\n\n均值\n总和除以个数\n定量数据\n易计算，考虑所有值\n易受极端值影响\n\n\n中位数\n排序后中间值\n定量、定序\n不受极端值影响\n不能反映所有值信息\n\n\n众数\n出现次数最多值\n定量、定序、名义\n不受极端值影响，适用所有类型\n可能多众数或无众数，不能反映所有值信息"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---集中趋势举例",
    "href": "qmd/chapter3.html#了解数据---集中趋势举例",
    "title": "信息技术基础",
    "section": "了解数据 - 集中趋势：举例 🍎",
    "text": "了解数据 - 集中趋势：举例 🍎\n举例：\n一组学生成绩：70, 75, 80, 85, 90, 95, 100\n\n均值：85\n中位数：85\n众数：无"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---集中趋势举例-续",
    "href": "qmd/chapter3.html#了解数据---集中趋势举例-续",
    "title": "信息技术基础",
    "section": "了解数据 - 集中趋势：举例 (续) 🍎",
    "text": "了解数据 - 集中趋势：举例 (续) 🍎\n若一个学生成绩为500：\n\n均值：142.14 (受极端值影响)\n中位数：85 (不受影响)\n众数：无"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---集中趋势定性数据",
    "href": "qmd/chapter3.html#了解数据---集中趋势定性数据",
    "title": "信息技术基础",
    "section": "了解数据 - 集中趋势：定性数据 🔤",
    "text": "了解数据 - 集中趋势：定性数据 🔤\n定性数据的集中趋势：\n\n均值、中位数通常无意义。\n众数可反映出现次数最多的类别。\n\n举例：头发颜色调查，众数为“黑色”，则黑发最多。\n\n不同数据类型适用不同集中趋势测度。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度",
    "href": "qmd/chapter3.html#了解数据---离散程度",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度 📏",
    "text": "了解数据 - 离散程度 📏\n除了集中趋势，还需要了解离散程度，描述数据间的差异。就像测量身高差异🚶🧍🚶‍♀️，是悬殊还是接近。\n常见测度：极差、方差、标准差、四分位距、平均差和变异系数。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度定量与定性数据",
    "href": "qmd/chapter3.html#了解数据---离散程度定量与定性数据",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度：定量与定性数据",
    "text": "了解数据 - 离散程度：定量与定性数据\n\n定量数据：\n\n极差：数据范围大小。\n方差、标准差、平均差：数据相对均值偏离。\n变异系数：标准差除以均值，修正度量单位影响。\n\n定性数据：\n\n极差：取值类别，含义有限。\n其他测度对定性数据（尤其名义变量）意义不大。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度极差",
    "href": "qmd/chapter3.html#了解数据---离散程度极差",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度：极差 ↔︎️",
    "text": "了解数据 - 离散程度：极差 ↔︎️\n极差 (Range)：\n\n最大值与最小值之差。\n就像测量班级最高和最矮同学的身高差。\n公式：Range = Max - Min\n优点：计算简单。\n缺点：易受极端值影响，不能反映分布。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度方差",
    "href": "qmd/chapter3.html#了解数据---离散程度方差",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度：方差 📐",
    "text": "了解数据 - 离散程度：方差 📐\n方差 (Variance)：\n\n每个值与均值之差的平方的平均值。\n衡量数据偏离均值的程度。\n公式： \\[\nVar(X) = \\frac{\\sum_{i=1}^{n} (x_i - \\bar{x})^2}{n}\n\\]\n优点：考虑所有值，反映离散程度。\n缺点：单位是数据单位平方，不易解释。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度标准差",
    "href": "qmd/chapter3.html#了解数据---离散程度标准差",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度：标准差 📏",
    "text": "了解数据 - 离散程度：标准差 📏\n标准差 (Standard Deviation)：\n\n方差的平方根。\n衡量偏离均值程度，与数据单位相同。\n公式： \\[\nSD(X) = \\sqrt{Var(X)}\n\\]\n优点：考虑所有值，单位与数据相同，易解释。\n缺点：计算比极差复杂。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度四分位距",
    "href": "qmd/chapter3.html#了解数据---离散程度四分位距",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度：四分位距 📦",
    "text": "了解数据 - 离散程度：四分位距 📦\n四分位距 (IQR)：\n\n上四分位数(Q3)与下四分位数(Q1)之差。\n衡量中间50%数据的离散程度。\n公式：IQR = Q3 - Q1\n优点：不受极端值影响。\n缺点：不能反映所有值信息。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度平均差",
    "href": "qmd/chapter3.html#了解数据---离散程度平均差",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度：平均差 ➖",
    "text": "了解数据 - 离散程度：平均差 ➖\n平均差 (MAD)：\n\n每个值与均值之差的绝对值的平均值。\n衡量数据偏离均值的平均距离。\n公式： \\[\nMAD = \\frac{\\sum_{i=1}^{n} |x_i - \\bar{x}|}{n}\n\\]\n优点：考虑所有值，反映离散程度。\n缺点：计算相对复杂。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离散程度变异系数",
    "href": "qmd/chapter3.html#了解数据---离散程度变异系数",
    "title": "信息技术基础",
    "section": "了解数据 - 离散程度：变异系数 ➗",
    "text": "了解数据 - 离散程度：变异系数 ➗\n变异系数 (CV)：\n\n标准差除以均值。\n衡量相对离散程度，无量纲。\n公式： \\[\nCV = \\frac{SD(X)}{\\bar{x}}\n\\]\n优点：无量纲，可比较不同数据集离散。\n\n举例：比较身高和体重离散程度。\n\n缺点：均值接近0时可能很大，失去意义。"
  },
  {
    "objectID": "qmd/chapter3.html#离散程度总结",
    "href": "qmd/chapter3.html#离散程度总结",
    "title": "信息技术基础",
    "section": "离散程度：总结 📝",
    "text": "离散程度：总结 📝\n\n\n\n\n\n\n\n\n\n指标\n定义\n优点\n缺点\n\n\n\n\n极差\n最大值与最小值之差\n计算简单\n易受极端值影响，不能反映分布\n\n\n方差\n值与均值之差的平方的平均值\n考虑所有值，反映离散\n单位平方，不易解释\n\n\n标准差\n方差平方根\n考虑所有值，单位与数据相同，易解释\n计算较复杂\n\n\n四分位距\nQ3与Q1之差\n不受极端值影响\n不能反映所有值信息\n\n\n平均差\n值与均值之差的绝对值的平均值\n考虑所有值，反映离散\n计算较复杂\n\n\n变异系数\n标准差除以均值\n无量纲，可比较不同数据集\n均值接近0时可能很大，失去意义"
  },
  {
    "objectID": "qmd/chapter3.html#离散程度总结-续",
    "href": "qmd/chapter3.html#离散程度总结-续",
    "title": "信息技术基础",
    "section": "离散程度：总结 (续) 🍎",
    "text": "离散程度：总结 (续) 🍎\n两组数据：\n\nA: 1, 2, 3, 4, 5\nB: 1, 1, 3, 5, 5\n\n均值都为3，但离散程度不同：\n\nA: 极差=4, 方差=2, 标准差≈1.41, IQR=3, MAD=1.2, CV≈0.47\nB: 极差=4, 方差=3.2, 标准差≈1.79, IQR=4, MAD=1.6, CV≈0.60\n\nB组离散程度更大。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---相关性",
    "href": "qmd/chapter3.html#了解数据---相关性",
    "title": "信息技术基础",
    "section": "了解数据 - 相关性 🤝",
    "text": "了解数据 - 相关性 🤝\n测量相关性，了解变量变化是否相关。就像研究朋友关系🧑‍🤝‍🧑，看是否经常一起玩耍🤹。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---相关性方法",
    "href": "qmd/chapter3.html#了解数据---相关性方法",
    "title": "信息技术基础",
    "section": "了解数据 - 相关性：方法",
    "text": "了解数据 - 相关性：方法\n\n相关性测量 🤝\n\n可视化：折线图📈、散点图，探索关系。\n\n举例：气温🌡️和冰淇淋销量🍦。\n\n协方差：确定关系正负，无强度信息，受单位影响。\n相关系数：不受单位影响，理论上限±1，完全线性相关。\n\n举例：身高🧍和体重⚖️。\n\n回归分析：一元或多元。\n\n举例：广告投入💰预测销售额📈。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---协方差",
    "href": "qmd/chapter3.html#了解数据---协方差",
    "title": "信息技术基础",
    "section": "了解数据 - 协方差 ➗✖️",
    "text": "了解数据 - 协方差 ➗✖️\n协方差 (Covariance)：\n\n衡量两变量总体误差。趋势一致为正，相反为负，独立为0。\n公式： \\[\nCov(X, Y) = \\frac{\\sum_{i=1}^{n} (x_i - \\bar{x})(y_i - \\bar{y})}{n}\n\\]\n优点：判断趋势是否一致。\n缺点：受单位影响，不能反映强度。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---相关系数",
    "href": "qmd/chapter3.html#了解数据---相关系数",
    "title": "信息技术基础",
    "section": "了解数据 - 相关系数 📏",
    "text": "了解数据 - 相关系数 📏\n相关系数 (Correlation Coefficient)：\n\n衡量线性相关程度，[-1, 1]。\n公式 (Pearson)： \\[\nr = \\frac{Cov(X, Y)}{SD(X) \\cdot SD(Y)}\n\\]\n优点：不受单位影响，反映强度，范围固定。\n解释：\n\nr = 1：完全正相关。\nr = -1：完全负相关。\nr = 0：不相关。\n|r|越大，相关性越强。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---相关系数举例",
    "href": "qmd/chapter3.html#了解数据---相关系数举例",
    "title": "信息技术基础",
    "section": "了解数据 - 相关系数：举例",
    "text": "了解数据 - 相关系数：举例\n\n\n\n相关系数\n解释\n\n\n\n\n0.9\n强正相关\n\n\n0.5\n中等正相关\n\n\n0.1\n弱正相关\n\n\n0\n不相关\n\n\n-0.1\n弱负相关\n\n\n-0.5\n中等负相关\n\n\n-0.9\n强负相关"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---相关性可视化",
    "href": "qmd/chapter3.html#了解数据---相关性可视化",
    "title": "信息技术基础",
    "section": "了解数据 - 相关性可视化 📊",
    "text": "了解数据 - 相关性可视化 📊\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成模拟数据\nnp.random.seed(42)\nx = np.random.rand(50) * 10\ny = 2 * x + 1 + np.random.randn(50) * 2\n\n# 绘制散点图\nplt.figure(figsize=(8, 6))\nplt.scatter(x, y)\nplt.xlabel(\"变量 X\")\nplt.ylabel(\"变量 Y\")\nplt.title(\"相关性可视化\")\nplt.show()\n\n\n\n\n\n\n\nFigure 1: 相关性可视化示例"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---相关性可视化-续",
    "href": "qmd/chapter3.html#了解数据---相关性可视化-续",
    "title": "信息技术基础",
    "section": "了解数据 - 相关性可视化 (续)",
    "text": "了解数据 - 相关性可视化 (续)\n相关性可视化:\n\n散点图直观展示关系。\n点呈现趋势 (如倾斜) 则可能相关。\n点杂乱无章则可能不相关。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---数据缺失",
    "href": "qmd/chapter3.html#了解数据---数据缺失",
    "title": "信息技术基础",
    "section": "了解数据 - 数据缺失 ❓",
    "text": "了解数据 - 数据缺失 ❓\n真实数据常有数据缺失。像书📚缺页。需了解原因和类型，以便处理。\n\n数据缺失 (Missing Data) ❓\n\n不含缺失值的变量称完全变量，含缺失值称不完全变量。\n原因：\n\n遗漏：采集故障、存储故障、人为因素等。\n\n举例：传感器故障📡。\n\n属性不存在。\n\n举例：未填婚姻状况💑。\n\n信息忽略。\n\n举例：认为“昵称”👻不重要。\n\n\n\n举例：\n\n收入缺失 💸\n参数缺失 ⚙️\n未答问题 📝"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---缺失原因",
    "href": "qmd/chapter3.html#了解数据---缺失原因",
    "title": "信息技术基础",
    "section": "了解数据 - 缺失原因",
    "text": "了解数据 - 缺失原因\n数据缺失的原因：\n\n数据遗漏：\n\n设备故障：传感器📡、硬盘💽。\n网络问题：中断🔗、丢包。\n人为因素：录入错误⌨️、忘填。\n\n属性不存在：\n\n对象本身不具备。\n\n举例：未婚无配偶。\n\n\n信息被忽略：\n\n采集者认为不重要。\n用户不愿提供。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---噪声",
    "href": "qmd/chapter3.html#了解数据---噪声",
    "title": "信息技术基础",
    "section": "了解数据 - 噪声 📢",
    "text": "了解数据 - 噪声 📢\n噪声是数据中随机误差或偏差。像照片噪点，影响清晰度。需识别处理，减少影响。\n\n噪声 (Noise) 📢\n\n观测变量的随机误差或方差。\n观测量 = 真实数据 + 噪声\n\n举例：\n\n测量误差 📏\n录入错误 ⌨️\n随机干扰 ⚡"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---噪声来源",
    "href": "qmd/chapter3.html#了解数据---噪声来源",
    "title": "信息技术基础",
    "section": "了解数据 - 噪声来源",
    "text": "了解数据 - 噪声来源\n噪声的来源：\n\n测量误差：\n\n仪器精度限制。\n环境干扰。\n人为操作误差。\n\n采集错误：\n\n录入错误。\n传输错误。\n\n随机因素：\n\n自然波动。\n无法预测干扰。"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离群点",
    "href": "qmd/chapter3.html#了解数据---离群点",
    "title": "信息技术基础",
    "section": "了解数据 - 离群点 🦄",
    "text": "了解数据 - 离群点 🦄\n离群点是明显不同的数据点。像羊群🐑中独角兽🦄。需识别处理，避免误导。\n\n离群点 (Outlier) 🦄\n\n与一般行为或模型不一致的数据。\n\n举例：\n\n欺诈交易 💳\n异常天气 🌪️\n疾病爆发 🤒"
  },
  {
    "objectID": "qmd/chapter3.html#了解数据---离群点原因",
    "href": "qmd/chapter3.html#了解数据---离群点原因",
    "title": "信息技术基础",
    "section": "了解数据 - 离群点原因",
    "text": "了解数据 - 离群点原因\n离群点的原因：\n\n数据错误：\n\n录入错误。\n测量错误。\n\n异常事件：\n\n罕见现象。\n突发事件。\n\n真实变异：\n\n个体差异。\n\n举例：篮球运动员身高。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量",
    "href": "qmd/chapter3.html#数据质量",
    "title": "信息技术基础",
    "section": "数据质量 💯",
    "text": "数据质量 💯\n预处理前，评估数据质量。像做菜🧑‍🍳前检查食材🥬🥕🥩。质量影响结果可靠性。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量四要素",
    "href": "qmd/chapter3.html#数据质量四要素",
    "title": "信息技术基础",
    "section": "数据质量：四要素",
    "text": "数据质量：四要素\n\n数据分析结果有效性和准确性的前提。💪\n四要素：\n\n完整性 (Completeness)\n一致性 (Consistency)\n准确性 (Accuracy)\n及时性 (Timeliness)"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---完整性",
    "href": "qmd/chapter3.html#数据质量---完整性",
    "title": "信息技术基础",
    "section": "数据质量 - 完整性 💯",
    "text": "数据质量 - 完整性 💯\n完整性 (Completeness) 💯\n\n数据信息是否缺失。可能是记录缺失，也可能是字段缺失。\n\n举例: 记录缺失像漏掉家庭👨‍👩‍👧‍👦信息；字段缺失像漏填必填项。\n\n不完整数据价值降低，是基础评估标准。像书📚缺页。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---完整性检查",
    "href": "qmd/chapter3.html#数据质量---完整性检查",
    "title": "信息技术基础",
    "section": "数据质量 - 完整性：检查",
    "text": "数据质量 - 完整性：检查\n\n统计记录数和唯一值个数。\n\n日志访问量突降需检查。\n地区统计缺失需检查。\n\n统计空值(NULL)个数。\n\n举例: Python pandas：\n\n\n\nimport pandas as pd\nimport numpy as np\n\n# 创建含缺失值的DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie', None],\n        'Age': [25, np.nan, 30, 40],\n        'City': ['NY', 'London', np.nan, 'Tokyo']}\ndf = pd.DataFrame(data)\n\n# 检查缺失值\nprint(df.isnull().sum())\n\nName    1\nAge     1\nCity    1\ndtype: int64"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---完整性评估",
    "href": "qmd/chapter3.html#数据质量---完整性评估",
    "title": "信息技术基础",
    "section": "数据质量 - 完整性：评估",
    "text": "数据质量 - 完整性：评估\n如何评估完整性：\n\n计算缺失值比例：\n\n缺失值数量 / 总数据量。\n\n检查关键字段是否缺失：\n\n举例：客户ID、订单号。\n\n可视化缺失值：\n\n热力图、条形图等。\n\nPython missingno库：\n\n\n\n\nimport missingno as msno\nimport pandas as pd\nimport numpy as np\n\n# 创建含缺失值的DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie', None],\n        'Age': [25, np.nan, 30, 40],\n        'City': ['NY', 'London', np.nan, 'Tokyo']}\ndf = pd.DataFrame(data)\n\n# 可视化缺失值\nmsno.matrix(df)"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---一致性",
    "href": "qmd/chapter3.html#数据质量---一致性",
    "title": "信息技术基础",
    "section": "数据质量 - 一致性 🔄",
    "text": "数据质量 - 一致性 🔄\n一致性 (Consistency) 🔄\n\n数据是否合乎规范，集合内数据是否统一格式。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---一致性体现",
    "href": "qmd/chapter3.html#数据质量---一致性体现",
    "title": "信息技术基础",
    "section": "数据质量 - 一致性：体现",
    "text": "数据质量 - 一致性：体现\n\n主要体现在记录规范和是否符合逻辑。\n\n规范：编码、格式，如手机号13位数字，IP地址格式。\n\n举例: 身份证、日期格式。\n\n逻辑：数据间关系，如PV≥UV，跳出率0-1间。\n\n举例: 年龄非负，身高不超3米。\n\n\n一致性审核重要且复杂。像检查产品📦📦📦是否符合规格。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---一致性举例",
    "href": "qmd/chapter3.html#数据质量---一致性举例",
    "title": "信息技术基础",
    "section": "数据质量 - 一致性：举例",
    "text": "数据质量 - 一致性：举例\n\n举例:\n\n日期格式：\n\n2023-10-26\n10/26/2023\n\n单位：\n\n温度：℃, ℉\n长度：m, ft"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---一致性举例-续",
    "href": "qmd/chapter3.html#数据质量---一致性举例-续",
    "title": "信息技术基础",
    "section": "数据质量 - 一致性：举例 (续)",
    "text": "数据质量 - 一致性：举例 (续)\n\n编码：\n\n性别：“男/女”, “M/F”, “1/0”\n地区：“北京”, “北京市”\n\n逻辑矛盾：\n\n下单时间晚于发货。\n年龄大于150。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---一致性检查",
    "href": "qmd/chapter3.html#数据质量---一致性检查",
    "title": "信息技术基础",
    "section": "数据质量 - 一致性：检查",
    "text": "数据质量 - 一致性：检查\n\n检查：\n\n定义规范：格式、编码、范围等。\n数据剖析：工具或脚本检查格式、分布等。\n校验规则：编写规则检查关系。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---准确性",
    "href": "qmd/chapter3.html#数据质量---准确性",
    "title": "信息技术基础",
    "section": "数据质量 - 准确性 ✅",
    "text": "数据质量 - 准确性 ✅\n准确性 (Accuracy) ✅\n\n数据记录信息是否异常或错误。\n关注数据中的错误。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---准确性错误",
    "href": "qmd/chapter3.html#数据质量---准确性错误",
    "title": "信息技术基础",
    "section": "数据质量 - 准确性：错误",
    "text": "数据质量 - 准确性：错误\n\n关注错误，例如：\n\n乱码。\n\n举例: 中文变“锟斤拷”�。\n\n异常值，不符有效性。\n\n举例: 年龄-5，身高10米。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---准确性数据集",
    "href": "qmd/chapter3.html#数据质量---准确性数据集",
    "title": "信息技术基础",
    "section": "数据质量 - 准确性：数据集",
    "text": "数据质量 - 准确性：数据集\n\n可能存在于个别记录，也可能存在于整个数据集。\n\n字段错误，如数量级错误，易发现。\n个别异常值，用最大值、最小值、箱线图审核。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---准确性举例",
    "href": "qmd/chapter3.html#数据质量---准确性举例",
    "title": "信息技术基础",
    "section": "数据质量 - 准确性：举例",
    "text": "数据质量 - 准确性：举例\n\n举例：\n\n拼写错误：“北京”写成“背景”。\n数值错误：“100”写成“1000”。\n单位错误：“米”写成“厘米”。\n乱码：文本显示为无法识别字符。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---准确性检查",
    "href": "qmd/chapter3.html#数据质量---准确性检查",
    "title": "信息技术基础",
    "section": "数据质量 - 准确性：检查",
    "text": "数据质量 - 准确性：检查\n\n检查：\n\n可视化：散点图、直方图、箱线图。\n统计分析：均值、中位数、标准差。\n业务规则校验：检查是否符合常识。\n数据比对：与可靠来源比对。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---准确性箱线图",
    "href": "qmd/chapter3.html#数据质量---准确性箱线图",
    "title": "信息技术基础",
    "section": "数据质量 - 准确性：箱线图 📦",
    "text": "数据质量 - 准确性：箱线图 📦\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成模拟数据\nnp.random.seed(42)\ndata = np.concatenate([np.random.normal(0, 1, 950), \n                       np.random.normal(8, 2, 50)])\n\n# 绘制箱线图\nplt.figure(figsize=(8, 6))\nplt.boxplot(data, showmeans=True)\nplt.xlabel(\"数据\")\nplt.ylabel(\"值\")\nplt.title(\"箱线图\")\nplt.show()\n\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 20540 (\\N{CJK UNIFIED IDEOGRAPH-503C}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 31665 (\\N{CJK UNIFIED IDEOGRAPH-7BB1}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 32447 (\\N{CJK UNIFIED IDEOGRAPH-7EBF}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 22270 (\\N{CJK UNIFIED IDEOGRAPH-56FE}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 25968 (\\N{CJK UNIFIED IDEOGRAPH-6570}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n/home/runner/.local/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Glyph 25454 (\\N{CJK UNIFIED IDEOGRAPH-636E}) missing from font(s) DejaVu Sans.\n  fig.canvas.print_figure(bytes_io, **kw)\n\n\n\n\n\n\n\n\nFigure 2: 箱线图示例"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---准确性箱线图-续",
    "href": "qmd/chapter3.html#数据质量---准确性箱线图-续",
    "title": "信息技术基础",
    "section": "数据质量 - 准确性：箱线图 (续)",
    "text": "数据质量 - 准确性：箱线图 (续)\n箱线图：\n\n箱体：中间50%数据。\n中位数：箱体中间线。\n上下边缘：Q3和Q1。\n触须：延伸至1.5倍IQR。\n异常值：超出触须点。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---及时性",
    "href": "qmd/chapter3.html#数据质量---及时性",
    "title": "信息技术基础",
    "section": "数据质量 - 及时性 ⏱️",
    "text": "数据质量 - 及时性 ⏱️\n及时性 (Timeliness) ⏱️\n\n数据产生到可查看的间隔，即延时。\n\n举例: 股票行情、天气预报。\n\n数据分析周期加建立时间过长，结论失去意义。像新闻📰时效性。"
  },
  {
    "objectID": "qmd/chapter3.html#数据质量---及时性重要性",
    "href": "qmd/chapter3.html#数据质量---及时性重要性",
    "title": "信息技术基础",
    "section": "数据质量 - 及时性：重要性",
    "text": "数据质量 - 及时性：重要性\n重要性：\n\n实时决策：需据最新数据快速决策。\n\n举例：股票交易、自动驾驶。\n\n趋势分析：过时数据无法反映当前。\n\n举例：去年数据分析明年销售。\n\n数据价值：随时间推移，价值降低。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗",
    "href": "qmd/chapter3.html#数据清洗",
    "title": "信息技术基础",
    "section": "数据清洗 🧼",
    "text": "数据清洗 🧼\n数据清洗是预处理重要环节，解决质量问题。像做菜🧑‍🍳前洗食材。\n目的是处理缺失值、噪声、不一致、异常数据，使数据符合标准。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗内容",
    "href": "qmd/chapter3.html#数据清洗内容",
    "title": "信息技术基础",
    "section": "数据清洗：内容",
    "text": "数据清洗：内容\n\n缺失值处理\n噪声数据处理\n不一致数据处理\n异常数据处理"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值",
    "href": "qmd/chapter3.html#数据清洗---缺失值",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值 ❓",
    "text": "数据清洗 - 缺失值 ❓\n缺失值，可忽略或填补。选择取决于比例和特点。像修衣服👕，洞大则扔，小则补。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值方法",
    "href": "qmd/chapter3.html#数据清洗---缺失值方法",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：方法",
    "text": "数据清洗 - 缺失值：方法\n\n方法：\n\n忽略 (Deletion)：简单，但可能损失数据。像扔苹果🍎。\n填补 (Imputation)：填固定值、均值，或据记录填充。像替苹果🍎。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值忽略",
    "href": "qmd/chapter3.html#数据清洗---缺失值忽略",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：忽略",
    "text": "数据清洗 - 缺失值：忽略\n忽略 (Deletion)：\n\n方法：\n\n删含缺失值记录 (行)。\n删缺失过多属性 (列)。\n\n优点：简单。\n缺点：\n\n可能损失数据。\n可能偏差。\n\n举例：缺失值集中某群体，删数据致结果偏。\n\n\n适用：\n\n缺失值比例低。\n缺失值不重要。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值填补",
    "href": "qmd/chapter3.html#数据清洗---缺失值填补",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：填补",
    "text": "数据清洗 - 缺失值：填补\n填补 (Imputation)：\n\n方法：\n\n固定值：0、-1、“未知”。\n统计值：均值、中位数、众数。\n模型预测：回归、决策树。\n最近邻：用相似记录值填充。\n\n优点：\n\n保留记录。\n减少损失。\n\n缺点：\n\n填补值可能不准。\n可能偏差。\n\n适用：\n\n缺失值比例高。\n缺失值重要。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值固定值",
    "href": "qmd/chapter3.html#数据清洗---缺失值固定值",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：固定值",
    "text": "数据清洗 - 缺失值：固定值\n固定值填补：\n\n举例：\n\n数值型：0或-1。\n类别型：“未知”、“佚名”、“N/A”。\n\n优点：简单。\n缺点：\n\n单一，不符实际。\n可能偏差。\n\n适用：\n\n含义明确，可用固定值替代。\n\n举例：“是否已婚”，缺失值用0表未婚。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值统计值",
    "href": "qmd/chapter3.html#数据清洗---缺失值统计值",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：统计值",
    "text": "数据清洗 - 缺失值：统计值\n统计值填补：\n\n举例：\n\n数值型：均值、中位数、众数。\n类别型：众数。\n\n优点：利用已有信息。\n缺点：\n\n易受极端值影响 (均值)。\n可能掩盖分布。\n\n适用：\n\n数值型，分布均匀 (均值)。\n数值型，分布偏斜 (中位数)。\n类别型 (众数)。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值模型预测",
    "href": "qmd/chapter3.html#数据清洗---缺失值模型预测",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：模型预测",
    "text": "数据清洗 - 缺失值：模型预测\n模型预测填补：\n\n举例：\n\n回归、决策树、随机森林。\n\n优点：\n\n利用关系，填补值更接近真实。\n\n缺点：\n\n计算复杂。\n需选模型。\n可能过拟合。\n\n适用：\n\n与其他变量有强关系。\n有合适模型。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值对比",
    "href": "qmd/chapter3.html#数据清洗---缺失值对比",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：对比 📝",
    "text": "数据清洗 - 缺失值：对比 📝\n\n\n\n\n\n\n\n\n\n方法\n优点\n缺点\n适用场景\n\n\n\n\n忽略\n简单\n可能损失数据，偏差\n比例低，不重要\n\n\n填补\n保留记录，减少损失\n可能不准，偏差\n比例高，重要\n\n\n固定值\n简单\n单一，不符实际\n含义明确，可固定值替代\n\n\n统计值\n利用已有信息\n易受极端影响，掩盖分布\n数值型，分布均匀(均值)；偏斜(中位数)；类别型(众数)\n\n\n模型预测\n利用关系，更接近真实\n计算复杂，需选模型，可能过拟合\n与其他变量强关系，有模型"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值举例",
    "href": "qmd/chapter3.html#数据清洗---缺失值举例",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值：举例",
    "text": "数据清洗 - 缺失值：举例\n举例：\n“年龄”列有缺失值。\n\n忽略：删年龄缺失记录。\n固定值：用0或-1填充。\n统计值：用已知年龄均值填充。\n模型预测：据职业、收入等"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---缺失值处理模型预测续",
    "href": "qmd/chapter3.html#数据清洗---缺失值处理模型预测续",
    "title": "信息技术基础",
    "section": "数据清洗 - 缺失值处理：模型预测（续）",
    "text": "数据清洗 - 缺失值处理：模型预测（续）\n模型预测填补：\n\n举例：\n\n根据用户的其他信息（如职业、收入等），建立一个模型来预测缺失的年龄。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---噪声数据处理",
    "href": "qmd/chapter3.html#数据清洗---噪声数据处理",
    "title": "信息技术基础",
    "section": "数据清洗 - 噪声数据处理 🔊",
    "text": "数据清洗 - 噪声数据处理 🔊\n对于噪声数据，我们可以使用分箱、聚类或回归等方法进行处理。就像去除照片上的噪点📸一样，让照片更清晰。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---噪声数据处理方法",
    "href": "qmd/chapter3.html#数据清洗---噪声数据处理方法",
    "title": "信息技术基础",
    "section": "数据清洗 - 噪声数据处理：方法",
    "text": "数据清洗 - 噪声数据处理：方法\n\n分箱 (Binning) 🗑️\n\n通过考察相邻数据来确定最终值，实现平滑。按属性值划分子区间，放入“箱子”。箱深表记录数，宽表范围。\n举例: 年龄分段：0-10、11-20、21-30岁等。\n\n聚类 (Clustering) 🧩\n\n数据分组为簇。找出并清除簇外值 (孤立点)。\n举例: 客户按消费习惯分群，找出“异常客户”。\n\n回归 (Regression) 📈\n\n发现变量关系，寻找映射，平滑数据。预测数值，包括线性回归和非线性回归。\n举例: 用面积、位置预测房价。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---噪声分箱",
    "href": "qmd/chapter3.html#数据清洗---噪声分箱",
    "title": "信息技术基础",
    "section": "数据清洗 - 噪声：分箱 🗑️",
    "text": "数据清洗 - 噪声：分箱 🗑️\n分箱 (Binning)：\n\n方法：\n\n数据按属性值划分区间 (箱子)。\n用代表值 (均值、中位数、边界值等) 替代箱内值。\n\n类型：\n\n等宽：宽度相同。\n等频：数据量相同。\n自定义：据需求定边界。\n\n优点：\n\n简单。\n平滑，降噪。\n\n缺点：\n\n需确定数量和宽度。\n可能损失细节。\n\n适用：\n\n数据量大。\n噪声为小幅波动。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---噪声聚类",
    "href": "qmd/chapter3.html#数据清洗---噪声聚类",
    "title": "信息技术基础",
    "section": "数据清洗 - 噪声：聚类 🧩",
    "text": "数据清洗 - 噪声：聚类 🧩\n聚类 (Clustering)：\n\n方法：\n\n数据划分簇，簇内相似度高，簇间低。\n远离中心点视为噪声或离群点。\n\n算法：\n\nK-Means\nDBSCAN\n层次聚类\n\n优点：\n\n自动识别离群点。\n\n缺点：\n\n需选算法和参数。\n计算量可能大。\n\n适用：\n\n明显类别结构。\n噪声为离群点。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---噪声回归",
    "href": "qmd/chapter3.html#数据清洗---噪声回归",
    "title": "信息技术基础",
    "section": "数据清洗 - 噪声：回归 📈",
    "text": "数据清洗 - 噪声：回归 📈\n回归 (Regression)：\n\n方法：\n\n建立模型，用其他变量预测目标变量。\n用预测值代替原始值，平滑数据。\n\n模型：\n\n线性回归\n多项式回归\n支持向量回归\n决策树回归\n\n优点：\n\n利用关系，平滑预测。\n\n缺点：\n\n需选模型。\n可能过拟合或欠拟合。\n\n适用：\n\n明显趋势或模式。\n噪声为随机误差。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---噪声对比",
    "href": "qmd/chapter3.html#数据清洗---噪声对比",
    "title": "信息技术基础",
    "section": "数据清洗 - 噪声：对比 📝",
    "text": "数据清洗 - 噪声：对比 📝\n\n\n\n\n\n\n\n\n\n方法\n优点\n缺点\n适用场景\n\n\n\n\n分箱\n简单，平滑，降噪\n需定数量宽度，可能损失细节\n数据量大，噪声小幅波动\n\n\n聚类\n自动识别离群点\n需选算法参数，计算量可能大\n明显类别结构，噪声为离群点\n\n\n回归\n利用关系，平滑预测\n需选模型，可能过拟合或欠拟合\n明显趋势模式，噪声为随机误差"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---不一致数据",
    "href": "qmd/chapter3.html#数据清洗---不一致数据",
    "title": "信息技术基础",
    "section": "数据清洗 - 不一致数据 🔄",
    "text": "数据清洗 - 不一致数据 🔄\n不一致数据，据情况处理，可能需人工干预或工具。像整理房间🧹，放东西到正确位置。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---不一致数据处理",
    "href": "qmd/chapter3.html#数据清洗---不一致数据处理",
    "title": "信息技术基础",
    "section": "数据清洗 - 不一致数据：处理",
    "text": "数据清洗 - 不一致数据：处理\n\n据实际情况定方案。\n人工修复，知识工程工具修改。\n\n举例: “性别”列有“男/女”和“M/F”，统一。\n\n多源集成，编码差异，需转化。\n\n举例: 两库“日期”格式不同，统一。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---不一致数据方法-续",
    "href": "qmd/chapter3.html#数据清洗---不一致数据方法-续",
    "title": "信息技术基础",
    "section": "数据清洗 - 不一致数据：方法 (续)",
    "text": "数据清洗 - 不一致数据：方法 (续)\n处理方法：\n\n标准化：\n\n统一格式、编码、单位。\n\n举例：日期统一为“YYYY-MM-DD”。\n\n\n转换：\n\n转换为统一表示。\n\n举例：“男/女”和“M/F”转“1/0”。\n\n\n合并：\n\n多源数据合并为统一集。\n\n举例：不同部门客户数据合并。\n\n\n人工校验：\n\n无法自动处理，需人工检查修正。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---异常数据",
    "href": "qmd/chapter3.html#数据清洗---异常数据",
    "title": "信息技术基础",
    "section": "数据清洗 - 异常数据 💥🩹",
    "text": "数据清洗 - 异常数据 💥🩹\n异常数据，判断是否可还原。不可还原则过滤；可还原尝试修复。像修电器🔌，有些可修，有些不可。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---异常数据类型",
    "href": "qmd/chapter3.html#数据清洗---异常数据类型",
    "title": "信息技术基础",
    "section": "数据清洗 - 异常数据：类型",
    "text": "数据清洗 - 异常数据：类型\n\n不可还原 (Irrecoverable) 💥\n\n难修正，如乱码，字符截断，异常值。无规律则过滤。像碎花瓶💐。\n\n可还原 (Recoverable) 🩹\n\n参杂无用字符，用取子串、trim()去空格。\n\n举例: ” Hello World “去空格。\n\n字符截断，可推导则还原。\n\n举例: 用户名“Alexan”，推断“Alexander”。\n\n数值单位差异，转化处理。\n\n举例: 重量“克”和“千克”统一。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---异常不可还原",
    "href": "qmd/chapter3.html#数据清洗---异常不可还原",
    "title": "信息技术基础",
    "section": "数据清洗 - 异常：不可还原",
    "text": "数据清洗 - 异常：不可还原\n不可还原异常：\n\n特点：无法恢复到原始正确状态。\n举例：\n\n乱码：编码错误致无法识别。\n严重丢失：关键信息缺失。\n完全错误：与真实不符。\n\n处理：\n\n过滤：直接删除。"
  },
  {
    "objectID": "qmd/chapter3.html#数据清洗---异常可还原",
    "href": "qmd/chapter3.html#数据清洗---异常可还原",
    "title": "信息技术基础",
    "section": "数据清洗 - 异常：可还原",
    "text": "数据清洗 - 异常：可还原\n可还原异常：\n\n特点：可恢复到原始正确状态。\n举例：\n\n字符串：\n\n多余空格、特殊字符：trim()、正则。\n截断：可推断则恢复。\n\n数值：\n\n单位错误：转换。\n数量级错误：乘除常数。\n\n\n处理：\n\n据情况选方法修复。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程",
    "href": "qmd/chapter3.html#特征工程",
    "title": "信息技术基础",
    "section": "特征工程 ⚙️",
    "text": "特征工程 ⚙️\n特征工程是预处理最后和重要环节。提取有用特征，提高性能。像厨师👨‍🍳切食材🔪，方便烹饪。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程作用",
    "href": "qmd/chapter3.html#特征工程作用",
    "title": "信息技术基础",
    "section": "特征工程：作用",
    "text": "特征工程：作用\n\n原始数据维数高，清洗后成原始特征，但不都有用，有些需处理，有些干扰。像木材🪵，有些直接用，有些加工，有些不能用。\n利用知识处理数据创建特征，供后续分析。目的：尽量少特征描述数据，保持特性。像木材加工家具🪑🛏️🛋️。\n\n特征选择 (Feature Selection)\n特征构建 (Feature Construction)\n特征提取 (Feature Extraction)"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征选择",
    "href": "qmd/chapter3.html#特征工程---特征选择",
    "title": "信息技术基础",
    "section": "特征工程 - 特征选择 🎯",
    "text": "特征工程 - 特征选择 🎯\n特征选择是从原始特征中选对分析最有用的。像选演员🎭，选最适合角色的。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征选择原则",
    "href": "qmd/chapter3.html#特征工程---特征选择原则",
    "title": "信息技术基础",
    "section": "特征工程 - 特征选择：原则",
    "text": "特征工程 - 特征选择：原则\n\n原则 🎯\n\n是否发散：不发散，方差近0，无区分作用。像身高🧍都一样。\n是否相关：取值能改变结果。相关性高优先。像预测房价🏠，面积、位置比颜色重要。\n信息是否冗余：本质相同，相关性高。像“年龄”和“出生年”。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征选择重要性",
    "href": "qmd/chapter3.html#特征工程---特征选择重要性",
    "title": "信息技术基础",
    "section": "特征工程 - 特征选择：重要性",
    "text": "特征工程 - 特征选择：重要性\n重要性：\n\n提高性能：选相关特征提准确性和泛化。\n降低成本：减少数量降训练预测时间和资源。\n增强可解释性：更少特征使模型易理解。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征选择方法",
    "href": "qmd/chapter3.html#特征工程---特征选择方法",
    "title": "信息技术基础",
    "section": "特征工程 - 特征选择：方法 🧰",
    "text": "特征工程 - 特征选择：方法 🧰\n方法多，据情况选。像选交通工具🚗✈️🚄，据距离、时间、预算。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征选择方法-续",
    "href": "qmd/chapter3.html#特征工程---特征选择方法-续",
    "title": "信息技术基础",
    "section": "特征工程 - 特征选择：方法 (续)",
    "text": "特征工程 - 特征选择：方法 (续)\n\n方法 🧰\n\nFilter (过滤)：按发散性或相关性评分，设阈值或个数，选择。\n\n举例: 算方差，选大于阈值。\n\nWrapper (包装)：据目标函数，每次选或排除若干。\n\n举例: 递归特征消除 (RFE)，逐步减，直到最佳。\n\nEmbedded (集成)：训练算法模型，得权值，据系数选。类似Filter，但通过训练定优劣。\n\n举例: LASSO回归，L1正则化使系数变0，选择。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---选择过滤法",
    "href": "qmd/chapter3.html#特征工程---选择过滤法",
    "title": "信息技术基础",
    "section": "特征工程 - 选择：过滤法",
    "text": "特征工程 - 选择：过滤法\n过滤法 (Filter)：\n\n原理：据特性 (方差、相关系数、互信息等) 评估重要性，排序或筛选。\n指标：\n\n方差：离散程度。\n相关系数：线性相关。\n卡方检验：类别型特征与目标相关性。\n互信息：非线性相关。\n\n优点：\n\n计算简单，快。\n不需训练。\n\n缺点：\n\n忽略关系。\n可能选冗余。\n\n适用：\n\n维度高，需快速筛选。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---选择包装法",
    "href": "qmd/chapter3.html#特征工程---选择包装法",
    "title": "信息技术基础",
    "section": "特征工程 - 选择：包装法",
    "text": "特征工程 - 选择：包装法\n包装法 (Wrapper)：\n\n原理：看作搜索，通过组合训练模型，评估性能，选最佳子集。\n方法：\n\n递归特征消除 (RFE)：逐步减，直到最佳。\n前向选择：逐步加，直到不提升。\n后向消除：逐步减，直到不下降。\n\n优点：\n\n针对目标函数优化，效果好。\n\n缺点：\n\n计算量大。\n易过拟合。\n\n适用：\n\n维度不高。\n性能要求高。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---选择集成法",
    "href": "qmd/chapter3.html#特征工程---选择集成法",
    "title": "信息技术基础",
    "section": "特征工程 - 选择：集成法",
    "text": "特征工程 - 选择：集成法\n集成法 (Embedded)：\n\n原理：嵌入模型训练，通过学习自动选择。\n方法：\n\nLASSO回归：L1正则化使系数变0，选择。\n决策树：据信息增益或基尼系数选分裂。\n随机森林：评估重要性，排序。\n\n优点：\n\n结合过滤和包装，考虑关系，利用模型，效果好。\n\n缺点：\n\n需训练，计算量可能大。\n\n适用：\n\n维度高。\n性能要求高。"
  },
  {
    "objectID": "qmd/chapter3.html#特征选择对比",
    "href": "qmd/chapter3.html#特征选择对比",
    "title": "信息技术基础",
    "section": "特征选择：对比 📝",
    "text": "特征选择：对比 📝\n\n\n\n\n\n\n\n\n\n方法\n优点\n缺点\n适用场景\n\n\n\n\n过滤法\n计算简单，快，不需训练\n忽略关系，可能选冗余\n维度高，需快速筛选\n\n\n包装法\n针对目标函数优化，效果好\n计算量大，易过拟合\n维度不高，性能要求高\n\n\n集成法\n结合过滤和包装，考虑关系，利用模型，效果好\n需训练，计算量可能大\n维度高，性能要求高"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征构建",
    "href": "qmd/chapter3.html#特征工程---特征构建",
    "title": "信息技术基础",
    "section": "特征工程 - 特征构建 🧱",
    "text": "特征工程 - 特征构建 🧱\n特征构建是据知识，人工构造新特征。需理解数据和业务。像厨师👨‍🍳据食材特点，创菜肴🍽️。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征构建作用",
    "href": "qmd/chapter3.html#特征工程---特征构建作用",
    "title": "信息技术基础",
    "section": "特征工程 - 特征构建：作用",
    "text": "特征工程 - 特征构建：作用\n\n从原始特征中人工构建。像积木🧱搭城堡🏰，用已有积木创新形状。\n需洞察力和分析力，从数据中找物理意义特征。\n表格数据，可用混合或组合属性创建，或分解切分原有特征。\n\n举例：\n\n混合：“年”和“月”合并“年月”。\n组合：“身高”和“体重”组合“BMI”。\n分解：“日期”分解“年”、“月”、“日”、“星期”。\n切分：“年龄”切分“儿童”、“青年”、“中年”、“老年”。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---构建方法",
    "href": "qmd/chapter3.html#特征工程---构建方法",
    "title": "信息技术基础",
    "section": "特征工程 - 构建：方法",
    "text": "特征工程 - 构建：方法\n方法：\n\n组合：多特征组合。\n\n举例：BMI = 体重(kg) / 身高(m)^2\n\n多项式：乘方、开方、相乘等。\n\n举例：x1, x2 -&gt; x1^2, x2^2, x1*x2\n\n比率：相关特征相除。\n\n举例：每公里油耗 = 耗油 / 里程\n\n类别编码：类别型转数值型。\n\n举例：One-Hot, Label Encoding\n\n时间处理：提取年、月、日等。\n文本处理：提取关键词、主题等。\n\n举例：TF-IDF, Word Embeddings\n\n领域知识：据知识设计。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征提取",
    "href": "qmd/chapter3.html#特征工程---特征提取",
    "title": "信息技术基础",
    "section": "特征工程 - 特征提取 ✨",
    "text": "特征工程 - 特征提取 ✨\n特征提取是算法自动生成新特征。用于降维和提取潜在结构。像照片📸转素描✏️，提取主要特征。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---特征提取方法",
    "href": "qmd/chapter3.html#特征工程---特征提取方法",
    "title": "信息技术基础",
    "section": "特征工程 - 特征提取：方法",
    "text": "特征工程 - 特征提取：方法\n\n自动构建新特征，将原始特征转为更具物理意义、统计意义或核的特征。方法包括PCA、ICA和LDA。\n\nPCA：坐标轴转换，寻最优子空间，降维、去相关。\n\n举例：1000维人脸图像降100维，保留特征。\n\nICA：PCA提不相关，ICA获独立属性。\n\n举例：混合音频分离独立声源 (人声、乐器)。\n\nLDA：投影到低维，使同类点接近，异类点远离。\n\n举例：文档映射低维，同主题近，不同主题远。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---提取pca",
    "href": "qmd/chapter3.html#特征工程---提取pca",
    "title": "信息技术基础",
    "section": "特征工程 - 提取：PCA",
    "text": "特征工程 - 提取：PCA\nPCA：\n\n原理：线性变换转为不相关特征 (主成分)，按方差排序。\n步骤：\n\n算协方差矩阵。\n算特征值和向量。\n选最大k个特征值对应向量，构成变换矩阵。\n原始数据乘变换矩阵，得降维数据。\n\n优点：\n\n降维，去冗余。\n发现主要成分，提潜在结构。\n\n缺点：\n\n解释性差。\n可能损失信息。\n\n适用：\n\n高维降维。\n可视化。\n去噪。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---提取ica",
    "href": "qmd/chapter3.html#特征工程---提取ica",
    "title": "信息技术基础",
    "section": "特征工程 - 提取：ICA",
    "text": "特征工程 - 提取：ICA\nICA：\n\n原理：假设数据由独立、非高斯成分混合，ICA找独立成分。\n与PCA区别：\n\nPCA找不相关 (主成分)，ICA找独立。\nPCA适用高斯分布，ICA适用非高斯。\n\n优点：\n\n分离独立信号源。\n\n缺点：\n\n计算复杂。\n对分布有假设。\n\n适用：\n\n信号分离 (鸡尾酒会问题)。\n图像处理。\n脑电图分析。"
  },
  {
    "objectID": "qmd/chapter3.html#特征工程---提取lda",
    "href": "qmd/chapter3.html#特征工程---提取lda",
    "title": "信息技术基础",
    "section": "特征工程 - 提取：LDA",
    "text": "特征工程 - 提取：LDA\nLDA：\n\n原理：投影到低维，同类点近，异类点远。\n与PCA区别：\n\nPCA无监督，LDA有监督。\nPCA目标最大化方差，LDA目标最大化可分性。\n\n优点：\n\n提分类性能。\n\n缺点：\n\n对分布有假设 (通常正态)。\n可能过拟合。\n\n适用：\n\n分类。\n降维。"
  },
  {
    "objectID": "qmd/chapter3.html#总结",
    "href": "qmd/chapter3.html#总结",
    "title": "信息技术基础",
    "section": "总结 📝",
    "text": "总结 📝\n数据预处理流程：\n\n了解数据：类型、特征、问题。\n质量评估：完整性、一致性、准确性、及时性。\n数据清洗：处理缺失值、噪声、不一致、异常。\n特征工程：提取有用特征，包括选择、构建、提取。"
  },
  {
    "objectID": "qmd/chapter3.html#总结-续",
    "href": "qmd/chapter3.html#总结-续",
    "title": "信息技术基础",
    "section": "总结 (续)",
    "text": "总结 (续)\n\n学习了预处理概念和方法。\n预处理是分析重要环节，提质量，改善性能。\n包括质量评估、清洗和特征工程。"
  },
  {
    "objectID": "qmd/chapter3.html#思考与讨论",
    "href": "qmd/chapter3.html#思考与讨论",
    "title": "信息技术基础",
    "section": "思考与讨论 🤔",
    "text": "思考与讨论 🤔\n\n你遇到过哪些质量问题？如何处理？\n除本章方法，还知道哪些预处理方法？\n预处理对分析和建模多重要？为什么？\n如何评价预处理方案好坏？"
  },
  {
    "objectID": "qmd/chapter5.html",
    "href": "qmd/chapter5.html",
    "title": "信息技术基础 📊",
    "section": "",
    "text": "Pandas介绍 🐼\n基础数据结构 🧱\nIndex对象访问 🔍\n数学统计计算 🧮\n聚合分组运算 ➕➖\n\n\n\n\n\n这里我对目录进行了一些改进：\n\n1.  使用 `layout-ncol=2` 将目录分为两列，使页面更紧凑。\n2.  简化了目录标题，使其更简洁明了。\n\n接下来是 Pandas 介绍部分：\n\n```qmd\n## Pandas介绍 🐼\n\n::: {.callout-note}\nPandas 是 Python 的一个**开源**工具包，为 Python 提供了**高性能**、**简单易用**的数据结构和数据分析工具。就像一个超级工具箱🧰，让数据处理变得轻松又高效！\n:::\n\n- Pandas 得名于 **pan**el **da**ta **s**ystem，即面板数据系统。\n- Pandas 基于 NumPy 构建，但提供了更高级、更方便的数据操作接口。\n- Pandas 擅长处理**结构化数据**，如表格、数据库、CSV 文件等。\n\n## Pandas介绍 🐼\n\n### Pandas可以完成什么事情？ {.smaller}\n\n- **索引对象**：包括简单的索引和多层次的索引，就像给数据贴上标签🏷️，方便查找和管理。\n    -  **索引 (Index)**：Pandas 中用于标记和定位数据的重要组成部分，类似于数据的“地址簿”。\n    -  **简单索引**：最基本的索引形式，通常是一个整数或字符串序列。\n    -  **多层次索引 (MultiIndex)**：一种更复杂的索引形式，允许在一个轴上有多个层级的索引，类似于“多级目录”，可以更精细地组织和访问数据。\n- **引擎集成组合**：用于汇总和转换数据集合，可以将多个数据源整合在一起，进行统一处理。\n    -   **汇总 (Aggregation)**：将多个数据值合并为一个值，例如求和、平均值、最大值等。\n    -   **转换 (Transformation)**：对数据进行某种形式的修改，例如标准化、填充缺失值等。\n- **日期范围生成器**：可以生成日期范围 📅，并支持自定义日期偏移（实现自定义频率），时间序列分析必备！\n    -   **日期范围 (Date Range)**：表示一段连续的日期，例如 \"2023-01-01\" 到 \"2023-01-10\"。\n    -   **日期偏移 (Date Offset)**：表示一个时间间隔，例如 \"2天\"、\"1个月\"、\"3小时\" 等。\n\n::: {#c2223a5d .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\n# 生成日期范围\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10')\nprint(date_range)\n\n# 自定义日期偏移\ncustom_dates = pd.date_range(start='2023-01-01', periods=5, freq='2D') # 每两天\nprint(custom_dates)\n:::"
  },
  {
    "objectID": "qmd/chapter5.html#目录",
    "href": "qmd/chapter5.html#目录",
    "title": "信息技术基础 📊",
    "section": "",
    "text": "Pandas介绍 🐼\n基础数据结构 🧱\nIndex对象访问 🔍\n数学统计计算 🧮\n聚合分组运算 ➕➖\n\n\n\n\n\n这里我对目录进行了一些改进：\n\n1.  使用 `layout-ncol=2` 将目录分为两列，使页面更紧凑。\n2.  简化了目录标题，使其更简洁明了。\n\n接下来是 Pandas 介绍部分：\n\n```qmd\n## Pandas介绍 🐼\n\n::: {.callout-note}\nPandas 是 Python 的一个**开源**工具包，为 Python 提供了**高性能**、**简单易用**的数据结构和数据分析工具。就像一个超级工具箱🧰，让数据处理变得轻松又高效！\n:::\n\n- Pandas 得名于 **pan**el **da**ta **s**ystem，即面板数据系统。\n- Pandas 基于 NumPy 构建，但提供了更高级、更方便的数据操作接口。\n- Pandas 擅长处理**结构化数据**，如表格、数据库、CSV 文件等。\n\n## Pandas介绍 🐼\n\n### Pandas可以完成什么事情？ {.smaller}\n\n- **索引对象**：包括简单的索引和多层次的索引，就像给数据贴上标签🏷️，方便查找和管理。\n    -  **索引 (Index)**：Pandas 中用于标记和定位数据的重要组成部分，类似于数据的“地址簿”。\n    -  **简单索引**：最基本的索引形式，通常是一个整数或字符串序列。\n    -  **多层次索引 (MultiIndex)**：一种更复杂的索引形式，允许在一个轴上有多个层级的索引，类似于“多级目录”，可以更精细地组织和访问数据。\n- **引擎集成组合**：用于汇总和转换数据集合，可以将多个数据源整合在一起，进行统一处理。\n    -   **汇总 (Aggregation)**：将多个数据值合并为一个值，例如求和、平均值、最大值等。\n    -   **转换 (Transformation)**：对数据进行某种形式的修改，例如标准化、填充缺失值等。\n- **日期范围生成器**：可以生成日期范围 📅，并支持自定义日期偏移（实现自定义频率），时间序列分析必备！\n    -   **日期范围 (Date Range)**：表示一段连续的日期，例如 \"2023-01-01\" 到 \"2023-01-10\"。\n    -   **日期偏移 (Date Offset)**：表示一个时间间隔，例如 \"2天\"、\"1个月\"、\"3小时\" 等。\n\n::: {#c2223a5d .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\n# 生成日期范围\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10')\nprint(date_range)\n\n# 自定义日期偏移\ncustom_dates = pd.date_range(start='2023-01-01', periods=5, freq='2D') # 每两天\nprint(custom_dates)\n:::"
  },
  {
    "objectID": "qmd/chapter5.html#pandas介绍-续",
    "href": "qmd/chapter5.html#pandas介绍-续",
    "title": "信息技术基础 📊",
    "section": "Pandas介绍 🐼 (续)",
    "text": "Pandas介绍 🐼 (续)\n\n输入/输出工具：从各种格式的文件（如 CSV、Excel）中加载表格数据，以及从 PyTables/HDF5 格式中保存和加载 Pandas 对象。数据导入导出，畅通无阻！\n\nCSV (Comma Separated Values)：逗号分隔值，一种常见的文本文件格式，用于存储表格数据。可以理解为用逗号,分隔字段（列），用换行符分隔每条记录（行）的纯文本。\n\n示例:\n\nName,Age,City\nAlice,25,New York\nBob,30,London\nCharlie,22,Paris\nDelimited Files: 使用特定分隔符（如制表符\\t、空格等）分隔数据的文件。\n\n示例 (使用制表符分隔):\n\nName    Age    City\nAlice    25    New York\nBob    30    London\nExcel 2003: 指的是 Microsoft Excel 2003 版本的文件格式（.xls）。现在更常用的是.xlsx格式。\n\nExcel 文件是二进制文件，包含多个工作表（Sheet），每个工作表包含行和列组成的表格数据。\n\nPyTables/HDF5:\n\nPyTables 是一个用于管理分层数据集的 Python 包，设计用于高效处理大量数据。\nHDF5 (Hierarchical Data Format version 5) 是一种用于存储和管理数据的文件格式。特点是支持存储非常大的、异构的、复杂的数据对象。\n\n分层数据：数据以类似文件系统的目录结构组织，可以包含多个组（Group）和数据集（Dataset）。\n高效：HDF5 使用了各种优化技术，例如压缩、分块等，可以快速读写大量数据。\n异构数据：HDF5 可以存储不同类型的数据，例如整数、浮点数、字符串、数组等。\n\n\n\n\n\n# 从 CSV 文件读取数据\ndf = pd.read_csv('data.csv')\n\n# 将数据保存为 Excel 文件\ndf.to_excel('data.xlsx', index=False)"
  },
  {
    "objectID": "qmd/chapter5.html#pandas介绍-续-1",
    "href": "qmd/chapter5.html#pandas介绍-续-1",
    "title": "信息技术基础 📊",
    "section": "Pandas介绍 🐼 (续)",
    "text": "Pandas介绍 🐼 (续)\n\n标准数据结构：支持存储大量缺失或一致的数据，就像一个大仓库 🏭，可以容纳各种类型的数据。\n\n缺失数据 (Missing Data)：数据集中某些值不存在或未知的情况，通常用 NaN (Not a Number) 表示。\n一致的数据 (Homogeneous Data)：数据集中所有值都是相同类型的情况。\nPandas 可以同时处理缺失数据和一致的数据，并提供了灵活的工具来处理这些情况。\n\n移动窗口统计：如滚动平均值、滚动标准偏差等，非常适合处理时间序列数据，就像一个滑动窗口 🪟，可以观察数据的变化趋势。\n\n移动窗口 (Moving Window)：在数据序列上按一定大小滑动的窗口，用于计算窗口内数据的统计量。\n滚动平均值 (Rolling Mean)：移动窗口内数据的平均值。\n滚动标准偏差 (Rolling Standard Deviation)：移动窗口内数据的标准偏差。\n时间序列数据 (Time Series Data)：按时间顺序排列的数据，例如股票价格、气温变化等。"
  },
  {
    "objectID": "qmd/chapter5.html#基础数据结构series",
    "href": "qmd/chapter5.html#基础数据结构series",
    "title": "信息技术基础 📊",
    "section": "基础数据结构——Series 🧱",
    "text": "基础数据结构——Series 🧱\n\n\n\n\n\n\nTip\n\n\n\nSeries 是 Pandas 中一种重要的数据结构，类似于一维数组与字典的结合。可以看作是带标签的数组，每个元素都有一个对应的标签（索引）。\n\n\n\n定长有序字典：Series 可以理解为一个定长、有序的“字典”结构，键值对一一对应。\n\n定长 (Fixed-length)：Series 一旦创建，其长度（元素个数）通常是固定的。\n有序 (Ordered)：Series 中的元素按照一定的顺序排列。\n字典 (Dictionary)：Python 中的一种数据结构，由键值对 (key-value pairs) 组成。\n\n有标签的一维数组：Series 是一个有标签的一维数组，标签在 Pandas 中对应的数据类型是 index。\n\n一维数组 (1D Array)：只有一个维度的数据集合，类似于一个列表。\n标签 (Label)：Series 中每个元素对应的名称或标识符，用于访问和操作数据。\nIndex：Pandas 中用于表示 Series 或 DataFrame 的标签的数据类型。\n\n\n\nSeries的创建\n\n通过 list 创建：\n\n\nimport pandas as pd\n\ndata = [1, 2, 3, 4, 5]  # 创建一个列表\nseries_from_list = pd.Series(data)  # 用列表创建 Series\nprint(series_from_list) # 打印 Series, 包含索引和值\n\n\n\n\n\n\n\nNote\n\n\n\n创建Series时可以指定index，如果没指定index，则自动使用整数索引，从0开始。\n\n\n\n通过 NumPy 的 ndarray 创建：\n\n\nimport pandas as pd\nimport numpy as np\n\ndata = np.array([1, 2, 3, 4, 5]) # 创建一个 NumPy 数组\nseries_from_ndarray = pd.Series(data)  # 用 NumPy 数组创建 Series\nprint(series_from_ndarray)\n\n\n通过 dict 创建：\n\n\nimport pandas as pd\n\ndata = {'a': 1, 'b': 2, 'c': 3} # 创建一个字典\nseries_from_dict = pd.Series(data)  # 用字典创建 Series\nprint(series_from_dict)  # 字典的键会成为 Series 的索引\n\n\n通过标量创建：\n\n\nimport pandas as pd\n\nseries_from_scalar = pd.Series(5, index=['a', 'b', 'c'])  # 创建一个所有值都为 5 的 Series\nprint(series_from_scalar)"
  },
  {
    "objectID": "qmd/chapter5.html#series的访问和操作",
    "href": "qmd/chapter5.html#series的访问和操作",
    "title": "信息技术基础 📊",
    "section": "Series的访问和操作",
    "text": "Series的访问和操作\n\nSeries的访问\n\n使用 iloc 和 loc 函数：\n\niloc：通过位置访问，就像数组一样，使用整数索引。\n\n位置 (Position)：元素在 Series 中的顺序编号，从 0 开始。\n\nloc：通过标签访问，就像字典一样，使用索引值。\n\n\n\nimport pandas as pd\n\ns = pd.Series([10, 20, 30], index=['a', 'b', 'c'])\n\n# 通过位置访问\nprint(\"通过位置访问(s.iloc[0]):\", s.iloc[0])  # 输出: 10\n\n# 通过标签访问\nprint(\"通过标签访问(s.loc['b']):\", s.loc['b']) # 输出: 20\n\n\n类似数组和属性的访问：\n\n\n# 类似数组\nprint(\"类似数组访问(s[0]):\", s[0])  # 输出: 10\n\n# 类似属性(如果索引是有效的Python变量名)\nprint(\"类似属性访问(s.a):\", s.a) # 输出: 10\n\n\n\nSeries的操作\n\n向量化操作：像数组一样对 Series 进行操作，无需循环，Pandas 会自动处理。\n\n向量化 (Vectorized)：对整个 Series 或数组进行操作，而不是逐个元素进行操作。\nPandas 的向量化操作通常比 Python 循环快得多。\n\nNumPy兼容性：NumPy 中对 ndarray 的操作也适用于 Series，例如加减乘除、求和、平均等。\n数据对齐：由于索引的存在，Series 在操作时会自动对齐数据，不同索引的数据会进行匹配，找不到匹配的会用 NaN 填充。\n\n数据对齐 (Data Alignment)：Pandas 在进行运算时，会根据索引自动匹配 Series 或 DataFrame 中的数据。\n\n\n\nimport pandas as pd\n\ns1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\ns2 = pd.Series([4, 5, 6], index=['b', 'c', 'd'])\n\nprint(\"s1 + s2:\\n\", s1 + s2)  # 索引对齐，'a' 和 'd' 对应的值为 NaN"
  },
  {
    "objectID": "qmd/chapter5.html#基础数据结构dataframe",
    "href": "qmd/chapter5.html#基础数据结构dataframe",
    "title": "信息技术基础 📊",
    "section": "基础数据结构——DataFrame 🧱",
    "text": "基础数据结构——DataFrame 🧱\n\n\n\n\n\n\nNote\n\n\n\nDataFrame 是 Pandas 中最常用的数据结构，是有标签的二维数组，类似于表格 📇、SQL中的 table，或者是一个 Series 对象的 dict。 可以看作是多个 Series 共享同一个索引。\n\n\n\n行索引 (index) 和 列索引 (columns)：DataFrame 同时具有行索引和列索引，就像一个表格有行标题和列标题。\n\n行索引 (Row Index)：用于标识 DataFrame 中每一行的标签。\n列索引 (Column Index)：用于标识 DataFrame 中每一列的标签。\n\n\n\nDataFrame的创建\n\n输入：\n\n一维 ndarray、list、dict 或 Series 的 dict。\n二维 ndarray。\n一个 Series。\n其他 DataFrame。\n\n\n\nimport pandas as pd\n\n# 用字典创建 DataFrame\ndata = {'col1': [1, 2], 'col2': [3, 4]}\ndf1 = pd.DataFrame(data)\nprint(\"用字典创建 DataFrame:\\n\", df1)\n\n# 用二维数组创建 DataFrame\ndata = [[1, 2], [3, 4]]\ndf2 = pd.DataFrame(data, columns=['col1', 'col2'])\nprint(\"用二维数组创建 DataFrame:\\n\", df2)\n\n\n索引：\n\n创建 DataFrame 时，可以通过 index 和 columns 参数指定行索引和列索引。\n如果没有明确指定，会自动生成从 0 开始的整数索引。\n\nSeries的dict创建DataFrame：\n\n若指定 index，会丢弃所有未和指定 index 匹配的数据。\n\n\n\nimport pandas as pd\n\ndata = {'col1': pd.Series([1, 2, 3], index=['a', 'b', 'c']),\n        'col2': pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}\ndf3 = pd.DataFrame(data)  # 字典的键会成为 DataFrame 的列名\nprint(\"用Series的dict创建DataFrame:\\n\", df3) # index自动取并集\n\ndf4 = pd.DataFrame(data, index=['a','b'])\nprint(\"指定index创建DataFrame:\\n\", df4) # index参数为['a','b']，df只有'a','b'两行，抛弃了'c'和'd'行的数据\n\n\n\n\n\n\n\nNote\n\n\n\n用Series的字典创建DataFrame时，index如果不指定，会自动取并集。"
  },
  {
    "objectID": "qmd/chapter5.html#dataframe的访问和操作",
    "href": "qmd/chapter5.html#dataframe的访问和操作",
    "title": "信息技术基础 📊",
    "section": "DataFrame的访问和操作",
    "text": "DataFrame的访问和操作\n\nDataFrame的访问\n\n多种访问方式:\n\n通过列索引访问：\n\n\n\ndf['column_label']\n\n\n通过行索引访问：\n\n\ndf.loc['row_label']\n\n\nloc: 通过行标签访问\n\n\nprint(df.loc['row_label'])\n\n\niloc：通过行位置访问。\n\n\nprint(df.iloc[row_position])\n\n\nimport pandas as pd\n\ndata = {'col1': [1, 2, 3], 'col2': [4, 5, 6]}\ndf = pd.DataFrame(data, index=['A', 'B', 'C'])\n\n# 通过列索引访问\nprint(\"通过列索引访问:\\n\", df['col1'])  # 选择 'col1' 列\n\n# 通过 loc 访问\nprint(\"通过 loc 访问:\\n\", df.loc['A'])  # 选择 'A' 行\n\n# 通过 iloc 访问\nprint(\"通过 iloc 访问:\\n\", df.iloc[0])  # 选择第一行\n\n\n\nDataFrame的操作\n\n算术操作：支持加、减、乘、除、转置等，就像操作矩阵一样。\nNumPy兼容性：NumPy 中对矩阵的操作也适用于 DataFrame。\n数据对齐：DataFrame 在操作时会自动按行和列索引对齐数据，不同索引的数据会进行匹配，找不到匹配的会用 NaN 填充。\n增删改查：可以对 DataFrame 进行增、删、改、查操作。\n\n\nimport pandas as pd\n\ndata = {'col1': [1, 2, 3], 'col2': [4, 5, 6]}\ndf = pd.DataFrame(data)\n\n# 添加一列\ndf['col3'] = [7, 8, 9]\nprint(\"添加一列后:\\n\", df)\n\n# 删除一列\ndf = df.drop('col2', axis=1)\nprint(\"删除一列后:\\n\", df)\n\n# 修改数据\ndf.loc[0, 'col1'] = 10\nprint(\"修改数据后:\\n\", df)\n\n# 查询数据\nprint(\"查询数据(col1 &gt; 1):\\n\", df[df['col1'] &gt; 1])"
  },
  {
    "objectID": "qmd/chapter5.html#基于pandas的index对象的访问操作",
    "href": "qmd/chapter5.html#基于pandas的index对象的访问操作",
    "title": "信息技术基础 📊",
    "section": "基于Pandas的Index对象的访问操作 🔍",
    "text": "基于Pandas的Index对象的访问操作 🔍\n\nPandas的Index对象\n\nSeries 中的 index 属性。\nDataFrame 中的 index 属性和 columns 属性。\n\n\n\n\n\n\n\nNote\n\n\n\nSeries 和 DataFrame 的索引都是 Index 对象，用于标识和访问数据。\n\n\n\n\nIndex对象的特征\n\n不可修改 (Immutable)：Index 对象一旦创建，就不能修改，保证了数据的安全性。\n\n不可修改性：这是为了防止意外修改索引导致数据混乱或错误。\n\n有序：Index 对象中的元素是有序的，可以按照顺序访问。\n可切片：可以像列表或数组一样对 Index 对象进行切片操作，方便获取部分数据。\n\n切片 (Slicing)：从序列中提取一部分的操作，例如 index[1:3]。\n\n\n\n\nIndex对象的类型\n\nIndex：最泛化的 Index 类型，将轴标签表示为一个由 Python 对象组成的 NumPy 数组。\nInt64Index：针对整数的 Index 类型，用于整数索引。\nMultiIndex：针对多层索引的 Index 类型，用于创建复杂的层次化索引。\n\n层次化索引 (Hierarchical Indexing)：在一个轴上有多个层级的索引。\n\nDatetimeIndex：存储时间戳的 Index 类型，用于时间序列数据。\n\n时间戳 (Timestamp)：表示一个特定时间点的数据，例如 “2023-10-27 10:00:00”。\n\nPeriodIndex：针对时间间隔数据的 Index 类型，用于表示一段时间。\n\n时间间隔 (Period)：表示一段持续时间的数据，例如 “2023年10月”、“2023年第3季度”。"
  },
  {
    "objectID": "qmd/chapter5.html#index对象的基本操作",
    "href": "qmd/chapter5.html#index对象的基本操作",
    "title": "信息技术基础 📊",
    "section": "Index对象的基本操作 🧮",
    "text": "Index对象的基本操作 🧮\n\n\n\n\n\n\n\n函数\n说明\n\n\n\n\ndelete\n删除索引 i 处的元素，返回新的 Index 对象（可以传入索引的数组）\n\n\ndrop\n删除传入的元素 e，返回新的 Index 对象（可以传入元素的数组）\n\n\ninsert\n将元素插入索引 i 处，返回新的 Index 对象\n\n\nappend\n连接另一个 Index 对象，返回新的 Index 对象\n\n\nunion\n与另一个 Index 对象进行并操作，返回两者的并集\n\n\ndifference\n与另一个 Index 对象进行差操作，返回两者的差集\n\n\nintersection\n与另一个 Index 对象进行交操作，返回两者的交集\n\n\nisin\n判断 Index 对象中每个元素是否在参数所给的数组类型对象中，返回一个与 Index 对象长度相同的 Bool 数组\n\n\nis_monotonic\n当每个元素都大于前一个元素时，返回 True\n\n\nis_unique\n当 Index 对象中没有重复值时，返回 True\n\n\nunique\n返回没有重复数据的 Index 对象\n\n\n\n\nimport pandas as pd\n\nindex = pd.Index(['a', 'b', 'c', 'd'])\n\n# 删除索引为 1 的元素\nnew_index = index.delete(1)\nprint(\"删除索引为 1 的元素:\", new_index)  # new_index: Index(['a', 'c', 'd'], dtype='object')\n\n# 删除元素 'c'\nnew_index = index.drop('c')\nprint(\"删除元素 'c':\", new_index)  # new_index: Index(['a', 'b', 'd'], dtype='object')\n\n# 插入元素 'e' 到索引 2\nnew_index = index.insert(2, 'e')\nprint(\"插入元素 'e' 到索引 2:\", new_index)  # new_index: Index(['a', 'b', 'e', 'c', 'd'], dtype='object')\n\n# 连接另一个 Index 对象\nother_index = pd.Index(['e', 'f'])\nnew_index = index.append(other_index)\nprint(\"连接另一个 Index 对象:\", new_index)  # new_index: Index(['a', 'b', 'c', 'd', 'e', 'f'], dtype='object')"
  },
  {
    "objectID": "qmd/chapter5.html#索引的不同访问方式",
    "href": "qmd/chapter5.html#索引的不同访问方式",
    "title": "信息技术基础 📊",
    "section": "索引的不同访问方式",
    "text": "索引的不同访问方式\n\nloc 方式\n\n关注 index 的 label，筛选条件与 label 相关。\n接收 index 的 label 作为参数输入。\n可以接收：\n\n单个 label。\nlabel 的数组。\nlabel 的分片 (slice)。\n布尔数组。\n回调函数（参数为调用 loc 函数的对象，即 Series 或 DataFrame）。\n\n\n\nimport pandas as pd\n\ndata = {'col1': [1, 2, 3], 'col2': [4, 5, 6]}\ndf = pd.DataFrame(data, index=['A', 'B', 'C'])\n\n# 单个 label\nprint(\"单个 label:\\n\", df.loc['A'])\n\n# label 数组\nprint(\"label 数组:\\n\", df.loc[['A', 'C']])\n\n# label 分片\nprint(\"label 分片:\\n\", df.loc['A':'B'])\n\n# 布尔数组\nprint(\"布尔数组:\\n\", df.loc[df['col1'] &gt; 1])\n\n# 回调函数\nprint(\"回调函数:\\n\", df.loc[lambda df: df['col2'] &gt; 4])\n\n\n\niloc 方式\n\n关注 index 的 position。\n接收 index 的 position 作为参数输入。\n可以接收：\n\n单个整数（表示 position）。\nposition 的数组。\nposition 的分片 (slice)。\n布尔数组。\n回调函数（参数为调用 iloc 函数的对象，即 Series 或 DataFrame）。\n\n\n\nimport pandas as pd\n\ndata = {'col1': [1, 2, 3], 'col2': [4, 5, 6]}\ndf = pd.DataFrame(data, index=['A', 'B', 'C'])\n\n# 单个整数\nprint(\"单个整数:\\n\", df.iloc[0])\n\n# position 数组\nprint(\"position 数组:\\n\", df.iloc[[0, 2]])\n\n# position 分片\nprint(\"position 分片:\\n\", df.iloc[0:2])\n\n# 布尔数组\nprint(\"布尔数组:\\n\", df.iloc[(df['col1'] &gt; 1).values])\n\n# 回调函数\nprint(\"回调函数:\\n\", df.iloc[lambda df: [0, 2]])  # 注意：这里的回调函数返回的是位置列表\n\n\n\n类似dict方式的访问\n\n可以将 Series 和 DataFrame 看作 dict。\nDataFrame 相当于每个元素是 Series 的 dict。\n可以用类似 dict 访问的方式来访问 Series 和 DataFrame。\n\n\nimport pandas as pd\n\ndata = {'col1': [1, 2, 3], 'col2': [4, 5, 6]}\ndf = pd.DataFrame(data)\n\n# 访问 'col1' 列\nprint(\"访问 'col1' 列:\\n\", df['col1'])  # 类似于访问字典的键\n\n# 对于 Series，可以直接通过索引访问\ns = pd.Series([10, 20, 30], index=['a', 'b', 'c'])\nprint(\"Series 通过索引访问:\\n\", s['b'])\n\n\n\n类似属性方式的访问\n\n接受参数类型包括：\n\n单个变量\n数组形式（list 或者 NumPy 的 ndarray）\n布尔数组\n回调函数。\n\n\n\nimport pandas as pd\n\ndata = {'col1': [1, 2, 3], 'col2': [4, 5, 6]}\ndf = pd.DataFrame(data, index=['A', 'B', 'C'])\n\n# 单个变量\nprint(\"单个变量:\\n\", df.col1)  # 访问 'col1' 列，类似于访问对象的属性\n\n# 数组形式\nprint(\"数组形式:\\n\", df[['col1', 'col2']])\n\n# 布尔数组\nprint(\"布尔数组:\\n\", df[df.col1 &gt; 1])  # 使用布尔数组筛选数据\n\n# 回调函数\nprint(\"回调函数:\\n\", df[lambda df: df.col2 &gt; 4])"
  },
  {
    "objectID": "qmd/chapter5.html#调用方式间的区别",
    "href": "qmd/chapter5.html#调用方式间的区别",
    "title": "信息技术基础 📊",
    "section": "调用方式间的区别",
    "text": "调用方式间的区别\n\nloc函数和iloc函数的区别\n\nloc 函数和 iloc 函数都是对 index 的访问。\n对于 DataFrame，也可以实现对某个 index 下的某个 column 的访问。\n接收的数据类型相同，但含义不同：\n\nloc 函数接收 Index 对象（index 和 columns）的 label。\niloc 函数接收 Index 对象（index 和 columns）的 position。\n\n\n\n\n通过loc访问和通过[]访问的区别\n\nloc 函数和 [] 都接收 Index 对象（index 和 columns）的 label 作为参数。\nloc 函数是对 index 的访问。\n[] 在 DataFrame 中是对 columns 的访问，在 Series 中无差别。"
  },
  {
    "objectID": "qmd/chapter5.html#特殊的输入类型",
    "href": "qmd/chapter5.html#特殊的输入类型",
    "title": "信息技术基础 📊",
    "section": "特殊的输入类型",
    "text": "特殊的输入类型\n\n输入为布尔类型数组\n\n使用布尔类型数组作为输入参数也是常见的操作之一。\n可用的运算符包括：\n\n| (或运算)\n& (与运算)\n~ (非运算)\n\n注意：要使用圆括号 () 来组合条件。\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'col1': [1, 2, 3], 'col2': [4, 5, 6]})\n\n# 选取 col1 大于 1 且 col2 小于 6 的行\nprint(\"选取 col1 大于 1 且 col2 小于 6 的行:\\n\", df[(df['col1'] &gt; 1) & (df['col2'] &lt; 6)])\n\n# 选取 col1 等于 1 或 col2 大于 5 的行\nprint(\"选取 col1 等于 1 或 col2 大于 5 的行:\\n\", df[(df['col1'] == 1) | (df['col2'] &gt; 5)])\n\n\n\n输入为回调函数\n\nloc、iloc 和 [] 都接收回调函数作为输入来进行访问。\n回调函数必须以被访问的 Series 或者 DataFrame 作为参数。\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'col1': [1, 2, 3], 'col2': [4, 5, 6]})\n\n# 使用回调函数选取 col2 大于 4 的行\nprint(\"使用回调函数选取 col2 大于 4 的行:\\n\", df[lambda df: df['col2'] &gt; 4])\n\n# 使用 loc 和回调函数选取 col1 大于 1 的行\nprint(\"使用 loc 和回调函数选取 col1 大于 1 的行:\\n\", df.loc[lambda df: df['col1'] &gt; 1])\n\n# 使用 iloc 和回调函数选取第 0 行和第 2 行\nprint(\"使用 iloc 和回调函数选取第 0 行和第 2 行:\\n\", df.iloc[lambda df: [0, 2]])"
  },
  {
    "objectID": "qmd/chapter5.html#数学统计和计算工具",
    "href": "qmd/chapter5.html#数学统计和计算工具",
    "title": "信息技术基础 📊",
    "section": "数学统计和计算工具 🧮",
    "text": "数学统计和计算工具 🧮\n\n统计函数\n\nPandas 提供了一系列统计函数接口，方便用户直接进行统计运算。\n包括：\n\n协方差: 用于衡量两个变量的总体误差。当两个变量的变化趋势一致时，协方差为正；当变化趋势相反时，协方差为负；如果两个变量相互独立，则协方差为0。\n\n协方差 (Covariance):\n\n公式： \\[\nCov(X, Y) = \\frac{\\sum_{i=1}^{n}(X_i - \\bar{X})(Y_i - \\bar{Y})}{n-1}\n\\] 其中，\\(X\\) 和 \\(Y\\) 是两个变量，\\(\\bar{X}\\) 和 \\(\\bar{Y}\\) 分别是它们的平均值，\\(n\\) 是样本数量。\n\n\n相关系数: 用于研究变量之间线性相关程度的量。相关系数的取值范围在-1到1之间，绝对值越大，说明变量之间的线性相关性越强。\n\n相关系数 (Correlation Coefficient):\n\n公式： \\[\nCorr(X, Y) = \\frac{Cov(X, Y)}{\\sigma_X \\sigma_Y}\n\\] 其中，\\(Cov(X, Y)\\) 是 \\(X\\) 和 \\(Y\\) 的协方差，\\(\\sigma_X\\) 和 \\(\\sigma_Y\\) 分别是 \\(X\\) 和 \\(Y\\) 的标准差。\n\n\n排序: 对数据进行排序。\n\nPandas 提供了：\n\n两个 Series 对象之间的协方差计算接口。\n一个 DataFrame 的协方差矩阵的计算接口。\n\n\n\nimport pandas as pd\n\ns1 = pd.Series([1, 2, 3, 4, 5])\ns2 = pd.Series([2, 3, 1, 5, 4])\n\n# 计算 s1 和 s2 的协方差\ncovariance = s1.cov(s2)\nprint(f\"协方差: {covariance}\")\n\n# 计算 s1 和 s2 的相关系数\ncorrelation = s1.corr(s2)\nprint(f\"相关系数: {correlation}\")\n\ndf = pd.DataFrame({'col1': [1, 2, 3], 'col2': [4, 5, 6]})\n\n# 计算 DataFrame 的协方差矩阵\ncov_matrix = df.cov()\nprint(f\"协方差矩阵:\\n{cov_matrix}\")\n\n# 计算 DataFrame 的相关系数矩阵\ncorr_matrix = df.corr()\nprint(f\"相关系数矩阵:\\n{corr_matrix}\")"
  },
  {
    "objectID": "qmd/chapter5.html#窗口函数",
    "href": "qmd/chapter5.html#窗口函数",
    "title": "信息技术基础 📊",
    "section": "窗口函数",
    "text": "窗口函数\n\n\n\n\n\n\nTip\n\n\n\n在移动窗口上计算统计函数对于处理时序数据 📈 非常常见。\n\n\n\nPandas 提供了一系列窗口函数，包括：\n\n计数\n求和\n求平均\n中位数\n相关系数\n方差\n协方差\n标准差\n偏斜度\n峰度\n\n窗口对象：\n\nRolling:\n\n定长的窗口。\n需要通过参数 window 指定窗口大小。\n\nExpanding:\n\n扩展窗口。\n第 i 个窗口的大小为 i。\n可以将其看作特殊的 windows 为数据长度、min_periods 为 1 的 Rolling 对象。\n\nEWM (Exponentially Weighted Moving):\n\n指数加权窗口。\n需要定义衰减因子 α。\n定义方式：\n\n时间间隔 span。\n质心 center of mass。\n半衰期 half-life（指数权重减少到一半需要的时间）。\n直接定义 alpha。\n\n\n\n\n\nimport pandas as pd\n\n# 创建一个时间序列\ns = pd.Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n              index=pd.date_range('2023-01-01', periods=10, freq='D'))\n\n# Rolling 窗口\nrolling_mean = s.rolling(window=3).mean()  # 计算 3 天的滚动平均值\nprint(f\"滚动平均:\\n{rolling_mean}\")\n\n# Expanding 窗口\nexpanding_sum = s.expanding().sum()  # 计算累计和\nprint(f\"累计和:\\n{expanding_sum}\")\n\n# EWM 窗口\newm_mean = s.ewm(span=3).mean()  # 计算指数加权移动平均值\nprint(f\"指数加权移动平均:\\n{ewm_mean}\")"
  },
  {
    "objectID": "qmd/chapter5.html#窗口对象的统计函数",
    "href": "qmd/chapter5.html#窗口对象的统计函数",
    "title": "信息技术基础 📊",
    "section": "窗口对象的统计函数 📊",
    "text": "窗口对象的统计函数 📊\n\n\n\n\n\n\n\n函数\n说明\n\n\n\n\ncount()\n移动窗口内非 NaN 值的计数\n\n\nsum()\n移动窗口内的和\n\n\nmean()\n移动窗口内的平均值\n\n\nmedian()\n移动窗口内的中位数\n\n\nmin()\n移动窗口内的最小值\n\n\nmax()\n移动窗口内的最大值\n\n\nstd()\n移动窗口内的无偏估计标准差（分母为 n-1）\n\n\nvar()\n移动窗口内的无偏估计方差（分母为 n-1）\n\n\nskew()\n移动窗口内的偏度 (样本的三阶标准化矩)\n\n\nkurt()\n移动窗口内的峰度 (样本的四阶标准化矩)\n\n\nquantile()\n移动窗口内的指定分位数位置的值（传入的应该是 [0,1] 的值）\n\n\napply()\n在移动窗口内使用普通的（可以自定义的）数组函数\n\n\ncov()\n移动窗口内的协方差\n\n\ncorr()\n移动窗口内的相关系数"
  },
  {
    "objectID": "qmd/chapter5.html#数学聚合和分组运算",
    "href": "qmd/chapter5.html#数学聚合和分组运算",
    "title": "信息技术基础 📊",
    "section": "数学聚合和分组运算 ➕➖",
    "text": "数学聚合和分组运算 ➕➖\n\n\n\n\n\n\nNote\n\n\n\n类似于 SQL 操作中的分组和聚合，Pandas 提供了 groupby 功能。\n\n\n\ngroupby 包括三个阶段：\n\nsplit：根据一定原则将数据分组。\n\n分组 (Grouping)：将数据按照某个或某些特征划分为不同的组。\n\napply：每个组分别执行一个函数，产生一个新值。\n\n应用函数 (Apply Function)：对每个分组应用一个函数，例如求和、平均值等。\n\ncombine：将各组的结果合并到最终对象中。\n\n合并 (Combine)：将每个分组的结果合并成一个最终的结果。\n\n\n拆分操作：\n\nPandas 对象（Series 或 DataFrame）根据提供的键在特定的轴上进行拆分。\nDataFrame 可以指定是在 index 轴还是 columns 轴。"
  },
  {
    "objectID": "qmd/chapter5.html#拆分键的形式",
    "href": "qmd/chapter5.html#拆分键的形式",
    "title": "信息技术基础 📊",
    "section": "拆分键的形式",
    "text": "拆分键的形式\n\n\n\n\n\n\n\n拆分键的形式说明\n示例\n\n\n\n\n和所选轴长度相同的数组（list 或 NumPy 的 array，甚至是一个 Series 对象）\ndf.groupby(group_list).count()\n\n\nDataFrame 某个列名的值或列名的 list\ndf.groupby('a') df.groupby(df['a'])\n\n\n\n# 上述两个表述等价\n\n\n\ngroup_series = pd.Series(group_list) df.groupby(group_series)\n\n\n参数为 axis 的标签的函数\ndf.groupby(df.loc['one'],axis=1)\n\n\n\ndef get_index_number(index): if index in ['one','two']:  return 'small'  else:  return 'big'  df.groupby(get_index_number)\n\n\n字典或者 Series，给出 axis 上的值与分组名之间的对应关系\n#该示例与Demo1的效果相同 group_list = ['one','two','one','two','two']  group_series = pd.Series(group_list,index = df.index)  df.groupby(group_series)\n\n\n组1、2、3、4的 list 或者\ndf.groupby(['a','b'])\n\n\n\n\nimport pandas as pd\n\ndata = {'col1': ['A', 'A', 'B', 'B', 'A'],\n        'col2': [1, 2, 3, 4, 5],\n        'col3': [6, 7, 8, 9, 10]}\n\ndf = pd.DataFrame(data)\n\n# 按 'col1' 分组，计算每组的平均值\ngrouped = df.groupby('col1')\nprint(\"按 'col1' 分组，计算每组的平均值:\\n\", grouped.mean())\n\n# 按 'col1' 和 'col2' 分组，计算每组的总和\ngrouped = df.groupby(['col1', 'col2'])\nprint(\"按 'col1' 和 'col2' 分组，计算每组的总和:\\n\", grouped.sum())\n\n# 使用自定义函数分组\ndef custom_group(index):\n  if index &lt; 2:\n    return 'group1'\n  else:\n    return 'group2'\n\ngrouped = df.groupby(custom_group)\nprint(\"使用自定义函数分组:\\n\", grouped.mean())"
  },
  {
    "objectID": "qmd/chapter5.html#应用部分",
    "href": "qmd/chapter5.html#应用部分",
    "title": "信息技术基础 📊",
    "section": "应用部分",
    "text": "应用部分\n\n主要实现以下三类操作：\n\n聚合操作：对于每个组经过计算得到一个概要性质的统计值，例如求和、求平均等。\n\n聚合 (Aggregation)：将多个数据值合并为一个值。\n\n转换操作：对于每个组经过计算得到和组的长度相同的一系列的值，例如对数据的标准化、填充 NA 值等。\n\n转换 (Transformation)：对数据进行某种形式的修改。\n\n过滤操作：通过对每个组的计算得到一个布尔类型的值完成对组的筛选，例如通过求得组的平均值来筛选组，或者每个组内通过一定的条件进行筛选。\n\n过滤 (Filtering)：根据某些条件筛选数据。\n\n\n\n\nimport pandas as pd\n\ndata = {'group': ['A', 'A', 'B', 'B', 'A'],\n        'value': [1, 2, 3, 4, 5]}\ndf = pd.DataFrame(data)\n\n# 聚合：计算每组的总和\ngrouped_sum = df.groupby('group').sum()\nprint(f\"聚合 - 每组总和:\\n{grouped_sum}\")\n\n# 转换：对每组进行标准化\nnormalized = df.groupby('group')['value'].transform(lambda x: (x - x.mean()) / x.std())\nprint(f\"转换 - 标准化:\\n{normalized}\")\n\n# 过滤：筛选出 value 平均值大于 2 的组\nfiltered = df.groupby('group').filter(lambda x: x['value'].mean() &gt; 2)\nprint(f\"过滤 - 平均值大于 2 的组:\\n{filtered}\")"
  },
  {
    "objectID": "qmd/chapter5.html#总结",
    "href": "qmd/chapter5.html#总结",
    "title": "信息技术基础 📊",
    "section": "总结 📝",
    "text": "总结 📝\n\nPandas 是 Python 数据分析的重要工具，提供了 Series 和 DataFrame 两种核心数据结构。\n\nSeries: 类似于带标签的一维数组。\nDataFrame: 类似于带标签的二维数组，或多个 Series 共享同一索引。\n\nPandas 具有强大的数据访问、操作、统计和分组功能。\n理解 loc、iloc 和 [] 的区别对于高效使用 Pandas 至关重要。\n\nloc: 通过标签访问数据。\niloc: 通过位置访问数据。\n[]: DataFrame 中用于访问列，Series 中类似于 loc。\n\n窗口函数是处理时序数据的有力工具。\ngroupby 功能可以实现类似于 SQL 的分组聚合操作。\n\nsplit: 按规则分组。\napply: 应用函数。\ncombine: 合并结果。"
  },
  {
    "objectID": "qmd/chapter5.html#思考与讨论",
    "href": "qmd/chapter5.html#思考与讨论",
    "title": "信息技术基础 📊",
    "section": "思考与讨论 🤔",
    "text": "思考与讨论 🤔\n\n在实际应用中，如何选择合适的数据结构（Series 或 DataFrame）？\n\n当只需要处理一维数据，或者需要一个带标签的数组时，选择 Series。\n当需要处理二维数据，或者需要一个表格结构时，选择 DataFrame。\n\nloc 和 iloc 在使用场景上有哪些区别？\n\n当需要通过标签访问数据时，使用 loc。\n当需要通过位置访问数据时，使用 iloc。"
  },
  {
    "objectID": "qmd/chapter5.html#思考与讨论-续",
    "href": "qmd/chapter5.html#思考与讨论-续",
    "title": "信息技术基础 📊",
    "section": "思考与讨论 🤔 (续)",
    "text": "思考与讨论 🤔 (续)\n\n如何利用 Pandas 的窗口函数分析股票数据？ (续)\n\n可以使用 ewm 函数计算指数加权移动平均线。\n\n指数加权移动平均线 (Exponentially Weighted Moving Average, EWMA)：对近期数据赋予更高的权重，更能反映最近的价格变化。\n\n\ngroupby 功能在实际数据分析中有哪些应用？\n\n可以按类别分组，计算每个类别的统计量。\n可以按时间分组，计算每个时间段的统计量。\n可以自定义分组规则，进行更灵活的数据分析。\n\n结合一个具体案例，如分析某个商场不同部门的销售数据，来设计到到目前课件为止的pandas操作？"
  },
  {
    "objectID": "qmd/chapter5.html#案例分析商场销售数据分析",
    "href": "qmd/chapter5.html#案例分析商场销售数据分析",
    "title": "信息技术基础 📊",
    "section": "案例分析：商场销售数据分析 🛒",
    "text": "案例分析：商场销售数据分析 🛒\n我们将使用 Pandas 分析某个商场不同部门的销售数据。\n\n1. 数据读取 📂\n\nimport pandas as pd\n\n# 假设数据文件名为 '商场销售数据.csv'\nsales_data = pd.read_csv('商场销售数据.csv')\n\n\npd.read_csv(): Pandas 函数，用于从 CSV 文件读取数据，返回一个 DataFrame。\nsales_data: DataFrame 变量，用于存储读取的数据。\n\n\n\n2. 数据概览 👀\n\nprint(sales_data.head())  # 查看前几行数据\nprint(sales_data.info())  # 查看数据类型和缺失值\nprint(sales_data.describe())  # 查看数据的统计信息\n\n\nsales_data.head(): 查看 DataFrame 的前几行（默认为 5 行），用于快速了解数据的结构。\nsales_data.info(): 查看 DataFrame 的详细信息，包括：\n\n每列的名称和数据类型。\n非空值的数量。\n内存使用情况。\n\nsales_data.describe(): 查看 DataFrame 的统计摘要，包括：\n\n计数 (count)\n平均值 (mean)\n标准差 (std)\n最小值 (min)\n25% 分位数\n中位数 (50% 分位数)\n75% 分位数\n最大值 (max)\n\n\n\n\n3. 数据清洗 🧹\n\n# 处理缺失值（假设用平均值填充）\nsales_data.fillna(sales_data.mean(), inplace=True)\n\n# 重命名列名\nsales_data = sales_data.rename(columns={'部门': 'department', '销售额': 'sales'})\n\n\nsales_data.fillna(): 填充 DataFrame 中的缺失值 (NaN)。\n\nsales_data.mean(): 计算每列的平均值。\ninplace=True: 直接修改原 DataFrame，不返回新的 DataFrame。\n\nsales_data.rename(): 重命名 DataFrame 的列名。\n\ncolumns={'部门': 'department', '销售额': 'sales'}: 将 “部门” 列重命名为 “department”，将 “销售额” 列重命名为 “sales”。\n\n\n\n\n4. 数据访问和筛选 🎯\n\n# 访问特定列\ndepartments = sales_data['department']\n\n# 访问特定行\nfirst_row = sales_data.loc[0]\n\n# 条件筛选 筛选出销售额大于10000的记录\nhigh_sales = sales_data[sales_data['sales'] &gt; 10000]\n\n# 使用 loc 筛选出特定部门和销售额的记录\nclothing_sales = sales_data.loc[(sales_data['department'] == '服装') & (sales_data['sales'] &gt; 5000)]\n\n\nsales_data['department']: 访问 “department” 列，返回一个 Series。\nsales_data.loc[0]: 使用 loc 访问第一行（标签为 0 的行），返回一个 Series。\nsales_data[sales_data['sales'] &gt; 10000]: 使用布尔索引筛选出 “sales” 列大于 10000 的行。\nsales_data.loc[(sales_data['department'] == '服装') & (sales_data['sales'] &gt; 5000)]: 使用 loc 和布尔索引筛选出 “department” 列为 “服装” 且 “sales” 列大于 5000 的行。\n\n\n\n5. 数据统计 📈\n\n# 计算总销售额\ntotal_sales = sales_data['sales'].sum()\n\n# 计算每个部门的平均销售额\navg_sales_by_department = sales_data.groupby('department')['sales'].mean()\n\n# 计算每个部门的销售额标准差\nstd_sales_by_department = sales_data.groupby('department')['sales'].std()\n\n\nsales_data['sales'].sum(): 计算 “sales” 列的总和。\nsales_data.groupby('department')['sales'].mean():\n\nsales_data.groupby('department'): 按 “department” 列分组。\n['sales']: 选择分组后的 “sales” 列。\n.mean(): 计算每组的平均值。\n\nsales_data.groupby('department')['sales'].std(): 计算每个部门销售额的标准差。\n\n\n\n6. 数据排序 ⬇️⬆️\n\n# 按销售额降序排列\nsales_data_sorted = sales_data.sort_values(by='sales', ascending=False)\n\n\nsales_data.sort_values(): 对 DataFrame 进行排序。\n\nby='sales': 按 “sales” 列排序。\nascending=False: 降序排列 (从大到小)。\n\n\n\n\n7. 窗口函数应用 (假设有日期数据) ⏱️\n\n# 假设数据中有 'date' 列，表示销售日期\nsales_data['date'] = pd.to_datetime(sales_data['date'])\nsales_data.set_index('date', inplace=True)\n\n# 计算 7 天滚动平均销售额\nrolling_avg_sales = sales_data['sales'].rolling(window=7).mean()\n\n# 计算每月销售总额\nmonthly_sales = sales_data['sales'].resample('M').sum()\n\n\nsales_data['date'] = pd.to_datetime(sales_data['date']): 将 “date” 列转换为日期时间类型。\nsales_data.set_index('date', inplace=True): 将 “date” 列设置为 DataFrame 的索引。\nsales_data['sales'].rolling(window=7).mean(): 计算 “sales” 列的 7 天滚动平均值。\nsales_data['sales'].resample('M').sum():\n\n.resample('M'): 按月对数据进行重采样。\n.sum(): 计算每个月的销售总额。\n\n\n\n\n8. 分组聚合 ➕➖\n\n# 计算每个部门的销售总额、平均销售额、最大销售额\ndepartment_stats = sales_data.groupby('department')['sales'].agg(['sum', 'mean', 'max'])\n\n# 筛选出销售总额大于 50000 的部门\nhigh_performing_departments = department_stats[department_stats['sum'] &gt; 50000]\n\n\nsales_data.groupby('department')['sales'].agg(['sum', 'mean', 'max']):\n\nsales_data.groupby('department'): 按 “department” 列分组。\n['sales']: 选择分组后的 “sales” 列。\n.agg(['sum', 'mean', 'max']): 对每组应用多个聚合函数 (求和、平均值、最大值)。\n\ndepartment_stats[department_stats['sum'] &gt; 50000]: 筛选出 “sum” 列大于 50000 的行。\n\n以上就是 Pandas 数据分析的基本流程和常用操作。通过这些操作，我们可以从原始数据中提取有用的信息，为业务决策提供支持。"
  },
  {
    "objectID": "qmd/chapter6.html",
    "href": "qmd/chapter6.html",
    "title": "信息技术基础 📊",
    "section": "",
    "text": "本章将带你探索数据分析与知识发现的奇妙世界，我们将学习几种常用的方法，就像解锁一个个宝箱 🔑，发现数据中隐藏的秘密。主要包括：\n\n📦 分类分析 (Classification Analysis)：将数据分门别类，就像整理房间一样。\n🔗 关联分析 (Association Analysis)：寻找数据之间的关联，就像侦探 🕵️‍♀️ 发现线索。\n🤝 聚类分析 (Cluster Analysis)：将相似的数据聚集在一起，就像朋友们聚会 🥳。\n📈 回归分析 (Regression Analysis)：预测未来的趋势，就像天气预报 🌤️。\n\n这些方法在金融、商业、科学研究等领域都有广泛的应用。通过学习这些方法，我们可以从数据中提取有价值的信息，并将其转化为知识，为决策提供支持。"
  },
  {
    "objectID": "qmd/chapter6.html#本章概述",
    "href": "qmd/chapter6.html#本章概述",
    "title": "信息技术基础 📊",
    "section": "",
    "text": "本章将带你探索数据分析与知识发现的奇妙世界，我们将学习几种常用的方法，就像解锁一个个宝箱 🔑，发现数据中隐藏的秘密。主要包括：\n\n📦 分类分析 (Classification Analysis)：将数据分门别类，就像整理房间一样。\n🔗 关联分析 (Association Analysis)：寻找数据之间的关联，就像侦探 🕵️‍♀️ 发现线索。\n🤝 聚类分析 (Cluster Analysis)：将相似的数据聚集在一起，就像朋友们聚会 🥳。\n📈 回归分析 (Regression Analysis)：预测未来的趋势，就像天气预报 🌤️。\n\n这些方法在金融、商业、科学研究等领域都有广泛的应用。通过学习这些方法，我们可以从数据中提取有价值的信息，并将其转化为知识，为决策提供支持。"
  },
  {
    "objectID": "qmd/chapter6.html#什么是数据分析",
    "href": "qmd/chapter6.html#什么是数据分析",
    "title": "信息技术基础 📊",
    "section": "什么是数据分析？ 🤔",
    "text": "什么是数据分析？ 🤔\n\n\n\n\n\n\nNote\n\n\n\n数据分析是一个迭代探索的过程。它利用统计学、机器学习等方法，对数据进行收集、清洗、转换、建模和可视化，从而发现数据中的模式、趋势、异常和关联，并对这些发现进行解释和评估。最终目的是从数据中提取有价值的信息，将其转化为知识，为决策提供支持。\n数据分析就像一位厨师 👨‍🍳，将原始食材（数据）经过一系列处理，变成美味佳肴（知识）。"
  },
  {
    "objectID": "qmd/chapter6.html#数据分析与python",
    "href": "qmd/chapter6.html#数据分析与python",
    "title": "信息技术基础 📊",
    "section": "数据分析与Python 🐍",
    "text": "数据分析与Python 🐍\nPython 是一种广泛应用于数据分析的编程语言，它就像一把瑞士军刀 🛠️，功能强大，方便实用。它具有以下优点：\n\n易于学习和使用: Python 语法简洁清晰，易于上手，就像搭乐高积木一样 🧱。\n丰富的库和工具: Python 拥有大量用于数据分析的库和工具，如 NumPy, Pandas, Scikit-learn, Matplotlib, Seaborn 等，可以大大提高数据分析的效率，就像拥有了各种神奇的工具 🧰。\n强大的社区支持: Python 拥有庞大的用户社区，可以提供丰富的学习资源和技术支持，就像有一个智囊团 🧠 在你身边。\n跨平台性: Python 可以在各种操作系统上运行，包括 Windows, macOS 和 Linux，就像一名旅行家 🌍，可以在不同的地方工作。"
  },
  {
    "objectID": "qmd/chapter6.html#python小例子",
    "href": "qmd/chapter6.html#python小例子",
    "title": "信息技术基础 📊",
    "section": "Python小例子 🐍",
    "text": "Python小例子 🐍\n\nimport pandas as pd\n\n# 创建一个 DataFrame (数据表格) 就像制作一个 Excel 表格 📊\ndata = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n        'Age': [25, 32, 18, 47],\n        'City': ['New York', 'Paris', 'London', 'Tokyo']}\ndf = pd.DataFrame(data)\n\n# 打印 DataFrame\nprint(df)\n\n# 计算平均年龄\naverage_age = df['Age'].mean()\nprint(f\"平均年龄: {average_age}\")\n\n      Name  Age      City\n0    Alice   25  New York\n1      Bob   32     Paris\n2  Charlie   18    London\n3    David   47     Tokyo\n平均年龄: 30.5\n\n\n这段代码演示了如何使用 Pandas 库创建一个简单的数据表格并计算平均年龄，就像用 Excel 做简单的计算一样。\n\n首先，我们导入了pandas库，这是Python中用于数据分析的核心库。\n然后，我们创建了一个字典data，其中包含了一些姓名、年龄和城市的数据。\n接着，我们使用pd.DataFrame(data)将这个字典转换成了一个DataFrame对象，DataFrame是pandas中用于表示表格数据的核心数据结构。\n最后，我们使用df['Age'].mean()计算了年龄这一列的平均值。"
  },
  {
    "objectID": "qmd/chapter6.html#分类分析",
    "href": "qmd/chapter6.html#分类分析",
    "title": "信息技术基础 📊",
    "section": "分类分析 🎯",
    "text": "分类分析 🎯\n\n\n\n\n\n\nNote\n\n\n\n分类是找出数据库中一组数据对象的共同特点并按照分类模式将其划分为不同的类，其目的是通过分类模型，将数据库中的数据项映射到某个给定的类别。\n分类就像图书管理员 📚 将书籍按照主题分类，或者像垃圾分类 ♻️ 一样，将不同的物品放入不同的垃圾桶。\n\n\n\n监督学习 👀\n分类学习是一类监督学习 (Supervised Learning) 的问题。\n\n监督学习: 从有标签的训练数据中学习模型，然后对未知数据进行预测。\n\n训练数据: 包含特征和标签的数据集，就像一本带有答案的练习册 📖。\n标签: 数据的类别或目标值，就像练习册中的答案 ✅。\n\n常见的监督学习任务：\n\n分类 (Classification): 预测离散的类别标签，就像判断一张图片是猫 🐱 还是狗 🐶。\n回归 (Regression): 预测连续的目标值，就像预测明天的气温 🌡️。\n\n\n\n\n监督学习：举例说明 📝\n假设我们有一组鸢尾花的数据，每朵花都有花萼长度、花萼宽度、花瓣长度、花瓣宽度四个特征，并且知道每朵花属于哪个品种（山鸢尾、变色鸢尾、维吉尼亚鸢尾）。\n\n特征: 花萼长度、花萼宽度、花瓣长度、花瓣宽度\n标签: 山鸢尾、变色鸢尾、维吉尼亚鸢尾\n\n我们的目标是训练一个模型，能够根据花的特征预测花的品种。这就是一个典型的监督学习中的分类问题。\n\n\n分类问题的类型 🗂️\n根据分类结果可以分为：\n\n二分类问题 (Binary Classification): 是与非的判断，分类结果为两类，从中选择一个作为预测结果。例如：判断一封邮件是否为垃圾邮件 📧🚫。\n多分类问题 (Multi-class Classification): 分类结果为多个类别，从中选择一个作为预测结果。例如：识别一张图片中的动物是猫 🐱、狗 🐶、鸟 🐦 还是兔子 🐰。\n多标签分类问题 (Multi-label Classification): 不同于前两者，多标签分类问题一个样本的预测结果可能是多个，或者有多个标签。例如：一部电影可以同时被分为动作片 🎬 和犯罪片 🔪，一则新闻可以同时属于政治 🏛️ 和法律 ⚖️ 等。"
  },
  {
    "objectID": "qmd/chapter6.html#分类分析常用算法---概览",
    "href": "qmd/chapter6.html#分类分析常用算法---概览",
    "title": "信息技术基础 📊",
    "section": "分类分析常用算法 ⚙️- 概览",
    "text": "分类分析常用算法 ⚙️- 概览\n\n\n\n\n\n\n\n\n\n\n算法\n原理\n优点\n缺点\n应用\n\n\n\n\n逻辑回归\n基于线性模型，使用Logistic函数将输出映射到[0,1]区间\n模型简单，可解释性强，计算效率高\n对非线性关系拟合能力有限\n信用风险评估、疾病诊断、客户流失预测\n\n\n线性判别分析\n将数据投影到一条直线上，使得同类样本尽可能接近，异类样本尽可能远离\n计算效率高，对数据分布有一定的鲁棒性\n对非线性关系拟合能力有限，对异常值敏感\n人脸识别、手写数字识别\n\n\n支持向量机\n找到一个最优超平面，将不同类别的样本分隔开，并最大化间隔\n对高维数据和非线性关系有较好的处理能力，具有较好的泛化性能\n对大规模数据集计算复杂度较高，对参数和核函数选择敏感\n文本分类、图像识别\n\n\n决策树\n基于树结构进行决策，通过一系列的if-else规则进行分类\n模型易于理解和解释，可以处理非线性关系，对缺失值不敏感\n容易过拟合，对数据中的噪声敏感\n客户细分、医疗诊断\n\n\nK邻近\n基于距离度量，找到与待分类样本最近的k个邻居，根据邻居的类别进行投票\n无需训练，实现简单\n计算复杂度较高，对k值选择敏感，对数据分布敏感\n推荐系统、异常检测\n\n\n朴素贝叶斯\n基于贝叶斯定理和特征条件独立假设，计算样本属于每个类别的概率，选择概率最大的类别\n计算效率高，对缺失数据不敏感\n特征条件独立假设在实际中往往不成立\n垃圾邮件过滤、情感分析"
  },
  {
    "objectID": "qmd/chapter6.html#逻辑回归-logistic-regression",
    "href": "qmd/chapter6.html#逻辑回归-logistic-regression",
    "title": "信息技术基础 📊",
    "section": "逻辑回归 (Logistic Regression) 🧠",
    "text": "逻辑回归 (Logistic Regression) 🧠\n\n概念解释 🤓\n\n线性关系: 特征与分类结果之间的关系可以用线性方程表示，就像我们可以用一条直线 📏 来近似描述身高和体重的关系。\n\n线性方程：\\(y = wx + b\\)\n其中，\\(w\\) 是权重向量，\\(x\\) 是特征向量，\\(b\\) 是偏置项。\n\n实数域: 所有实数的集合，就像一条无限延伸的数轴 ↔︎️。\n{0, 1} 空间: 只有 0 和 1 两个值的集合，就像一个开关 💡，只有开和关两种状态。\nLogistic 函数: 一种 S 形函数，可以将实数映射到 (0, 1) 区间，就像一个魔法 🧙‍♀️，将任何数字变成 0 到 1 之间的数字。\n\n\n\nLogistic 函数 📝\n\\[\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\n\\]\n\n\\(z\\): 线性方程的结果 (\\(z = wx + b\\))\n\\(e\\): 自然对数的底数 (约等于 2.718)\n\\(\\sigma(z)\\): 介于 0 和 1 之间的概率值\n\n\n\n\n\n\n\nLogistic函数图像\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nz = np.linspace(-10, 10, 100)\nsigma = 1 / (1 + np.exp(-z))\n\nplt.figure(figsize=(8, 6))\nplt.plot(z, sigma)\nplt.xlabel(\"z\")\nplt.ylabel(\"$\\sigma(z)$\")\nplt.title(\"Logistic Function\")\nplt.grid(True)\nplt.show()\n\n\n&lt;&gt;:10: SyntaxWarning: invalid escape sequence '\\s'\n&lt;&gt;:10: SyntaxWarning: invalid escape sequence '\\s'\n/tmp/ipykernel_2806/2242896298.py:10: SyntaxWarning: invalid escape sequence '\\s'\n  plt.ylabel(\"$\\sigma(z)$\")\n\n\n\n\n\n\n\n\nFigure 1: Logistic函数图像\n\n\n\n\n\n从图中可以看出，Logistic函数将任意实数映射到 (0, 1) 区间，当 \\(z\\) 趋近于正无穷时，\\(\\sigma(z)\\) 趋近于 1；当 \\(z\\) 趋近于负无穷时，\\(\\sigma(z)\\) 趋近于 0。\n\n\n\n\n逻辑回归的优点 👍\n\n直接对分类概率进行建模，无需事先假设数据分布，就像我们可以直接估计一件事情发生的可能性，而不需要知道事情发生的具体细节。\n是一个判别模型 (Discriminative Model)。\n\n判别模型: 直接学习预测模型，例如逻辑回归，就像我们直接学习如何区分猫 🐱 和狗 🐶，而不需要知道猫和狗是如何产生的。\n生成模型 (Generative Model): 学习数据的联合分布，然后进行预测，例如朴素贝叶斯，就像我们先学习猫和狗的各种特征，然后根据这些特征来判断一个动物是猫还是狗。\n\nLogistic 函数是任意阶可导凸函数，可以使用许多数学优化算法，就像我们可以用各种工具 🛠️ 来打磨一块玉石 💎。"
  },
  {
    "objectID": "qmd/chapter6.html#线性判别分析-linear-discriminant-analysis-lda",
    "href": "qmd/chapter6.html#线性判别分析-linear-discriminant-analysis-lda",
    "title": "信息技术基础 📊",
    "section": "线性判别分析 (Linear Discriminant Analysis, LDA) 📐",
    "text": "线性判别分析 (Linear Discriminant Analysis, LDA) 📐\n\nLDA 的核心思想 💡\n\n将训练样本投影到一条直线上，使得：\n\n同类样本的投影点尽可能接近，就像让好朋友们 🤝 站得近一些。\n异类样本的投影点尽可能远离，就像让陌生人 🧍 保持距离。\n协方差尽可能小。\n\n\n\n\n投影 📐\n\n假设有一条直线 \\(l\\)，我们可以将任意一个点 \\(x\\) 投影到这条直线上，得到投影点 \\(x'\\)。\n投影的过程可以用向量内积来表示：\\(x' = w^Tx\\)，其中 \\(w\\) 是直线的方向向量。\n\n\n\n目标函数 🎯\nLDA 的目标是最大化类间距离，最小化类内距离。可以通过数学公式推导出 LDA 的目标函数，就像我们可以用公式来计算投篮 🏀 的最佳角度。\n\n类间距离: 不同类别样本的投影点之间的距离。\n类内距离: 同一类别样本的投影点之间的距离。\n目标函数: \\(\\frac{w^TS_bw}{w^TS_ww}\\)\n\n\\(S_b\\): 类间散度矩阵\n\\(S_w\\): 类内散度矩阵"
  },
  {
    "objectID": "qmd/chapter6.html#支持向量机-support-vector-machine-svm",
    "href": "qmd/chapter6.html#支持向量机-support-vector-machine-svm",
    "title": "信息技术基础 📊",
    "section": "支持向量机 (Support Vector Machine, SVM) 🛡️",
    "text": "支持向量机 (Support Vector Machine, SVM) 🛡️\n\nSVM 的基本思想\n\n基于训练集在样本空间中找到一个超平面可以将不同类别的样本分开,就像用一把刀 🔪 将苹果 🍎 和橙子 🍊 分开。\n并且使得所有的数据点都尽可能的远离超平面\n如何找到一个最优的超平面以及最优超平面如何定义是支持向量机需要解决的问题。\n我们所需要寻找的超平面应该对样本局部扰动的“容忍性”最好,即结果对于未知样本的预测更加准确。\n\n\n\n核心概念 🤓\n\n超平面 (Hyperplane): 在高维空间中，将数据划分为两部分的平面，就像在二维空间中，用一条直线将平面分成两部分。\n\n方程：\\(w \\cdot x + b = 0\\)\n\\(w\\): 法向量，决定超平面的方向，就像指南针 🧭 指引方向。\n\\(b\\): 位移项，决定超平面与原点之间的距离，就像调整刀 🔪 的位置。\n\n函数间隔 (Functional Margin): \\(\\gamma' = y(w \\cdot x + b)\\)\n\n\\(y\\): 样本的真实类别 (+1 或 -1)，就像标签 🏷️。\n\\(w \\cdot x + b\\): 样本点到超平面的“距离”，就像测量距离 📏。\n函数间隔的符号表示分类是否正确，大小表示确信度，就像考试分数 💯，越高越好。\n\n几何间隔 (Geometric Margin): \\(\\gamma = \\frac{y(w \\cdot x + b)}{||w||_2}\\)\n\n几何间隔是点到超平面的真实距离，就像用尺子 📏 测量距离。\n\\(||w||_2\\): 向量 \\(w\\) 的 L2 范数（模长），就像计算向量的长度。\n支持向量 (Support Vectors): 距离超平面最近的几个训练样本点，就像支撑起整个分类的士兵 💂‍♀️💂。\n\n\n\n\n支持向量的作用\n\n支持向量决定了超平面的位置和方向。\n只有支持向量对模型起作用，其他样本点可以被忽略。\n\n\n\nSVM 的优化目标 🎯\n\n目标: 最大化几何间隔，就像让苹果和橙子之间的距离最大。\n约束: 所有样本点都被正确分类，且位于支持向量定义的间隔之外，就像确保每个水果 🍏🍊 都被分到正确的类别。\n数学表达: \\[\n\\max_{\\mathbf{w}, b} \\frac{2}{\\|\\mathbf{w}\\|} \\\\\n\\text{s.t.} \\quad y_i(\\mathbf{w}^T\\mathbf{x}_i + b) \\geq 1, \\quad i=1,2,\\ldots,m.\n\\]\n对偶问题: 通过拉格朗日乘子法，可以将上述优化问题转化为对偶问题，更高效地求解，就像用更巧妙的方法解决问题。\n\n\n\nSVM 图示 🖼️\n\n\n\nSVM 图示\n\n\n\n实线: 超平面，就像刀 🔪。\n虚线: 间隔边界，就像安全线 🚧。\n圆圈和叉: 不同类别的样本，就像苹果 🍎 和橙子 🍊。\n带箭头的虚线: 支持向量到超平面的距离，就像测量距离 📏。\n\n图示解释 (1/4)\n\n实线: 这是我们希望找到的最优超平面，它能够将不同类别的样本分隔开。\n\n\n\n\nSVM 图示\n\n\n图示解释 (2/4)\n\n虚线: 这两条虚线是间隔边界，它们与超平面平行，并且距离超平面的距离相等。\n\n\n\n\nSVM 图示\n\n\n图示解释 (3/4)\n\n圆圈和叉: 这些是不同类别的样本点，我们的目标是将它们分隔开。\n\n\n\n\nSVM 图示\n\n\n图示解释 (4/4)\n\n带箭头的虚线: 这些虚线表示支持向量到超平面的距离，支持向量是距离超平面最近的样本点，它们决定了超平面的位置和方向。\n\n\n\n\nSVM 图示"
  },
  {
    "objectID": "qmd/chapter6.html#决策树-decision-tree",
    "href": "qmd/chapter6.html#决策树-decision-tree",
    "title": "信息技术基础 📊",
    "section": "决策树 (Decision Tree) 🌳",
    "text": "决策树 (Decision Tree) 🌳\n\n决策树的核心思想 💡\n\n决策树是一种树形结构，用于模拟人类的决策过程，就像一棵有许多分叉的树 🌳。\n通过一系列的问题 (特征)，对样本进行分类，就像玩“猜猜我是谁”的游戏 🕵️‍♀️。\n节点:\n\n内部节点: 表示一个特征或属性，就像一个问题 🤔。\n叶节点: 表示一个类别，就像一个答案 ✅。\n\n分支: 表示特征的取值，就像不同的选择 ➡️。\n\n\n\n决策树示例：信用卡申请 💳\n\n\n\n决策树示例\n\n\n\n问题: 是否批准信用卡申请？\n\n决策树示例：信用卡申请 💳 (1/5)\n\n根节点: 第一个问题是“年龄”，根据年龄将申请人分为不同的组。\n\n\n\n\n决策树示例\n\n\n决策树示例：信用卡申请 💳 (2/5)\n\n分支:\n\n如果年龄 &lt;= 30，进入左侧分支。\n如果年龄 &gt; 30，进入右侧分支。\n\n\n\n\n\n决策树示例\n\n\n决策树示例：信用卡申请 💳 (3/5)\n\n内部节点: 在左侧分支，下一个问题是“是否有房产”。\n\n\n\n\n决策树示例\n\n\n决策树示例：信用卡申请 💳 (4/5)\n\n内部节点: 在右侧分支，下一个问题是“是否有固定工作”。\n\n\n\n\n决策树示例\n\n\n决策树示例：信用卡申请 💳 (5/5)\n\n叶节点:\n\n“批准”：表示批准信用卡申请。\n“拒绝”：表示拒绝信用卡申请。\n\n\n\n\n\n决策树示例"
  },
  {
    "objectID": "qmd/chapter6.html#k-邻近-k-nearest-neighbors-knn",
    "href": "qmd/chapter6.html#k-邻近-k-nearest-neighbors-knn",
    "title": "信息技术基础 📊",
    "section": "K 邻近 (K-Nearest Neighbors, KNN) 🏘️",
    "text": "K 邻近 (K-Nearest Neighbors, KNN) 🏘️\n\nKNN 的工作机制 ⚙️\n\n给定测试样本，计算它与训练集中每个样本的距离，就像测量你和每个邻居 🧍🧍‍♀️ 的距离。\n找出距离最近的 k 个训练样本（k 个邻居），就像找到你最近的 k 个邻居。\n根据这 k 个邻居的类别，预测测试样本的类别。\n\n多数表决: 选择 k 个邻居中出现次数最多的类别，就像投票 🗳️ 选出最受欢迎的邻居。\n加权表决: 根据距离的远近，对 k 个邻居的投票进行加权，就像给更近的邻居更多的投票权 ⚖️。\n\n\n\n\nKNN 的关键因素 🤔\n\nk 值的选择:\n\nk 值过小，容易受噪声影响，就像只听一个邻居的意见，可能会被误导。\nk 值过大，容易受不相关样本影响，就像听太多人的意见，会变得犹豫不决。\n\n距离度量:\n\n欧氏距离 (Euclidean Distance)，就像直线距离 📏。\n曼哈顿距离 (Manhattan Distance)，就像城市街区距离 🏙️。\n其他距离度量。\n\n\n\n\nKNN 的特点 👍\n\n懒惰学习 (Lazy Learning): 无需训练，直接使用训练集进行预测，就像“临时抱佛脚” 📖。\n急切学习 (Eager Learning): 需要在训练阶段对样本进行处理，就像“未雨绸缪” ☔️。\n\n\n\nKNN 算法示例 🍎🍊\n假设我们有一些水果的数据，包括水果的重量和颜色，以及水果的种类（苹果或橙子）。\n\n\n\n重量 (克)\n颜色 (0-1)\n种类\n\n\n\n\n150\n0.8\n苹果\n\n\n180\n0.9\n苹果\n\n\n200\n0.5\n橙子\n\n\n220\n0.4\n橙子\n\n\n\n现在有一个新的水果，重量为 170 克，颜色为 0.7，我们想用 KNN 算法来预测它是苹果还是橙子。\n\n计算距离:\n\n假设我们使用欧氏距离：\n\n距离第 1 个样本：\\(\\sqrt{(170-150)^2 + (0.7-0.8)^2} \\approx 20.02\\)\n距离第 2 个样本：\\(\\sqrt{(170-180)^2 + (0.7-0.9)^2} \\approx 10.02\\)\n距离第 3 个样本：\\(\\sqrt{(170-200)^2 + (0.7-0.5)^2} \\approx 30.07\\)\n距离第 4 个样本：\\(\\sqrt{(170-220)^2 + (0.7-0.4)^2} \\approx 50.09\\)\n\n\n选择 k 值:\n\n假设我们选择 \\(k=3\\)，即选择最近的 3 个邻居。\n\n多数表决:\n\n最近的 3 个邻居是：第 2 个样本（苹果）、第 1 个样本（苹果）、第 3 个样本（橙子）。\n苹果的票数：2，橙子的票数：1。\n因此，预测新水果为苹果。"
  },
  {
    "objectID": "qmd/chapter6.html#朴素贝叶斯-naive-bayes",
    "href": "qmd/chapter6.html#朴素贝叶斯-naive-bayes",
    "title": "信息技术基础 📊",
    "section": "朴素贝叶斯 (Naive Bayes) 🍀",
    "text": "朴素贝叶斯 (Naive Bayes) 🍀\n\n贝叶斯定理 (Bayes’ Theorem) 🤓\n\\[\nP(B|A) = \\frac{P(A|B)P(B)}{P(A)}\n\\]\n\n\\(P(B|A)\\): 后验概率 (Posterior Probability)，就像在知道一些信息后，对事件发生的可能性的重新评估。\n\\(P(A|B)\\): 似然概率 (Likelihood)，就像事件发生后，观察到某些现象的可能性。\n\\(P(B)\\): 先验概率 (Prior Probability)，就像在没有任何信息的情况下，对事件发生的可能性的初步估计。\n\\(P(A)\\): 证据 (Evidence)，就像观察到的现象。\n\n\n\n贝叶斯定理：例子 🌰\n假设一个学校里有 60% 的男生和 40% 的女生。女生穿裤子和裙子的概率相等，都是 50%；男生都穿裤子。一个人在远处走来，我们只能看到他/她穿了一条裤子，求这个人是女生的概率。\n\n事件 A: 观察到穿裤子\n事件 B: 这个人是女生\n\\(P(B)\\): 女生的先验概率 (40%)\n\\(P(A)\\): 穿裤子的概率 (60% * 100% + 40% * 50% = 80%)\n\\(P(A|B)\\): 女生穿裤子的概率 (50%)\n\\(P(B|A)\\): 穿裤子的人是女生的概率 (根据贝叶斯定理计算)\n\n\\[\nP(B|A) = \\frac{P(A|B)P(B)}{P(A)} = \\frac{0.5 \\times 0.4}{0.8} = 0.25\n\\]\n\n\n朴素贝叶斯分类器 🤖\n\n生成模型: 学习特征 X 和类别 Y 的联合分布 P(X, Y)，就像先了解猫 🐱 和狗 🐶 的各种特征。\n预测: 计算条件概率 P(Y|X) = P(X, Y) / P(X)，就像根据观察到的特征，判断是猫还是狗。\n朴素 (Naive): 假设特征之间相互独立，就像认为猫的颜色和体重之间没有关系，这在现实中可能不成立，但可以让计算更简单。\n\n\n\n朴素贝叶斯分类器：例子 📧\n假设我们要判断一封邮件是否为垃圾邮件。\n\n特征：邮件中出现的词语（“免费”、“优惠”、“发票”等）\n类别：垃圾邮件、非垃圾邮件\n朴素假设：假设每个词语的出现都是独立的，即一个词语的出现与其他词语的出现无关。\n\n我们可以根据训练数据（已标注的垃圾邮件和非垃圾邮件）来计算：\n\n\\(P(Y)\\): 垃圾邮件和非垃圾邮件的先验概率\n\\(P(X|Y)\\): 在垃圾邮件和非垃圾邮件中，每个词语出现的概率\n\n然后，对于一封新的邮件，我们可以根据贝叶斯定理计算它是垃圾邮件的概率：\n\\[\nP(垃圾邮件|邮件内容) = \\frac{P(邮件内容|垃圾邮件)P(垃圾邮件)}{P(邮件内容)}\n\\]"
  },
  {
    "objectID": "qmd/chapter6.html#关联分析-association-analysis",
    "href": "qmd/chapter6.html#关联分析-association-analysis",
    "title": "信息技术基础 📊",
    "section": "关联分析 (Association Analysis) 🔗",
    "text": "关联分析 (Association Analysis) 🔗\n\n\n\n\n\n\nNote\n\n\n\n关联规则是描述数据库中数据项之间所存在的关系的规则，即根据一个事务中某些项的出现可导出另一些项在同一事务中也出现，即隐藏在数据间的关联或相互关系。\n关联分析就像侦探 🕵️‍♀️ 在犯罪现场寻找线索，发现不同物品之间的关联。\n\n\n\n关联分析的应用 🛒\n\n购物篮分析: 发现顾客购买商品之间的关联规则，例如著名的“啤酒与尿布” 🍺🧷 故事。\n\n超市发现，购买啤酒的顾客往往也会购买尿布，因此可以将啤酒和尿布放在一起促销。\n\n其他应用: 医疗诊断 🩺、网页浏览分析 🖱️、文本挖掘 📝 等。\n\n医疗诊断：发现某些症状与某种疾病之间的关联。\n网页浏览分析：发现用户经常同时访问的网页。\n文本挖掘：发现文章中经常同时出现的词语。\n\n\n\n\n关联规则的定义 🤓\n\n项集 (Itemset): 一组项目的集合，例如 {啤酒, 尿布}。\n\n项集可以是单个项目，也可以是多个项目的组合。\n\n事务 (Transaction): 一次购买记录，例如 {牛奶, 面包, 啤酒, 尿布}。\n\n事务是项集的集合。\n\n关联规则 (Association Rule): 形如 X → Y 的蕴含式，其中 X 和 Y 是不相交的项集。\n\n例如: {啤酒} → {尿布}\nX 称为前项 (antecedent)，Y 称为后项 (consequent)。\n\n\n\n\n关联规则的指标 📊\n\n支持度 (Support): 项集 X 和 Y 同时出现的概率。\n\n\\(Support(X \\to Y) = P(X \\cup Y)\\)\n就像计算同时购买啤酒和尿布的顾客比例。\n\n置信度 (Confidence): 在 X 出现的条件下，Y 出现的概率。\n\n\\(Confidence(X \\to Y) = P(Y|X) = \\frac{P(X \\cup Y)}{P(X)}\\)\n就像计算购买啤酒的顾客中，也购买尿布的比例。\n\n例子: 假设有 100 个顾客，其中：\n\n15 个顾客同时购买了啤酒和尿布。\n30 个顾客购买了啤酒。\n那么：\n\nSupport({啤酒} → {尿布}) = 15/100 = 15%\nConfidence({啤酒} → {尿布}) = 15/30 = 50%\n\n\n\n\n\n关联规则的指标 (续) 📈\n\n期望置信度 (Expected Confidence): Y 单独出现的概率。\n\n\\(Expected Confidence(X \\to Y) = P(Y)\\)\n就像计算所有顾客中，购买尿布的比例。\n\n提升度 (Lift): 置信度与期望置信度的比值。\n\n\\(Lift(X \\to Y) = \\frac{Confidence(X \\to Y)}{Expected Confidence(X \\to Y)} = \\frac{P(Y|X)}{P(Y)} = \\frac{P(X \\cup Y)}{P(X)P(Y)}\\)\n提升度反映了 X 的出现对 Y 的出现概率的影响程度，就像研究啤酒的出现是否会让尿布的销量增加。\nLift &gt; 1: 正相关，就像啤酒的出现会促进尿布的销量。\nLift = 1: 不相关，就像啤酒的出现对尿布的销量没有影响。\nLift &lt; 1: 负相关，就像啤酒的出现会抑制尿布的销量。\n\n例子 (续): 假设有 100 个顾客，其中：\n\n25 个顾客购买了尿布。\n那么：\n\nExpected Confidence({啤酒} → {尿布}) = 25/100 = 25%\nLift({啤酒} → {尿布}) = 50% / 25% = 2\n\n\n\n\n\n关联规则挖掘定义 ⛏️\n\n目标: 给定一个交易数据集 T，找出其中所有支持度 ≥ min_support 和置信度 ≥ min_confidence 的关联规则。\n\nmin_support: 最小支持度阈值\nmin_confidence: 最小置信度阈值\n\n步骤:\n\n生成频繁项集 (Frequent Itemset Generation): 找出所有满足最小支持度的项集，就像找到所有经常被一起购买的商品组合。\n生成规则 (Rule Generation): 在上一步产生的频繁项集的基础上生成满足最小置信度的规则，就像从经常被一起购买的商品组合中，找到那些具有强关联关系的组合。\n\n\n\n\n关联规则挖掘算法 ⚙️\n\nApriori 算法FP-Tree 算法 🌳PrefixSpan 算法\n\n\n\n核心思想: 基于两条定律，减少频繁项集的生成时间：\n\n如果一个项集是频繁的，则它的所有子集都是频繁的。就像如果 {啤酒, 尿布, 牛奶} 经常被一起购买，那么 {啤酒, 尿布} 也一定经常被一起购买。\n如果一个项集是非频繁的，则它的所有超集都是非频繁的。就像如果 {薯片} 很少被购买，那么 {薯片, 啤酒} 也一定很少被一起购买。\n\n例子:\n\n如果 {A, B} 是频繁项集，则 {A} 和 {B} 一定是频繁项集。\n如果 {A} 是非频繁项集，则 {A, B}, {A, C}, {A, B, C} 等一定是非频繁项集。\n\n\n\n\n\nFP-Tree (Frequent Pattern Tree): 一种树形数据结构，用于存储频繁项集的信息，就像一棵“购物树” 🌳，树上的每个节点都代表一个商品，节点之间的路径代表商品之间的关联。\n构建 FP-Tree:\n\n扫描数据集，统计每个项的支持度，就像统计每个商品的销量。\n根据支持度对项进行排序，就像将商品按照销量从高到低排序。\n再次扫描数据集，将每个事务中的项按照排序后的顺序插入到 FP-Tree 中，就像将每个顾客的购物清单 🛒 按照商品销量排序后，添加到“购物树”中。\n\n挖掘 FP-Tree: 从 FP-Tree 中递归地挖掘频繁项集，就像从“购物树”中找到那些经常出现的“树枝” 🌿。\n\n\n算法示例1\n 原始数据中，一共有10条交易数据，分别统计每个商品的支持度计数，A出现了8次，记为A:8，其他商品同理。\n\n\n算法示例1-解释\n这张图展示了FP-Tree算法的第一步：统计每个商品的支持度计数。\n\n原始数据: 左侧表格是原始的交易数据，每一行代表一次交易，包含了顾客购买的商品。\n支持度计数: 右侧表格是统计结果，显示了每个商品出现的次数（支持度计数）。\n例子:\n\nA: 8 表示商品A在所有交易中出现了8次。\nB: 6 表示商品B在所有交易中出现了6次。\n\n\n\n\n算法示例2\n 设置支持度阈值为20%，因为一共有10条交易数据，所以支持度计数至少为2，所以将支持度计数小于2的商品删除。\n\n\n算法示例2-解释\n这张图展示了FP-Tree算法的第二步：根据支持度阈值过滤商品。\n\n支持度阈值: 这里设置为20%，意味着只有出现次数达到总交易数20%的商品才会被保留。\n计算: 总共有10条交易数据，20%的支持度对应着至少出现2次。\n过滤: 支持度计数小于2的商品（如O、I、J、K、L、M、N、H）被删除。\n\n\n\n算法示例3\n 将每条交易数据中的商品按照支持度技术排序。 比如第一条交易数据ABCEFO，按照新的支持度表排序为ACEBF。其他交易数据同理。\n\n\n算法示例3-解释\n这张图展示了FP-Tree算法的第三步：对每条交易数据中的商品按照支持度计数排序。\n\n排序依据: 根据上一步过滤后的支持度计数表，对商品进行降序排列。\n例子:\n\n原始交易数据：ABCEFO\n排序后：ACEBF (A &gt; C &gt; E &gt; B &gt; F)\n\n\n\n\n算法示例4\n 将排序好的交易数据添加到FP树中。 第一条数据ACEBF，则创建A:1, C:1, E:1, B:1, F:1的FP树分支。 第二条数据ACG，创建单独的A:1, C:1, G:1分支。 以此类推。\n\n\n算法示例4-解释\n这张图展示了FP-Tree算法的第四步：开始构建FP-Tree。\n\n插入规则:\n\n从根节点开始，按照排序后的交易数据顺序插入商品。\n如果FP-Tree中已存在相同的商品节点，则增加该节点的计数。\n如果不存在相同的商品节点，则创建新的节点。\n\n例子:\n\n第一条数据 ACEBF：创建 A:1 -&gt; C:1 -&gt; E:1 -&gt; B:1 -&gt; F:1 的分支。\n第二条数据 ACG：创建 A:1 -&gt; C:1 -&gt; G:1 的分支。\n\n\n\n\n算法示例5\n 当插入第四条交易数据ACEGD时，发现可以与第二条数据ACG共享A:1, C:1的前缀，所以形成A:2, C:2, G:1, E:1, D:1的分支。 以此类推。\n\n\n算法示例5-解释\n这张图展示了FP-Tree算法的第五步：继续构建FP-Tree，合并共享前缀。\n\n合并规则:\n\n如果新插入的交易数据与FP-Tree中已有的分支有相同的前缀，则共享这些前缀节点，并增加节点的计数。\n\n例子:\n\n第四条数据 ACEGD：与第二条数据 ACG 共享前缀 A 和 C，因此 A 和 C 的计数增加到 2，形成 A:2 -&gt; C:2 -&gt; G:1 -&gt; E:1 -&gt; D:1 的分支。\n\n\n\n\n算法示例6\n\n\n\nFP-Tree 示例 6\n\n\n构建好的FP树。 挖掘FP-Tree：从FP-Tree中递归地挖掘频繁项集，比如以D为条件，找到D的条件模式基为&lt;A:2, C:2&gt;，这意味着在所有交易数据中，D和AC同时出现的次数为2次。其他商品同理。\n\n\n算法示例6-解释\n这张图展示了最终构建好的FP-Tree，以及如何从中挖掘频繁项集。\n\nFP-Tree:\n\n根节点通常为空。\n每个节点表示一个商品，节点上的数字表示该商品在路径中出现的次数。\n具有相同前缀的路径会被合并。\n\n挖掘频繁项集:\n\n从FP-Tree的叶子节点开始，递归地向上查找其条件模式基（conditional pattern base）。\n条件模式基是指以该节点为结尾的所有前缀路径。\n例如，以 D 为条件，找到 D 的条件模式基为 &lt;A:2, C:2&gt;，这意味着在所有交易数据中，D 和 AC 同时出现的次数为 2 次。\n\n\n\n\n\n\nPrefixSpan (Prefix-Projected Pattern Growth): 一种挖掘频繁序列的算法。\n序列 (Sequence): 一组有序的项集，例如 &lt;(AB)(AC)D(CF)&gt;，就像顾客按时间顺序购买的商品列表。\n子序列 (Subsequence): 如果序列 A 的所有项集都能在序列 B 的项集中找到，则 A 是 B 的子序列，就像顾客购买了商品列表 A 中的所有商品，那么 A 就是 B 的子序列。\n前缀 (Prefix) 和 后缀 (Suffix):\n\n例如，序列 &lt;a(abc)(ac)d(cf)&gt; 的前缀和后缀例子：\n\n\n\n\n\n前缀\n后缀 (前缀投影)\n\n\n\n\n&lt;&gt;\n&lt;(abc)(ac)d(cf)&gt;\n\n\n&lt;&gt;\n&lt;(_bc)(ac)d(cf)&gt;\n\n\n&lt;&gt;\n&lt;(_c)(ac)d(cf)&gt;\n\n\n\n\nPrefixSpan算法步骤\n\n输入: 序列数据集S和支持度阈值α\n输出: 所有满足支持度要求的频繁序列集\n找出所有长度为1的前缀和对应的投影数据库\n对长度为1的前缀进行计数,将支持度低于阈值α的前缀对应的项从数据集S删除,同时得到所有的频繁1项序列, i=1.\n对于每个长度为i满足支持度要求的前缀进行递归挖掘:\n\n找出前缀所对应的投影数据库。如果投影数据库为空,则递归返回。\n统计对应投影数据库中各项的支持度计数。如果所有项的支持度计数都低于阈值, 则递归返回。\n将满足支持度计数的各个单项和当前的前缀进行合并, 得到若干新的前缀\n令i=i+1, 前缀为合并单项后的各个前缀, 分别递归执行第3步。"
  },
  {
    "objectID": "qmd/chapter6.html#聚类分析-cluster-analysis",
    "href": "qmd/chapter6.html#聚类分析-cluster-analysis",
    "title": "信息技术基础 📊",
    "section": "聚类分析 (Cluster Analysis) 🤝",
    "text": "聚类分析 (Cluster Analysis) 🤝\n\n\n\n\n\n\nNote\n\n\n\n聚类分析是典型的无监督学习任务，训练样本的标签信息未知，通过对无标签样本的学习揭示数据内在性质及规律，这个规律通常是样本间相似性的规律。\n聚类分析就像将不同的水果 🍎🍊🍌🍇 按照种类放在不同的篮子里 🧺。\n\n\n\n聚类分析的目标 🎯\n\n将一组数据按照相似性和差异性分为几个类别。\n使得：\n\n同一类别内的数据相似性尽可能大，就像让同一品种的水果 🍎🍎 放在一起。\n不同类别间的数据相似性尽可能小，就像让不同品种的水果 🍎🍊 分开。\n\n\n\n\n聚类分析的应用 🏘️\n\n市场细分: 将顾客划分为不同的群体，以便进行精准营销，就像将顾客按照年龄、收入等特征分成不同的群体。\n\n针对不同群体制定不同的营销策略。\n\n图像分割: 将图像分割成不同的区域，以便进行目标识别，就像将照片中的天空 ☁️、树木 🌳、人物 🧍‍♀️ 分割开来。\n\n自动驾驶汽车识别道路、行人、车辆等。\n\n异常检测: 发现数据中的异常点，例如信用卡欺诈 💳🚫，就像找出不正常的交易记录。\n\n银行检测信用卡欺诈交易。\n\n\n\n\n聚类分析的特点 🤔\n\n无监督学习: 无需标签信息，就像在没有标签的情况下，将水果 🍎🍊🍌🍇 分类。\n探索性分析: 发现数据中潜在的规律，就像探索未知的领域 🗺️。\n结果解释: 需要对聚类结果进行解释，赋予其语义，就像给每个水果篮子 🧺 贴上标签 🏷️。\n\n\n\n聚类分析算法 ⚙️\n\nK-均值算法 (K-Means)DBSCAN 算法\n\n\n\n原理: 将样本划分到 k 个簇中，使得每个样本到其所属簇的中心的距离之和最小，就像将学生 🧑‍🎓 分到 k 个班级 🏫，使得每个学生到班级中心的距离之和最小。\n步骤:\n\n随机选取 k 个聚类中心，就像随机选择 k 个班长 🙋‍♀️🙋‍♂️。\n重复以下过程，直到收敛：\n\n对于每个样本，计算其所属的类别（距离最近的中心），就像让每个学生选择离自己最近的班级。\n对于每个类别，重新计算聚类中心（该类别所有样本的均值），就像重新选举班长，选出班级的平均位置。\n\n\n缺点:\n\n需要预先指定 k 值，就像需要预先确定班级的数量，这在实际中可能很难确定。\n对初始聚类中心敏感，就像不同的班长人选可能会导致不同的分班结果。\n对噪声和离群点敏感，就像个别学生的特殊情况可能会影响分班结果。\n可能陷入局部最优，就像分班结果可能不是最佳的。\n\n公式\n\n距离和E: \\[\nE = \\sum_{i=1}^{k}\\sum_{x \\in C_i}||x - \\mu_i||_2^2\n  \\] 其中\\(\\mu_i\\)是簇\\(C_i\\)的均值向量, 即： \\[\n\\mu_i = \\frac{1}{|C_i|} \\sum_{x \\in C_i}x\n\\]\n\n\n\n\n\nDBSCAN (Density-Based Spatial Clustering of Applications with Noise): 一种基于密度的聚类算法，就像根据人群的密度 🧑‍🤝‍🧑 来划分不同的区域。\n核心思想: 将具有足够密度的区域划分为簇，并发现任意形状的簇，就像找出人群聚集的区域。\n关键概念:\n\nEps 邻域: 以点 p 为中心，半径为 Eps 的区域，就像以你为中心，画一个半径为 Eps 的圆 ⭕。\nMinPts: 给定的密度阈值，就像规定一个区域内至少有多少人 👨‍👩‍👧‍👦 才能算作人群聚集。\n核心对象 (Core Object): Eps 邻域内包含至少 MinPts 个点的点，就像人群中的核心人物 😎。\n直接密度可达 (Directly Density-Reachable): 如果点 p 在点 q 的 Eps 邻域内，且 q 是核心对象，则 p 从 q 直接密度可达，就像你和一个核心人物 😎 在同一个圈子里。\n密度可达 (Density-Reachable): 如果存在一系列点，使得每个点从前一个点直接密度可达，则最后一个点从第一个点密度可达，就像你通过一系列朋友 🤝 认识了一个名人 🌟。\n密度相连 (Density-Connected): 如果两个点都从同一个点密度可达，则这两个点密度相连，就像你和另一个人都通过朋友 🤝 认识了同一个名人 🌟。\n\n步骤:\n\n检查每个点的 Eps 邻域。\n如果一个点的 Eps 邻域包含的点数多于 MinPts，则创建一个以该点为核心对象的新簇。\n迭代地聚集从核心对象直接密度可达的对象。\n当没有新的点添加到任何簇时，过程结束。\n\n优点:\n\n无需预先指定簇的数量，就像不需要事先知道有多少个人群聚集区。\n可以发现任意形状的簇，就像可以找出各种形状的人群聚集区 🚶‍♀️🚶‍♂️🧍🧍‍♀️。\n对噪声不敏感，就像可以忽略那些离群的独行侠 👤。\n\n缺点:\n\n对参数 Eps 和 MinPts 敏感，就像半径 Eps 和人数阈值 MinPts 的设置会影响聚类结果。\n当数据密度不均匀时，聚类效果较差，就像人群密度差异很大时，很难确定合适的半径和人数阈值。\n对于高维数据，存在“维度灾难” 😨，就像在高维空间中，很难定义“距离”和“密度”。"
  },
  {
    "objectID": "qmd/chapter6.html#回归分析-regression-analysis",
    "href": "qmd/chapter6.html#回归分析-regression-analysis",
    "title": "信息技术基础 📊",
    "section": "回归分析 (Regression Analysis) 📈",
    "text": "回归分析 (Regression Analysis) 📈\n\n\n\n\n\n\nNote\n\n\n\n回归分析方法反映的是事务数据库中属性值在时间上的特征,产生一个将数据项映射到一个实值预测变量的函数,发现变量或属性间的依赖关系,其主要研究问题包括数据序列的趋势特征、数据序列的预测以及数据间的相关关系等。\n回归分析就像根据过去的天气数据 🌤️🌧️🌈 来预测明天的天气 ☔。\n\n\n\n回归分析的目标 🎯\n\n研究变量之间的相关关系，就像研究身高和体重之间的关系。\n\n身高越高，体重通常越重。\n\n建立数学模型进行预测，就像建立一个公式，根据身高来预测体重。\n\n体重 = a * 身高 + b\n\n\n\n\n回归分析与分类 📊\n\n相似之处: 都是监督学习问题，就像都需要有标签的数据 🏷️ 来进行学习。\n区别:\n\n分类: 预测离散的类别标签，就像判断一张图片是猫 🐱 还是狗 🐶。\n\n输出是类别（离散值）。\n\n回归: 预测连续的目标值，就像预测明天的气温 🌡️。\n\n输出是数值（连续值）。\n\n\n\n\n\n常见的回归分析模型 ⚙️\n\n线性回归分析 (Linear Regression)支持向量回归 (Support Vector Regression, SVR) 🛡️K 邻近回归 (K-Nearest Neighbors Regression) 🏘️\n\n\n\n原理: 用线性模型刻画特征向量 X 与回归目标 y 之间的关系，就像用一条直线 📏 来拟合身高和体重之间的关系。\n模型:\n\n\\(f(x_i) = w_1x_{i1} + w_2x_{i2} + ... + w_nx_{in} + b\\), 使得 \\(f(x_i) \\approx y_i\\)\n就像找到一条直线，使得直线上的点尽可能接近真实的数据点。\n\n损失函数:\n\n\\(L(w, b) = \\sum_{i=1}^{m}(y_i - w^Tx_i - b)^2\\)\n就像计算每个数据点到直线的距离的平方和，然后最小化这个和。\n\n求解: 最小二乘法 (Least Squares Method)，就像找到一条“最佳拟合”直线。\n广义线性模型 (Generalized Linear Model): 引入非线性函数 g，使得 y 和 f(x) 之间存在非线性关系，就像用曲线 〰️ 来拟合数据。\n\n\\(y_i = g^{-1}(w^Tx_i + b)\\)\ng: 联系函数 (Link Function)，就像一个“桥梁” 🌉，连接线性模型和非线性模型。\n\n\n\n\n\n原理: 允许预测值 f(x) 和真实值 y 之间存在一定的偏差 (容忍度 ε)，就像允许预测的气温和真实气温之间存在一定的误差。\n核心思想: 构建一个宽度为 2ε 的间隔带，落入间隔带内的样本被认为预测正确，就像在真实气温周围画一个“安全区” 🚧。\n\n\n\n\n原理: 类似于 K 邻近分类，找到 k 个最近邻居，将这些邻居的回归目标的平均值作为预测值，就像根据你周围邻居的身高，来预测你的身高。\n加权平均: 可以根据距离的远近，对邻居的回归目标进行加权平均，就像给更近的邻居更大的权重。"
  },
  {
    "objectID": "qmd/chapter6.html#总结",
    "href": "qmd/chapter6.html#总结",
    "title": "信息技术基础 📊",
    "section": "总结 🎉",
    "text": "总结 🎉\n本章我们学习了数据分析和知识发现的几种常用方法，就像打开了一个工具箱 🧰，里面装满了各种神奇的工具：\n\n分类分析 📦：将数据对象划分到不同的类别中，就像整理房间一样。\n关联分析 🔗：发现数据项之间的关联规则，就像侦探 🕵️‍♀️ 发现线索。\n聚类分析 🤝：将数据对象分成不同的簇，使得同一簇内的对象相似度高，不同簇之间的对象相似度低，就像朋友们聚会 🥳。\n回归分析 📈：研究变量之间的关系，并建立模型进行预测，就像天气预报 🌤️。\n\n这些方法在实际应用中非常广泛，可以帮助我们从数据中提取有价值的信息，并将其转化为知识，为决策提供支持。"
  },
  {
    "objectID": "qmd/chapter6.html#思考与讨论",
    "href": "qmd/chapter6.html#思考与讨论",
    "title": "信息技术基础 📊",
    "section": "思考与讨论 🤔",
    "text": "思考与讨论 🤔\n\n你之前是否接触过这些方法？在什么场景下接触到的呢？\n你认为这些方法有哪些应用场景？你能举出一些具体的例子吗？\n你认为这些方法的优缺点是什么？在实际应用中需要注意哪些问题？\n你觉得还有什么需要补充的地方吗？\n结合本章学习的内容，谈谈你在日常生活、学习和未来的工作中如何运用这些知识？\n你在金融领域有自己感兴趣的方向吗？这些知识和技能对你有什么帮助？"
  }
]