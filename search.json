[
  {
    "objectID": "qmd/pandas3ed1.html",
    "href": "qmd/pandas3ed1.html",
    "title": "one",
    "section": "",
    "text": "one\n\n\ntwo"
  },
  {
    "objectID": "qmd/pandas3ed4.html",
    "href": "qmd/pandas3ed4.html",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "",
    "text": "NumPy, short for Numerical Python, is a foundational package for numerical computing in Python.\n\nWhy is it important? üßê Many scientific computing packages rely on NumPy‚Äôs array objects for data exchange. Think of it as the lingua franca (common language) of data analysis in Python.\nIt is designed for efficiency on large arrays of data.\nWhat will we learn? We‚Äôll cover the basics, focusing on how NumPy enables fast, array-oriented operations, which are crucial for data analysis with libraries like pandas."
  },
  {
    "objectID": "qmd/pandas3ed4.html#introduction-to-numpy",
    "href": "qmd/pandas3ed4.html#introduction-to-numpy",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "",
    "text": "NumPy, short for Numerical Python, is a foundational package for numerical computing in Python.\n\nWhy is it important? üßê Many scientific computing packages rely on NumPy‚Äôs array objects for data exchange. Think of it as the lingua franca (common language) of data analysis in Python.\nIt is designed for efficiency on large arrays of data.\nWhat will we learn? We‚Äôll cover the basics, focusing on how NumPy enables fast, array-oriented operations, which are crucial for data analysis with libraries like pandas."
  },
  {
    "objectID": "qmd/pandas3ed4.html#key-features-of-numpy",
    "href": "qmd/pandas3ed4.html#key-features-of-numpy",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Key Features of NumPy",
    "text": "Key Features of NumPy\n\nHere‚Äôs a glimpse of what NumPy offers:\n\nndarray: The heart of NumPy. A highly efficient multidimensional array. Imagine a container holding data of the same type (e.g., all numbers). It allows for fast operations and broadcasting (we‚Äôll cover this later!).\nMathematical Functions: A rich set of functions that operate on entire arrays without explicit loops. This is called vectorization, and it‚Äôs much faster than writing loops in Python.\nData I/O: Tools to read and write array data to disk.\nLinear Algebra: Capabilities for linear algebra, random number generation, and Fourier transforms. Essential tools for many scientific and engineering tasks.\nC API: Allows seamless integration with libraries written in C, C++, or FORTRAN. This is key for leveraging high-performance legacy code."
  },
  {
    "objectID": "qmd/pandas3ed4.html#why-numpy-is-efficient",
    "href": "qmd/pandas3ed4.html#why-numpy-is-efficient",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Why NumPy is Efficient?",
    "text": "Why NumPy is Efficient?\n\nNumPy‚Äôs efficiency stems from several design choices:\n\nContiguous Memory: Unlike Python lists, NumPy arrays store data in a single, contiguous block of memory. This makes accessing and manipulating data much faster.\nC-Based Algorithms: Many NumPy operations are implemented in C, avoiding the overhead of Python‚Äôs interpreter.\nLess Memory Usage: NumPy arrays generally consume less memory than Python lists, especially for numerical data."
  },
  {
    "objectID": "qmd/pandas3ed4.html#numpy-vs.-python-lists-a-performance-showdown",
    "href": "qmd/pandas3ed4.html#numpy-vs.-python-lists-a-performance-showdown",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "NumPy vs.¬†Python Lists: A Performance Showdown üèÉ‚Äç‚ôÇÔ∏è",
    "text": "NumPy vs.¬†Python Lists: A Performance Showdown üèÉ‚Äç‚ôÇÔ∏è\n\nLet‚Äôs see NumPy‚Äôs speed advantage in action. We‚Äôll compare multiplying a million integers by 2 using both a NumPy array and a Python list:\n\nimport numpy as np\nmy_arr = np.arange(1_000_000)  # NumPy array\nmy_list = list(range(1_000_000)) # Python list\n\nNow, the timed operations:\n\n# NumPy array operation\n# %timeit my_arr2 = my_arr * 2\n\n\n# Python list operation (using a list comprehension)\n# %timeit my_list2 = [x * 2 for x in my_list]\n\n\n\n\n\n\n\n\nNumPy-based algorithms are generally 10 to 100 times faster (or more) than their pure Python counterparts and use significantly less memory."
  },
  {
    "objectID": "qmd/pandas3ed4.html#the-numpy-ndarray-a-closer-look",
    "href": "qmd/pandas3ed4.html#the-numpy-ndarray-a-closer-look",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "The NumPy ndarray: A Closer Look",
    "text": "The NumPy ndarray: A Closer Look\n\nThe ndarray (N-dimensional array) is the core data structure in NumPy.\n\nHomogeneous Data: All elements in an ndarray must be of the same data type (e.g., all integers, all floats).\nKey Attributes:\n\nshape: A tuple indicating the size of each dimension. For a 2x3 array, the shape would be (2, 3).\ndtype: An object describing the data type of the elements (e.g., int64, float32).\n\nCreating ndarray The easiest way to create an array is to use the array function. This accepts any sequence-like object (including other arrays) and produces a new NumPy array containing the passed data."
  },
  {
    "objectID": "qmd/pandas3ed4.html#creating-ndarrays-examples",
    "href": "qmd/pandas3ed4.html#creating-ndarrays-examples",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Creating ndarrays: Examples",
    "text": "Creating ndarrays: Examples\n\nLet‚Äôs create some arrays:\n\nimport numpy as np\n\n# From a list\ndata1 = [6, 7.5, 8, 0, 1]\narr1 = np.array(data1)\nprint(arr1)\nprint(arr1.dtype)\n\n[6.  7.5 8.  0.  1. ]\nfloat64\n\n\n\n# From a nested list (creates a 2D array)\ndata2 = [[1, 2, 3, 4], [5, 6, 7, 8]]\narr2 = np.array(data2)\nprint(arr2)\nprint(arr2.ndim)  # Number of dimensions\nprint(arr2.shape)\nprint(arr2.dtype)\n\n[[1 2 3 4]\n [5 6 7 8]]\n2\n(2, 4)\nint32"
  },
  {
    "objectID": "qmd/pandas3ed4.html#array-creation-functions",
    "href": "qmd/pandas3ed4.html#array-creation-functions",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Array Creation Functions",
    "text": "Array Creation Functions\n\nNumPy provides several convenient functions to create arrays:\n\n# Array of zeros\nzeros_arr = np.zeros(10)  # 1D array\nprint(zeros_arr)\n\nzeros_arr_2d = np.zeros((3, 6)) # 2D array (3x6)\nprint(zeros_arr_2d)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n\n\n\n# Array of ones\nones_arr = np.ones((2, 3)) # 2D array (2x3)\nprint(ones_arr)\n\n[[1. 1. 1.]\n [1. 1. 1.]]\n\n\n\n# Uninitialized array (may contain garbage values)\nempty_arr = np.empty((2, 3, 2)) # 3D array\nprint(empty_arr)\n\n[[[1.38814909e-311 3.16202013e-322]\n  [0.00000000e+000 0.00000000e+000]\n  [5.96314381e-096 1.42320827e+160]]\n\n [[4.69610055e-033 2.21559062e-056]\n  [6.82245542e-038 6.93790501e+169]\n  [1.85357951e-051 4.39272680e+175]]]\n\n\n\n#  'arange': Similar to Python's 'range', but returns an ndarray\nrange_arr = np.arange(15)\nprint(range_arr)\n\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#summary-of-array-creation-functions",
    "href": "qmd/pandas3ed4.html#summary-of-array-creation-functions",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Summary of Array Creation Functions",
    "text": "Summary of Array Creation Functions\n\nA handy table summarizing common array creation functions:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\narray\nConverts input data (list, tuple, array, etc.) to an ndarray.\n\n\nasarray\nSimilar to array, but does not copy if the input is already an ndarray.\n\n\narange\nLike Python‚Äôs range, but returns an ndarray.\n\n\nones, ones_like\nCreates an array filled with 1s. ones_like takes another array and creates a ones array of the same shape and dtype.\n\n\nzeros, zeros_like\nSimilar to ones and ones_like, but creates arrays filled with 0s.\n\n\nempty, empty_like\nCreates an array without initializing its values. Use with caution!\n\n\nfull, full_like\nCreates an array filled with a specified value. full_like takes another array and uses its shape and dtype.\n\n\neye, identity\nCreates a square identity matrix (1s on the diagonal, 0s elsewhere)."
  },
  {
    "objectID": "qmd/pandas3ed4.html#data-types-dtypes",
    "href": "qmd/pandas3ed4.html#data-types-dtypes",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Data Types (dtypes)",
    "text": "Data Types (dtypes)\n\n\nWhat is a dtype? A special object that contains information about the data type held by an ndarray (e.g., float64, int32, bool).\nWhy are dtypes important? They give you fine-grained control over how data is stored in memory. This is crucial for performance, especially with large datasets. They also allow NumPy to interface with data from other systems (like databases or files written in C/C++).\nSpecifying dtypes:\n\n\narr1 = np.array([1, 2, 3], dtype=np.float64)  # Explicitly set dtype\narr2 = np.array([1, 2, 3], dtype=np.int32)\nprint(arr1.dtype)\nprint(arr2.dtype)\n\nfloat64\nint32"
  },
  {
    "objectID": "qmd/pandas3ed4.html#common-numpy-data-types",
    "href": "qmd/pandas3ed4.html#common-numpy-data-types",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Common NumPy Data Types",
    "text": "Common NumPy Data Types\n\n\n\n\n\n\n\n\n\nType\nType Code\nDescription\n\n\n\n\nint8, uint8\ni1, u1\nSigned and unsigned 8-bit (1 byte) integer types\n\n\nint16, uint16\ni2, u2\nSigned and unsigned 16-bit integer types\n\n\nint32, uint32\ni4, u4\nSigned and unsigned 32-bit integer types\n\n\nint64, uint64\ni8, u8\nSigned and unsigned 64-bit integer types\n\n\nfloat16\nf2\nHalf-precision floating point\n\n\nfloat32\nf4 or f\nStandard single-precision floating point; compatible with C float\n\n\nfloat64\nf8 or d\nStandard double-precision floating point; compatible with C double and Python float\n\n\nfloat128\nf16 or g\nExtended-precision floating point\n\n\ncomplex64, complex128, complex256\nc8, c16, c32\nComplex numbers represented by two 32, 64, or 128 floats, respectively\n\n\nbool\n?\nBoolean type storing True and False values\n\n\nobject\nO\nPython object type; a value can be any Python object\n\n\nstring_\nS\nFixed-length ASCII string type (1 byte per character). Use S10 for a string of length 10.\n\n\nunicode_\nU\nFixed-length Unicode type (number of bytes platform-specific)\n\n\n\n\n\n\n\n\n\n\nThere are both signed and unsigned integer types. A signed integer can represent both positive and negative integers, while an unsigned integer can only represent non-zero integers."
  },
  {
    "objectID": "qmd/pandas3ed4.html#casting-with-astype",
    "href": "qmd/pandas3ed4.html#casting-with-astype",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Casting with astype",
    "text": "Casting with astype\n\n\nWhat is casting? Converting an array from one dtype to another.\nHow to cast: Use the astype method. astype always creates a new array (a copy of the data), even if the new dtype is the same as the old dtype.\n\n\narr = np.array([1, 2, 3, 4, 5])\nprint(arr.dtype)\nfloat_arr = arr.astype(np.float64) # Integer to float\nprint(float_arr.dtype)\n\nint32\nfloat64\n\n\n\nnumeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)\nfloat_arr = numeric_strings.astype(float) # String to float\nprint(float_arr)\n\n[ 1.25 -9.6  42.  ]\n\n\n\n\n\n\n\n\nBe cautious when using the numpy.string_ type, as string data in NumPy is fixed size and may truncate input without warning. pandas has more intuitive out-of-the-box behavior on non-numeric data."
  },
  {
    "objectID": "qmd/pandas3ed4.html#arithmetic-with-numpy-arrays-vectorization",
    "href": "qmd/pandas3ed4.html#arithmetic-with-numpy-arrays-vectorization",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Arithmetic with NumPy Arrays: Vectorization",
    "text": "Arithmetic with NumPy Arrays: Vectorization\n\n\nVectorization: A core concept in NumPy. It means performing operations on entire arrays without writing explicit for loops. This is much faster and more concise.\nElement-wise Operations: Arithmetic operations between equal-sized arrays are applied element-wise:\n\n\narr = np.array([[1., 2., 3.], [4., 5., 6.]])\nprint(arr * arr) # Element-wise multiplication\nprint(arr - arr) # Element-wise subtraction\n\n[[ 1.  4.  9.]\n [16. 25. 36.]]\n[[0. 0. 0.]\n [0. 0. 0.]]\n\n\n\nOperations with Scalars: Arithmetic operations with scalars propagate the scalar value to each element in the array:\n\n\nprint(1 / arr)   # Divide each element by 1\nprint(arr ** 2) # Square each element\n\n[[1.         0.5        0.33333333]\n [0.25       0.2        0.16666667]]\n[[ 1.  4.  9.]\n [16. 25. 36.]]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#broadcasting-brief-introduction",
    "href": "qmd/pandas3ed4.html#broadcasting-brief-introduction",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Broadcasting (Brief Introduction)",
    "text": "Broadcasting (Brief Introduction)\n\n\nWhat is broadcasting? A powerful mechanism that allows NumPy to perform arithmetic operations on arrays of different shapes, under certain conditions.\nExample: You can add a scalar to an array of any shape. The scalar is effectively ‚Äústretched‚Äù to match the array‚Äôs shape.\nWe‚Äôll cover broadcasting in more detail later. For now, just be aware that it exists and is a key reason why NumPy is so flexible."
  },
  {
    "objectID": "qmd/pandas3ed4.html#basic-indexing-and-slicing",
    "href": "qmd/pandas3ed4.html#basic-indexing-and-slicing",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Basic Indexing and Slicing",
    "text": "Basic Indexing and Slicing\n\n\nSimilar to Python Lists: One-dimensional NumPy arrays can be indexed and sliced much like Python lists:\n\n\narr = np.arange(10)\nprint(arr[5])      # Access element at index 5\nprint(arr[5:8])    # Slice elements from index 5 up to (but not including) 8\narr[5:8] = 12     # Assign a value to a slice\nprint(arr)\n\n5\n[5 6 7]\n[ 0  1  2  3  4 12 12 12  8  9]\n\n\n\nViews vs.¬†Copies: Array slices are views on the original array. This means that modifying a slice will modify the original array. This is different from Python lists, where slices create copies.\n\n\narr_slice = arr[5:8]\narr_slice[1] = 12345  # Modify the slice\nprint(arr)          # Original array is also modified!\n\n[    0     1     2     3     4    12 12345    12     8     9]\n\n\n\n\n\n\n\n\n\nIf you want a copy of a slice of an ndarray instead of a view, you will need to explicitly copy the array‚Äîfor example, arr[5:8].copy()."
  },
  {
    "objectID": "qmd/pandas3ed4.html#indexing-and-slicing-higher-dimensions",
    "href": "qmd/pandas3ed4.html#indexing-and-slicing-higher-dimensions",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Indexing and Slicing: Higher Dimensions",
    "text": "Indexing and Slicing: Higher Dimensions\n\n\nTwo-Dimensional Arrays: You can access elements using comma-separated indices:\n\n\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d[2])     # Access the third row (index 2)\nprint(arr2d[0][2])  # Access element at row 0, column 2 (two ways)\nprint(arr2d[0, 2])   # Access element at row 0, column 2\n\n[7 8 9]\n3\n3\n\n\n\nThinking about Axes:\n\nAxis 0: Rows\nAxis 1: Columns"
  },
  {
    "objectID": "qmd/pandas3ed4.html#indexing-elements-in-a-numpy-array.",
    "href": "qmd/pandas3ed4.html#indexing-elements-in-a-numpy-array.",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Indexing elements in a NumPy array.",
    "text": "Indexing elements in a NumPy array.\n\n\n\n\n\n\ngraph LR\n    subgraph \"Axis 0 (Rows)\"\n        0 --&gt; 1\n        1 --&gt; 2\n    end\n    subgraph \"Axis 1 (Columns)\"\n        0 --&gt; 0[0,0]\n        0 --&gt; 1[0,1]\n        0 --&gt; 2[0,2]\n        1 --&gt; 3[1,0]\n        1 --&gt; 4[1,1]\n        1 --&gt; 5[1,2]\n        2 --&gt; 6[2,0]\n        2 --&gt; 7[2,1]\n        2 --&gt; 8[2,2]\n    end"
  },
  {
    "objectID": "qmd/pandas3ed4.html#indexing-and-slicing-higher-dimensions-continued",
    "href": "qmd/pandas3ed4.html#indexing-and-slicing-higher-dimensions-continued",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Indexing and Slicing: Higher Dimensions (Continued)",
    "text": "Indexing and Slicing: Higher Dimensions (Continued)\n\n\nSlicing in Multiple Dimensions:\n\n\nprint(arr2d[:2])      # Select the first two rows\nprint(arr2d[:2, 1:])   # Select first two rows, columns from index 1 onwards\n\n[[1 2 3]\n [4 5 6]]\n[[2 3]\n [5 6]]\n\n\n\nMixing Integer Indexing and Slicing:\n\n\nprint(arr2d[1, :2])   # Select second row, first two columns (lower dimensional slice)\nprint(arr2d[:2, 2])    # Select first two rows, third column\n\n[4 5]\n[3 6]\n\n\n\nColon for Entire Axis:\n\n\nprint(arr2d[:, :1])   # Select all rows, but only the first column\n\n[[1]\n [4]\n [7]]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#two-dimensional-array-slicing",
    "href": "qmd/pandas3ed4.html#two-dimensional-array-slicing",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Two-dimensional array slicing",
    "text": "Two-dimensional array slicing\n\n\n\n\n\n\n\n\n\nExpression\nShape\nVisualization\n\n\n\n\narr[:2,1:]\n(2,2)\n```{python}\n\n\n#\necho: false\n\n\n\n\nimport matplotlib.pyplot as plt import numpy as np\narr = np.zeros((3,3)) arr[:2,1:] = 1 plt.imshow(arr, cmap=‚Äògray_r‚Äô) plt.xticks([]) plt.yticks([]) plt.show()\n| `arr[2]`          |    (3,)      |  ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[2,:] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```    |\n| `arr[2,:]`          |    (3,)      |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[2,:] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[2:,:]`          |     (1,3)     |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[2:,:] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[:, :2]`          |   (3,2)       |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[:,:2] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[1, :2]`          |     (2,)     |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[1,:2] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[1:2, :2]`          |  (1,2)        |  ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[1:2,:2] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```    |\n:::\n\n## Boolean Indexing\n\n::: {style=\"font-size: 0.8em;\"}\n- **Concept:**  Select data based on a Boolean array (an array of `True`/`False` values).  The Boolean array typically has the same shape as the array you're indexing.\n\n::: {#c53c0934 .cell execution_count=21}\n``` {.python .cell-code}\nnames = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])\ndata = np.array([[4, 7], [0, 2], [-5, 6], [0, 0], [1, 2],\n                 [-12, -4], [3, 4]])\n\nprint(names == 'Bob')  # Create a Boolean array\nprint(data[names == 'Bob'])  # Select rows where names == 'Bob'\n\n[ True False False  True False False False]\n[[4 7]\n [0 0]]\n\n\n\nCombining with Slicing/Indexing:\n\n\nprint(data[names == 'Bob', 1:])  # Select rows where names == 'Bob', and columns from index 1\nprint(data[names != 'Bob'])     # Select rows where names is NOT 'Bob'\n\n[[7]\n [0]]\n[[  0   2]\n [ -5   6]\n [  1   2]\n [-12  -4]\n [  3   4]]\n\n\n\nLogical Operators:\n\n~: Negates a Boolean array (like not)\n&: Combines conditions (like and)\n|: Combines conditions (like or)\n\n\n\nmask = (names == 'Bob') | (names == 'Will')\nprint(data[mask])\n\n[[ 4  7]\n [-5  6]\n [ 0  0]\n [ 1  2]]\n\n\n\n\n\n\n\n\nThe Python keywords and and or do not work with Boolean arrays. Use & (and) and | (or) instead."
  },
  {
    "objectID": "qmd/pandas3ed4.html#fancy-indexing",
    "href": "qmd/pandas3ed4.html#fancy-indexing",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Fancy Indexing",
    "text": "Fancy Indexing\n\nConcept: Indexing using integer arrays. Allows you to select specific rows or columns, and even reorder them.\n\n\narr = np.zeros((8, 4))\nfor i in range(8):\n    arr[i] = i\nprint(arr)\nprint(arr[[4, 3, 0, 6]])  # Select rows 4, 3, 0, and 6, in that order\n\n[[0. 0. 0. 0.]\n [1. 1. 1. 1.]\n [2. 2. 2. 2.]\n [3. 3. 3. 3.]\n [4. 4. 4. 4.]\n [5. 5. 5. 5.]\n [6. 6. 6. 6.]\n [7. 7. 7. 7.]]\n[[4. 4. 4. 4.]\n [3. 3. 3. 3.]\n [0. 0. 0. 0.]\n [6. 6. 6. 6.]]\n\n\n\narr = np.arange(32).reshape((8, 4))\nprint(arr[[1, 5, 7, 2], [0, 3, 1, 2]]) # Select elements (1, 0), (5, 3), (7, 1), (2, 2)\n\n[ 4 23 29 10]\n\n\n\nSelecting a Rectangular Region:\n\n\nprint(arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]])  # Select rows 1, 5, 7, 2, and reorder columns\n\n[[ 4  7  5  6]\n [20 23 21 22]\n [28 31 29 30]\n [ 8 11  9 10]]\n\n\n\nImportant: Fancy indexing, unlike slicing, always copies the data into a new array."
  },
  {
    "objectID": "qmd/pandas3ed4.html#transposing-arrays-and-swapping-axes",
    "href": "qmd/pandas3ed4.html#transposing-arrays-and-swapping-axes",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Transposing Arrays and Swapping Axes",
    "text": "Transposing Arrays and Swapping Axes\n\n\nTransposing: Rearranging data by switching rows and columns. Use the .T attribute or the transpose method.\n\n\narr = np.arange(15).reshape((3, 5))\nprint(arr)\nprint(arr.T)  # Transpose the array\n\n[[ 0  1  2  3  4]\n [ 5  6  7  8  9]\n [10 11 12 13 14]]\n[[ 0  5 10]\n [ 1  6 11]\n [ 2  7 12]\n [ 3  8 13]\n [ 4  9 14]]\n\n\n\nMatrix Multiplication: Use np.dot or the @ operator for matrix multiplication.\n\n\narr = np.array([[0, 1, 0], [1, 2, -2], [6, 3, 2], [-1, 0, -1], [1, 0, 1]])\nprint(np.dot(arr.T, arr))  # Matrix multiplication\nprint(arr.T @ arr)\n\n[[39 20 12]\n [20 14  2]\n [12  2 10]]\n[[39 20 12]\n [20 14  2]\n [12  2 10]]\n\n\n\nSwapping Axes: The swapaxes method takes a pair of axis numbers and switches the indicated axes.\n\n\nprint(arr.swapaxes(0, 1)) # swap axis 0 and axis 1\n\n[[ 0  1  6 -1  1]\n [ 1  2  3  0  0]\n [ 0 -2  2 -1  1]]\n\n\n\n\n\n\n\n\n\nTransposing and swapaxes return views on the underlying data without making a copy."
  },
  {
    "objectID": "qmd/pandas3ed4.html#pseudorandom-number-generation",
    "href": "qmd/pandas3ed4.html#pseudorandom-number-generation",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Pseudorandom Number Generation",
    "text": "Pseudorandom Number Generation\n\n\nnumpy.random Module: Provides functions to generate arrays of random numbers from various distributions.\ndefault_rng: The recommended way to create a random number generator.\n\n\nrng = np.random.default_rng(seed=12345)  # Create a generator with a seed\ndata = rng.standard_normal((2, 3))       # Generate a 2x3 array of standard normal values\nprint(data)\n\n[[-1.42382504  1.26372846 -0.87066174]\n [-0.25917323 -0.07534331 -0.74088465]]\n\n\n\nWhy use a seed? Setting a seed ensures reproducibility. You‚Äôll get the same random numbers each time you run the code with the same seed.\nGenerator Isolation: The generator object rng is isolated from other code that might also use the numpy.random module.\nPerformance: numpy.random is much faster than Python‚Äôs built-in random module for generating large arrays."
  },
  {
    "objectID": "qmd/pandas3ed4.html#common-numpy.random-functions",
    "href": "qmd/pandas3ed4.html#common-numpy.random-functions",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Common numpy.random Functions",
    "text": "Common numpy.random Functions\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npermutation\nReturns a random permutation of a sequence, or a permuted range.\n\n\nshuffle\nRandomly permutes a sequence in place.\n\n\nuniform\nDraws samples from a uniform distribution.\n\n\nintegers\nDraws random integers from a given low-to-high range.\n\n\nstandard_normal\nDraws samples from a standard normal distribution (mean 0, standard deviation 1).\n\n\nbinomial\nDraws samples from a binomial distribution.\n\n\nnormal\nDraws samples from a normal (Gaussian) distribution.\n\n\nbeta\nDraws samples from a Beta distribution.\n\n\nchisquare\nDraws samples from a chi-square distribution.\n\n\ngamma\nDraws samples from a gamma distribution.\n\n\nuniform\nDraws samples from a uniform [0, 1) distribution."
  },
  {
    "objectID": "qmd/pandas3ed4.html#universal-functions-ufuncs",
    "href": "qmd/pandas3ed4.html#universal-functions-ufuncs",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Universal Functions (ufuncs)",
    "text": "Universal Functions (ufuncs)\n\n\nWhat are ufuncs? Functions that perform element-wise operations on ndarrays. They are fast vectorized wrappers for simple functions.\nUnary ufuncs: Take a single array as input.\n\n\narr = np.arange(10)\nprint(np.sqrt(arr))    # Square root of each element\nprint(np.exp(arr))     # Exponential of each element\n\n[0.         1.         1.41421356 1.73205081 2.         2.23606798\n 2.44948974 2.64575131 2.82842712 3.        ]\n[1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01\n 5.45981500e+01 1.48413159e+02 4.03428793e+02 1.09663316e+03\n 2.98095799e+03 8.10308393e+03]\n\n\n\nBinary ufuncs: Take two arrays as input.\n\n\nx = rng.standard_normal(8)\ny = rng.standard_normal(8)\nprint(np.maximum(x, y))  # Element-wise maximum\n\n[-0.46695317  0.6488928   0.78884434 -1.25666813  2.34740965  1.39897899\n  1.32229806  0.90219827]\n\n\n\nufuncs that return multiple arrays:\n\n\narr = rng.standard_normal(7) * 5\nremainder, whole_part = np.modf(arr)  # Returns fractional and integral parts\nprint(remainder)\nprint(whole_part)\n\n[ 0.51459671 -0.10791367 -0.7909463   0.24741966 -0.71800536 -0.40843795\n  0.62369966]\n[ 4. -8. -0.  2. -6. -0.  8.]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#some-unary-universal-functions",
    "href": "qmd/pandas3ed4.html#some-unary-universal-functions",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Some Unary Universal Functions",
    "text": "Some Unary Universal Functions\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nabs, fabs\nComputes the absolute value element-wise. fabs is faster for non-complex data.\n\n\nsqrt\nComputes the square root of each element (equivalent to arr ** 0.5).\n\n\nsquare\nComputes the square of each element (equivalent to arr ** 2).\n\n\nexp\nComputes the exponent ex of each element.\n\n\nlog, log10, log2, log1p\nNatural logarithm (base e), log base 10, log base 2, and log(1 + x), respectively.\n\n\nsign\nComputes the sign of each element: 1 (positive), 0 (zero), or -1 (negative).\n\n\nceil\nComputes the ceiling of each element (smallest integer greater than or equal to that number).\n\n\nfloor\nComputes the floor of each element (largest integer less than or equal to each element).\n\n\nrint\nRounds elements to the nearest integer, preserving the dtype.\n\n\nmodf\nReturns fractional and integral parts of array as separate arrays.\n\n\nisnan\nReturns a Boolean array indicating whether each value is NaN (Not a Number).\n\n\nisfinite, isinf\nReturns a Boolean array indicating whether each element is finite or infinite, respectively.\n\n\ncos, cosh, sin, sinh, tan, tanh\nRegular and hyperbolic trigonometric functions.\n\n\narccos, arccosh, arcsin, arcsinh, arctan, arctanh\nInverse trigonometric functions.\n\n\nlogical_not\nComputes the truth value of not x element-wise (equivalent to ~arr)."
  },
  {
    "objectID": "qmd/pandas3ed4.html#some-binary-universal-functions",
    "href": "qmd/pandas3ed4.html#some-binary-universal-functions",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Some Binary Universal Functions",
    "text": "Some Binary Universal Functions\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nadd\nAdds corresponding elements in arrays.\n\n\nsubtract\nSubtracts elements in second array from first array.\n\n\nmultiply\nMultiplies array elements.\n\n\ndivide, floor_divide\nDivides or floor divides (truncating the remainder).\n\n\npower\nRaises elements in first array to powers indicated in second array.\n\n\nmaximum, fmax\nElement-wise maximum. fmax ignores NaN.\n\n\nminimum, fmin\nElement-wise minimum. fmin ignores NaN.\n\n\nmod\nElement-wise modulus (remainder of division).\n\n\ncopysign\nCopies the sign of values in second argument to values in first argument.\n\n\ngreater, greater_equal, less, less_equal, equal, not_equal\nPerforms element-wise comparison, yielding a Boolean array.\n\n\nlogical_and, logical_or, logical_xor\nComputes element-wise truth value of logical operations."
  },
  {
    "objectID": "qmd/pandas3ed4.html#array-oriented-programming-example",
    "href": "qmd/pandas3ed4.html#array-oriented-programming-example",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Array-Oriented Programming: Example",
    "text": "Array-Oriented Programming: Example\n\nLet‚Äôs compute the function ‚àö(x^2 + y^2) across a grid of values:\n\npoints = np.arange(-5, 5, 0.01)  # 1000 equally spaced points\nxs, ys = np.meshgrid(points, points)  # Create coordinate matrices\nz = np.sqrt(xs ** 2 + ys ** 2)      # Compute the function\n\nNow, let‚Äôs visualize the result using Matplotlib:\n\nimport matplotlib.pyplot as plt\nplt.imshow(z, cmap=plt.cm.gray, extent=[-5, 5, -5, 5])\nplt.colorbar()\nplt.title(\"Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values\")\n# plt.close('all')\nplt.show()\n\n&lt;&gt;:4: SyntaxWarning: invalid escape sequence '\\s'\n&lt;&gt;:4: SyntaxWarning: invalid escape sequence '\\s'\nC:\\Users\\zwujr\\AppData\\Local\\Temp\\ipykernel_9680\\1319111413.py:4: SyntaxWarning: invalid escape sequence '\\s'\n  plt.title(\"Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values\")\n\n\n\n\n\n\n\n\n\nThis example demonstrates how concise and efficient array-oriented programming can be."
  },
  {
    "objectID": "qmd/pandas3ed4.html#expressing-conditional-logic-np.where",
    "href": "qmd/pandas3ed4.html#expressing-conditional-logic-np.where",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Expressing Conditional Logic: np.where",
    "text": "Expressing Conditional Logic: np.where\n\n\nnp.where: A vectorized version of the ternary expression x if condition else y.\n\n\nxarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])\nyarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])\ncond = np.array([True, False, True, True, False])\n\nresult = np.where(cond, xarr, yarr)  # Select from xarr if cond is True, otherwise yarr\nprint(result)\n\n[1.1 2.2 1.3 1.4 2.5]\n\n\n\nExample: Replace positive values in an array with 2, and negative values with -2:\n\n\narr = rng.standard_normal((4, 4))\nresult = np.where(arr &gt; 0, 2, -2)\nprint(result)\n\n[[ 2  2  2 -2]\n [-2 -2  2  2]\n [-2 -2  2  2]\n [-2  2 -2 -2]]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#mathematical-and-statistical-methods",
    "href": "qmd/pandas3ed4.html#mathematical-and-statistical-methods",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Mathematical and Statistical Methods",
    "text": "Mathematical and Statistical Methods\n\nNumPy provides a set of methods for computing statistics on arrays:\n\narr = rng.standard_normal((5, 4))\nprint(arr.mean())       # Mean of all elements\nprint(np.mean(arr))    # Equivalent to arr.mean()\nprint(arr.sum())        # Sum of all elements\n\n-0.08719744457434529\n-0.08719744457434529\n-1.743948891486906\n\n\n\nAxis Argument: Many methods take an optional axis argument to compute the statistic along a specific axis:\n\n\nprint(arr.mean(axis=1))  # Mean across columns (for each row)\nprint(arr.sum(axis=0))   # Sum down rows (for each column)\n\n[ 0.10899104  0.3280763   0.16502112 -0.66719934 -0.37087634]\n[-1.62923076  1.03990647 -0.33436331 -0.82026129]\n\n\n\ncumsum and cumprod: Compute cumulative sums and products:\n\n\narr = np.array([0, 1, 2, 3, 4, 5, 6, 7])\nprint(arr.cumsum())  # Cumulative sum\n\n[ 0  1  3  6 10 15 21 28]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#basic-array-statistical-methods",
    "href": "qmd/pandas3ed4.html#basic-array-statistical-methods",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Basic Array Statistical Methods",
    "text": "Basic Array Statistical Methods\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nsum\nSum of all the elements in the array or along an axis; zero-length arrays have sum 0.\n\n\nmean\nArithmetic mean; invalid (returns NaN) on zero-length arrays.\n\n\nstd, var\nStandard deviation and variance, respectively.\n\n\nmin,max\nMinimum and maximum.\n\n\nargmin, argmax\nIndices of minimum and maximum elements, respectively.\n\n\ncumsum\nCumulative sum of elements starting from 0.\n\n\ncumprod\nCumulative product of elements starting from 1."
  },
  {
    "objectID": "qmd/pandas3ed4.html#methods-for-boolean-arrays",
    "href": "qmd/pandas3ed4.html#methods-for-boolean-arrays",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Methods for Boolean Arrays",
    "text": "Methods for Boolean Arrays\n\n\nsum with Booleans: True values are treated as 1, False as 0. Useful for counting True values.\n\n\narr = rng.standard_normal(100)\nprint((arr &gt; 0).sum())  # Count positive values\n\n48\n\n\n\nany and all:\n\nany: Checks if at least one value in a Boolean array is True.\nall: Checks if all values in a Boolean array are True.\n\n\n\nbools = np.array([False, False, True, False])\nprint(bools.any())  # Is there at least one True?\nprint(bools.all())  # Are all values True?\n\nTrue\nFalse"
  },
  {
    "objectID": "qmd/pandas3ed4.html#sorting",
    "href": "qmd/pandas3ed4.html#sorting",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Sorting",
    "text": "Sorting\n\n\nsort Method: Sorts an array in place.\n\n\narr = rng.standard_normal(6)\narr.sort()  # Sort the array in place\nprint(arr)\n\n[-0.72083767 -0.68391322 -0.08241372 -0.05481416  0.07726066  1.12062282]\n\n\n\nSorting Along an Axis:\n\n\narr = rng.standard_normal((5, 3))\narr.sort(axis=0)  # Sort within each column\nprint(arr)\narr.sort(axis=1) # Sort within each row\nprint(arr)\n\n[[-2.05280763 -0.05032522  0.28931754]\n [ 0.17930568 -0.02788771  0.29204679]\n [ 0.40589222  0.38050908  0.75539067]\n [ 0.63840567  1.23853712  1.27279553]\n [ 0.9359865   1.39748056  1.37105185]]\n[[-2.05280763 -0.05032522  0.28931754]\n [-0.02788771  0.17930568  0.29204679]\n [ 0.38050908  0.40589222  0.75539067]\n [ 0.63840567  1.23853712  1.27279553]\n [ 0.9359865   1.37105185  1.39748056]]\n\n\n\nnp.sort Function: Returns a sorted copy of an array (does not modify the original)."
  },
  {
    "objectID": "qmd/pandas3ed4.html#unique-and-other-set-logic",
    "href": "qmd/pandas3ed4.html#unique-and-other-set-logic",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Unique and Other Set Logic",
    "text": "Unique and Other Set Logic\n\n\nnp.unique: Returns the sorted unique values in an array.\n\n\nnames = np.array(['Bob', 'Will', 'Joe', 'Bob', 'Will', 'Joe', 'Joe'])\nprint(np.unique(names)) # Get unique names\n\n['Bob' 'Joe' 'Will']\n\n\n\nnp.in1d: Tests membership of values in one array within another.\n\n\nvalues = np.array([6, 0, 0, 3, 2, 5, 6])\nprint(np.in1d(values, [2, 3, 6]))  # Check if each value in 'values' is in [2, 3, 6]\n\n[ True False False  True  True False  True]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#array-set-operations",
    "href": "qmd/pandas3ed4.html#array-set-operations",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Array Set Operations",
    "text": "Array Set Operations\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nunique(x)\nComputes the sorted, unique elements in x.\n\n\nintersect1d(x, y)\nComputes the sorted, common elements in x and y.\n\n\nunion1d(x, y)\nComputes the sorted union of elements.\n\n\nin1d(x, y)\nComputes a Boolean array indicating whether each element of x is in y.\n\n\nsetdiff1d(x, y)\nSet difference: elements in x that are not in y.\n\n\nsetxor1d(x, y)\nSet symmetric differences; elements that are in either of the arrays, but not both."
  },
  {
    "objectID": "qmd/pandas3ed4.html#file-input-and-output-with-arrays",
    "href": "qmd/pandas3ed4.html#file-input-and-output-with-arrays",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "File Input and Output with Arrays",
    "text": "File Input and Output with Arrays\n\n\nnp.save and np.load: Functions for saving and loading arrays in NumPy‚Äôs binary format (.npy).\n\n\narr = np.arange(10)\nnp.save('some_array', arr)  # Save to 'some_array.npy'\nloaded_arr = np.load('some_array.npy')  # Load from 'some_array.npy'\nprint(loaded_arr)\n\n[0 1 2 3 4 5 6 7 8 9]\n\n\n\nnp.savez: Saves multiple arrays into an uncompressed archive (.npz).\n\n\nnp.savez('array_archive.npz', a=arr, b=arr)  # Save multiple arrays\narch = np.load('array_archive.npz')        # Load the archive\nprint(arch['b'])  # Access arrays by name\n\n[0 1 2 3 4 5 6 7 8 9]\n\n\n\nnp.savez_compressed: Saves multiple arrays into a compressed archive."
  },
  {
    "objectID": "qmd/pandas3ed4.html#linear-algebra",
    "href": "qmd/pandas3ed4.html#linear-algebra",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Linear Algebra",
    "text": "Linear Algebra\n\n\nnumpy.linalg Module: Provides functions for linear algebra operations.\nMatrix Multiplication:\n\n\nx = np.array([[1., 2., 3.], [4., 5., 6.]])\ny = np.array([[6., 23.], [-1, 7], [8, 9]])\nprint(x.dot(y))        # Matrix multiplication (method)\nprint(np.dot(x, y))    # Matrix multiplication (function)\nprint( x @ np.ones(3)) # Matrix multiplication using the @ operator\n\n[[ 28.  64.]\n [ 67. 181.]]\n[[ 28.  64.]\n [ 67. 181.]]\n[ 6. 15.]\n\n\n\nInverse and Determinant:\n\n\nfrom numpy.linalg import inv, qr\nX = rng.standard_normal((5, 5))\nmat = X.T @ X\nprint(inv(mat))   # Inverse of a matrix\n\n[[  3.49932285   2.84436268   3.59557002 -16.55376878   4.47325573]\n [  2.84436268   2.56666253   2.9001963  -13.57742      3.76776505]\n [  3.59557002   2.9001963    4.48232906 -18.34525499   4.70660032]\n [-16.55376878 -13.57742    -18.34525499  84.01018808 -22.04840478]\n [  4.47325573   3.76776505   4.70660032 -22.04840478   6.05251342]]"
  },
  {
    "objectID": "qmd/pandas3ed4.html#commonly-used-numpy.linalg-functions",
    "href": "qmd/pandas3ed4.html#commonly-used-numpy.linalg-functions",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Commonly Used numpy.linalg Functions",
    "text": "Commonly Used numpy.linalg Functions\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ndiag\nReturns the diagonal (or off-diagonal) elements of a square matrix as a 1D array, or converts a 1D array to a square matrix.\n\n\ndot\nMatrix multiplication.\n\n\ntrace\nComputes the sum of the diagonal elements.\n\n\ndet\nComputes the matrix determinant.\n\n\neig\nComputes the eigenvalues and eigenvectors of a square matrix.\n\n\ninv\nComputes the inverse of a square matrix.\n\n\npinv\nComputes the Moore-Penrose pseudoinverse of a matrix.\n\n\nqr\nComputes the QR decomposition.\n\n\nsvd\nComputes the singular value decomposition (SVD).\n\n\nsolve\nSolves the linear system Ax = b for x, where A is a square matrix.\n\n\nlstsq\nComputes the least-squares solution to Ax = b."
  },
  {
    "objectID": "qmd/pandas3ed4.html#example-random-walks",
    "href": "qmd/pandas3ed4.html#example-random-walks",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Example: Random Walks",
    "text": "Example: Random Walks\n\nLet‚Äôs simulate a simple random walk using NumPy:\n\nnsteps = 1000\nrng = np.random.default_rng(seed=12345)\ndraws = rng.integers(0, 2, size=nsteps)  # Generate 0s and 1s (coin flips)\nsteps = np.where(draws == 0, 1, -1)      # Convert to 1 and -1\nwalk = steps.cumsum()                    # Cumulative sum (the walk)\n\nFirst 100 steps of a simple random walk:\n\nimport matplotlib.pyplot as plt\nplt.plot(walk[:100])\nplt.show()"
  },
  {
    "objectID": "qmd/pandas3ed4.html#random-walks-analysis",
    "href": "qmd/pandas3ed4.html#random-walks-analysis",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Random Walks: Analysis",
    "text": "Random Walks: Analysis\n\nWe can analyze the random walk:\n\nprint(walk.min())  # Minimum value\nprint(walk.max())  # Maximum value\n\n-8\n50\n\n\n\nFirst Crossing Time: The step at which the walk reaches a particular value.\n\n\nprint((np.abs(walk) &gt;= 10).argmax())  # Find the first step where the absolute value is &gt;= 10\n\n155\n\n\n\n\n\n\n\n\n\nusing argmax here is not always efficient because it always makes a full scan of the array. In this special case, once a True is observed we know it to be the maximum value."
  },
  {
    "objectID": "qmd/pandas3ed4.html#simulating-many-random-walks-at-once",
    "href": "qmd/pandas3ed4.html#simulating-many-random-walks-at-once",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Simulating Many Random Walks at Once",
    "text": "Simulating Many Random Walks at Once\n\nWe can efficiently simulate many random walks simultaneously:\n\nnwalks = 5000\nnsteps = 1000\ndraws = rng.integers(0, 2, size=(nwalks, nsteps))  # Generate draws for all walks\nsteps = np.where(draws &gt; 0, 1, -1)\nwalks = steps.cumsum(axis=1)                     # Cumulative sum for each walk\n\nThen, for example, calculate the average minimum crossing time:\n\nhits30 = (np.abs(walks) &gt;= 30).any(axis=1)\ncrossing_times = (np.abs(walks[hits30]) &gt;= 30).argmax(axis=1)\nprint(crossing_times.mean())\n\n500.5699558173785\n\n\n\n\n\n\n\n\n\nthis vectorized approach requires creating an array with nwalks * nsteps elements, which may use a large amount of memory for large simulations. If memory is more constrained, then a different approach will be required."
  },
  {
    "objectID": "qmd/pandas3ed4.html#summary",
    "href": "qmd/pandas3ed4.html#summary",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Summary",
    "text": "Summary\n\n\nNumPy‚Äôs Power: NumPy provides a powerful foundation for numerical computing in Python, thanks to its efficient ndarray and vectorized operations.\nKey Concepts:\n\nndarray: Multidimensional array with homogeneous data.\ndtype: Data type of array elements.\nVectorization: Performing operations on entire arrays without loops.\nBroadcasting: Arithmetic operations on arrays of different shapes.\nIndexing and Slicing: Accessing and modifying array elements and subarrays.\nFancy Indexing: Indexing with integer arrays.\nTransposing: Rearranging data.\nufuncs: Fast element-wise functions.\nnumpy.random: Generating arrays of random numbers.\nLinear Algebra\n\nEfficiency: NumPy is designed for performance, especially with large datasets."
  },
  {
    "objectID": "qmd/pandas3ed4.html#thoughts-and-discussion",
    "href": "qmd/pandas3ed4.html#thoughts-and-discussion",
    "title": "NumPy Basics: Arrays and Vectorized Computation",
    "section": "Thoughts and Discussion ü§î",
    "text": "Thoughts and Discussion ü§î\n\n\nHow does the concept of vectorization in NumPy compare to how you might perform similar operations in other programming languages you know?\nCan you think of specific data analysis tasks where NumPy‚Äôs array-oriented approach would be significantly more efficient than using Python lists and loops?\nWhat are the advantages and potential disadvantages of NumPy array slices being views rather than copies? When might you need to explicitly create a copy?\nConsider the np.where function. How could you use it to implement more complex conditional logic than the simple examples we saw?\nWhy is it important to understand NumPy‚Äôs data types (dtypes)? How can they impact performance and memory usage?\nDiscuss scenarios where you might use NumPy‚Äôs linear algebra functions (e.g., dot, inv, eig)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "ÊàëÊòØÈÇ±È£ûÔºåËøôÊòØÊàëÁöÑ‰∏™‰∫∫ÁΩëÁ´ôÔºå\nÁî®‰∫éÂàÜ‰∫´‰∏Ä‰∫õÊï∞ÊçÆÂàÜÊûêÊñáÁ´†ÔºåËøòÊúâ‰∏™‰∫∫ÁöÑËÆ∞ÂΩïÂíåËµÑÊñô„ÄÇ"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ÁªüËÆ°Â≠¶‰π†ÂØºËÆ∫",
    "section": "",
    "text": "ÊïôÊùêÈááÁî®ËëóÂêçÁöÑISL(Introduction to Statistical Learning)\nhttps://www.statlearning.com/"
  },
  {
    "objectID": "index.html#ÊïôÊùê",
    "href": "index.html#ÊïôÊùê",
    "title": "ÁªüËÆ°Â≠¶‰π†ÂØºËÆ∫",
    "section": "",
    "text": "ÊïôÊùêÈááÁî®ËëóÂêçÁöÑISL(Introduction to Statistical Learning)\nhttps://www.statlearning.com/"
  },
  {
    "objectID": "index.html#ppt",
    "href": "index.html#ppt",
    "title": "ÁªüËÆ°Â≠¶‰π†ÂØºËÆ∫",
    "section": "ppt",
    "text": "ppt\n Á¨¨‰∏ÄÁ´† \n Á¨¨‰∫åÁ´† \n Á¨¨‰∏âÁ´† \n Á¨¨ÂõõÁ´† \n Á¨¨‰∫îÁ´† \n Á¨¨ÂÖ≠Á´† \n Á¨¨‰∏ÉÁ´† \n Á¨¨ÂÖ´Á´† \n Á¨¨‰πùÁ´† \n Á¨¨ÂçÅÁ´† \n Á¨¨ÂçÅ‰∏ÄÁ´† \n Á¨¨ÂçÅ‰∫åÁ´† \n Á¨¨ÂçÅ‰∏âÁ´†"
  }
]