{
  "hash": "d1b3d79a31582a6e8cc7740e84f1d47f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"NumPy Basics: Arrays and Vectorized Computation\"\nauthor: \"Your Name\"\n---\n\n\n## Introduction to NumPy\n\n::: {style=\"font-size: 0.9em;\"}\nNumPy, short for Numerical Python, is a foundational package for numerical computing in Python. \n\n-   **Why is it important?** ðŸ§ Many scientific computing packages rely on NumPy's array objects for data exchange. Think of it as the *lingua franca* (common language) of data analysis in Python.\n\n-  It is designed for efficiency on large arrays of data.\n\n-   **What will we learn?** We'll cover the basics, focusing on how NumPy enables fast, array-oriented operations, which are crucial for data analysis with libraries like pandas.\n:::\n\n## Key Features of NumPy\n\n::: {style=\"font-size: 0.85em;\"}\nHere's a glimpse of what NumPy offers:\n\n-   **ndarray:**  The heart of NumPy. A highly efficient multidimensional array. Imagine a container holding data of the same type (e.g., all numbers). It allows for fast operations and *broadcasting* (we'll cover this later!).\n-   **Mathematical Functions:**  A rich set of functions that operate on entire arrays *without* explicit loops. This is called *vectorization*, and it's *much* faster than writing loops in Python.\n-   **Data I/O:** Tools to read and write array data to disk.\n-   **Linear Algebra:**  Capabilities for linear algebra, random number generation, and Fourier transforms. Essential tools for many scientific and engineering tasks.\n-   **C API:**  Allows seamless integration with libraries written in C, C++, or FORTRAN. This is key for leveraging high-performance legacy code.\n:::\n\n## Why NumPy is Efficient?\n\n::: {style=\"font-size: 0.9em;\"}\nNumPy's efficiency stems from several design choices:\n\n-   **Contiguous Memory:**  Unlike Python lists, NumPy arrays store data in a single, contiguous block of memory. This makes accessing and manipulating data much faster.\n\n-   **C-Based Algorithms:**  Many NumPy operations are implemented in C, avoiding the overhead of Python's interpreter.\n\n-   **Less Memory Usage:** NumPy arrays generally consume less memory than Python lists, especially for numerical data.\n\n:::\n\n## NumPy vs. Python Lists: A Performance Showdown ðŸƒâ€â™‚ï¸\n\n::: {style=\"font-size: 0.8em;\"}\nLet's see NumPy's speed advantage in action. We'll compare multiplying a million integers by 2 using both a NumPy array and a Python list:\n\n::: {#6c42dd1c .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nmy_arr = np.arange(1_000_000)  # NumPy array\nmy_list = list(range(1_000_000)) # Python list\n```\n:::\n\n\nNow, the timed operations:\n\n::: {#2d618ca3 .cell execution_count=2}\n``` {.python .cell-code}\n# NumPy array operation\n# %timeit my_arr2 = my_arr * 2\n```\n:::\n\n\n::: {#0413fb39 .cell execution_count=3}\n``` {.python .cell-code}\n# Python list operation (using a list comprehension)\n# %timeit my_list2 = [x * 2 for x in my_list]\n```\n:::\n\n\n:::\n::: {.callout-note appearance=\"simple\"}\nNumPy-based algorithms are generally 10 to 100 times faster (or more) than their pure Python counterparts and use significantly less memory.\n:::\n\n## The NumPy ndarray: A Closer Look\n\n::: {style=\"font-size: 0.9em;\"}\nThe `ndarray` (N-dimensional array) is the core data structure in NumPy.\n\n-   **Homogeneous Data:**  All elements in an ndarray must be of the same data type (e.g., all integers, all floats).\n\n-   **Key Attributes:**\n    -   `shape`: A tuple indicating the size of each dimension.  For a 2x3 array, the shape would be `(2, 3)`.\n    -   `dtype`:  An object describing the data type of the elements (e.g., `int64`, `float32`).\n\n- **Creating ndarray**\nThe easiest way to create an array is to use the array function. This accepts any sequence-like object (including other arrays) and produces a new NumPy array containing the passed data.\n\n:::\n\n## Creating ndarrays: Examples\n\n::: {style=\"font-size: 0.85em;\"}\nLet's create some arrays:\n\n::: {#de4ae170 .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\n\n# From a list\ndata1 = [6, 7.5, 8, 0, 1]\narr1 = np.array(data1)\nprint(arr1)\nprint(arr1.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[6.  7.5 8.  0.  1. ]\nfloat64\n```\n:::\n:::\n\n\n::: {#d7655b24 .cell execution_count=5}\n``` {.python .cell-code}\n# From a nested list (creates a 2D array)\ndata2 = [[1, 2, 3, 4], [5, 6, 7, 8]]\narr2 = np.array(data2)\nprint(arr2)\nprint(arr2.ndim)  # Number of dimensions\nprint(arr2.shape)\nprint(arr2.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3 4]\n [5 6 7 8]]\n2\n(2, 4)\nint32\n```\n:::\n:::\n\n\n:::\n\n##  Array Creation Functions\n\n::: {style=\"font-size: 0.85em;\"}\nNumPy provides several convenient functions to create arrays:\n\n::: {#a56ee9b0 .cell execution_count=6}\n``` {.python .cell-code}\n# Array of zeros\nzeros_arr = np.zeros(10)  # 1D array\nprint(zeros_arr)\n\nzeros_arr_2d = np.zeros((3, 6)) # 2D array (3x6)\nprint(zeros_arr_2d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n```\n:::\n:::\n\n\n::: {#81f7c839 .cell execution_count=7}\n``` {.python .cell-code}\n# Array of ones\nones_arr = np.ones((2, 3)) # 2D array (2x3)\nprint(ones_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 1. 1.]\n [1. 1. 1.]]\n```\n:::\n:::\n\n\n::: {#8a854480 .cell execution_count=8}\n``` {.python .cell-code}\n# Uninitialized array (may contain garbage values)\nempty_arr = np.empty((2, 3, 2)) # 3D array\nprint(empty_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[1.38814909e-311 3.16202013e-322]\n  [0.00000000e+000 0.00000000e+000]\n  [5.96314381e-096 1.42320827e+160]]\n\n [[4.69610055e-033 2.21559062e-056]\n  [6.82245542e-038 6.93790501e+169]\n  [1.85357951e-051 4.39272680e+175]]]\n```\n:::\n:::\n\n\n::: {#f2ad4848 .cell execution_count=9}\n``` {.python .cell-code}\n#  'arange': Similar to Python's 'range', but returns an ndarray\nrange_arr = np.arange(15)\nprint(range_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]\n```\n:::\n:::\n\n\n:::\n\n## Summary of Array Creation Functions\n\n::: {style=\"font-size: 0.7em;\"}\nA handy table summarizing common array creation functions:\n\n| Function         | Description                                                                                                                                                                              |\n|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `array`          | Converts input data (list, tuple, array, etc.) to an ndarray.                                                                                                                            |\n| `asarray`        | Similar to `array`, but does not copy if the input is already an ndarray.                                                                                                               |\n| `arange`         | Like Python's `range`, but returns an ndarray.                                                                                                                                           |\n| `ones`, `ones_like` | Creates an array filled with 1s. `ones_like` takes another array and creates a ones array of the same shape and dtype.                                                                     |\n| `zeros`, `zeros_like` |  Similar to `ones` and `ones_like`, but creates arrays filled with 0s. |\n| `empty`, `empty_like` | Creates an array without initializing its values.  Use with caution!                                                                                                                  |\n| `full`, `full_like` | Creates an array filled with a specified value. `full_like` takes another array and uses its shape and dtype.                                                                        |\n| `eye`, `identity`  | Creates a square identity matrix (1s on the diagonal, 0s elsewhere).                                                                                                                  |\n:::\n\n## Data Types (dtypes)\n\n::: {style=\"font-size: 0.8em;\"}\n-   **What is a dtype?**  A special object that contains information about the data type held by an ndarray (e.g., `float64`, `int32`, `bool`).\n\n-   **Why are dtypes important?**  They give you fine-grained control over how data is stored in memory. This is crucial for performance, especially with large datasets.  They also allow NumPy to interface with data from other systems (like databases or files written in C/C++).\n\n- **Specifying dtypes:**\n\n::: {#83b312fc .cell execution_count=10}\n``` {.python .cell-code}\narr1 = np.array([1, 2, 3], dtype=np.float64)  # Explicitly set dtype\narr2 = np.array([1, 2, 3], dtype=np.int32)\nprint(arr1.dtype)\nprint(arr2.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfloat64\nint32\n```\n:::\n:::\n\n\n:::\n\n## Common NumPy Data Types\n\n::: {style=\"font-size: 0.68em;\"}\n| Type             | Type Code      | Description                                                                         |\n|-------------------|----------------|-------------------------------------------------------------------------------------|\n| `int8`, `uint8`   | `i1`, `u1`     | Signed and unsigned 8-bit (1 byte) integer types                                    |\n| `int16`, `uint16` | `i2`, `u2`     | Signed and unsigned 16-bit integer types                                           |\n| `int32`, `uint32` | `i4`, `u4`     | Signed and unsigned 32-bit integer types                                           |\n| `int64`, `uint64` | `i8`, `u8`     | Signed and unsigned 64-bit integer types                                           |\n| `float16`        | `f2`           | Half-precision floating point                                                       |\n| `float32`        | `f4` or `f`    | Standard single-precision floating point; compatible with C `float`                 |\n| `float64`        | `f8` or `d`    | Standard double-precision floating point; compatible with C `double` and Python `float` |\n| `float128`       | `f16` or `g`   | Extended-precision floating point                                                  |\n| `complex64`, `complex128`, `complex256` | `c8`, `c16`, `c32` | Complex numbers represented by two 32, 64, or 128 floats, respectively               |\n| `bool`           | `?`            | Boolean type storing `True` and `False` values                                       |\n| `object`         | `O`            | Python object type; a value can be any Python object                                 |\n| `string_`        | `S`            | Fixed-length ASCII string type (1 byte per character).  Use `S10` for a string of length 10. |\n| `unicode_`       | `U`            | Fixed-length Unicode type (number of bytes platform-specific)                        |\n:::\n::: {.callout-note appearance=\"simple\"}\nThere are both *signed* and *unsigned* integer types. A *signed* integer can represent both positive and negative integers, while an *unsigned* integer can only represent non-zero integers.\n:::\n\n## Casting with `astype`\n\n::: {style=\"font-size: 0.85em;\"}\n-   **What is casting?**  Converting an array from one dtype to another.\n\n-   **How to cast:** Use the `astype` method.  `astype` *always* creates a new array (a copy of the data), even if the new dtype is the same as the old dtype.\n\n::: {#bbbdcf90 .cell execution_count=11}\n``` {.python .cell-code}\narr = np.array([1, 2, 3, 4, 5])\nprint(arr.dtype)\nfloat_arr = arr.astype(np.float64) # Integer to float\nprint(float_arr.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nint32\nfloat64\n```\n:::\n:::\n\n\n::: {#765bd6aa .cell execution_count=12}\n``` {.python .cell-code}\nnumeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)\nfloat_arr = numeric_strings.astype(float) # String to float\nprint(float_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 1.25 -9.6  42.  ]\n```\n:::\n:::\n\n\n::: {.callout-caution appearance=\"simple\"}\nBe cautious when using the `numpy.string_` type, as string data in NumPy is fixed size and may truncate input without warning. `pandas` has more intuitive out-of-the-box behavior on non-numeric data.\n:::\n:::\n\n## Arithmetic with NumPy Arrays: Vectorization\n\n::: {style=\"font-size: 0.8em;\"}\n- **Vectorization:**  A core concept in NumPy.  It means performing operations on entire arrays *without* writing explicit `for` loops. This is *much* faster and more concise.\n\n- **Element-wise Operations:**  Arithmetic operations between equal-sized arrays are applied element-wise:\n\n::: {#fd5aece5 .cell execution_count=13}\n``` {.python .cell-code}\narr = np.array([[1., 2., 3.], [4., 5., 6.]])\nprint(arr * arr) # Element-wise multiplication\nprint(arr - arr) # Element-wise subtraction\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1.  4.  9.]\n [16. 25. 36.]]\n[[0. 0. 0.]\n [0. 0. 0.]]\n```\n:::\n:::\n\n\n-   **Operations with Scalars:**  Arithmetic operations with scalars *propagate* the scalar value to each element in the array:\n\n::: {#bca6decd .cell execution_count=14}\n``` {.python .cell-code}\nprint(1 / arr)   # Divide each element by 1\nprint(arr ** 2) # Square each element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1.         0.5        0.33333333]\n [0.25       0.2        0.16666667]]\n[[ 1.  4.  9.]\n [16. 25. 36.]]\n```\n:::\n:::\n\n\n:::\n\n## Broadcasting (Brief Introduction)\n\n::: {style=\"font-size: 0.8em;\"}\n-   **What is broadcasting?** A powerful mechanism that allows NumPy to perform arithmetic operations on arrays of *different* shapes, under certain conditions.\n\n-   **Example:**  You can add a scalar to an array of any shape.  The scalar is effectively \"stretched\" to match the array's shape.\n\n-   We'll cover broadcasting in more detail later. For now, just be aware that it exists and is a key reason why NumPy is so flexible.\n:::\n\n## Basic Indexing and Slicing\n\n::: {style=\"font-size: 0.85em;\"}\n-   **Similar to Python Lists:**  One-dimensional NumPy arrays can be indexed and sliced much like Python lists:\n\n::: {#826a9e18 .cell execution_count=15}\n``` {.python .cell-code}\narr = np.arange(10)\nprint(arr[5])      # Access element at index 5\nprint(arr[5:8])    # Slice elements from index 5 up to (but not including) 8\narr[5:8] = 12     # Assign a value to a slice\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n[5 6 7]\n[ 0  1  2  3  4 12 12 12  8  9]\n```\n:::\n:::\n\n\n-   **Views vs. Copies:**  *Array slices are views on the original array*. This means that modifying a slice *will* modify the original array. This is different from Python lists, where slices create copies.\n\n::: {#7ff6e1ff .cell execution_count=16}\n``` {.python .cell-code}\narr_slice = arr[5:8]\narr_slice[1] = 12345  # Modify the slice\nprint(arr)          # Original array is also modified!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[    0     1     2     3     4    12 12345    12     8     9]\n```\n:::\n:::\n\n\n:::\n::: {.callout-warning appearance=\"simple\"}\nIf you want a copy of a slice of an ndarray instead of a view, you will need to explicitly copy the arrayâ€”for example, `arr[5:8].copy()`.\n:::\n\n## Indexing and Slicing: Higher Dimensions\n\n::: {style=\"font-size: 0.85em;\"}\n-   **Two-Dimensional Arrays:**  You can access elements using comma-separated indices:\n\n::: {#7987d290 .cell execution_count=17}\n``` {.python .cell-code}\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d[2])     # Access the third row (index 2)\nprint(arr2d[0][2])  # Access element at row 0, column 2 (two ways)\nprint(arr2d[0, 2])   # Access element at row 0, column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[7 8 9]\n3\n3\n```\n:::\n:::\n\n\n-   **Thinking about Axes:**\n    -   Axis 0: Rows\n    -   Axis 1: Columns\n\n:::\n\n## Indexing elements in a NumPy array.\n\n::: {style=\"font-size: 0.85em;\"}\n\n\n```{mermaid}\ngraph LR\n    subgraph \"Axis 0 (Rows)\"\n        0 --> 1\n        1 --> 2\n    end\n    subgraph \"Axis 1 (Columns)\"\n        0 --> 0[0,0]\n        0 --> 1[0,1]\n        0 --> 2[0,2]\n        1 --> 3[1,0]\n        1 --> 4[1,1]\n        1 --> 5[1,2]\n    \t2 --> 6[2,0]\n    \t2 --> 7[2,1]\n    \t2 --> 8[2,2]\n    end\n```\n\n\n:::\n\n## Indexing and Slicing: Higher Dimensions (Continued)\n\n::: {style=\"font-size: 0.8em;\"}\n-   **Slicing in Multiple Dimensions:**\n\n::: {#3e1e2285 .cell execution_count=18}\n``` {.python .cell-code}\nprint(arr2d[:2])      # Select the first two rows\nprint(arr2d[:2, 1:])   # Select first two rows, columns from index 1 onwards\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]]\n[[2 3]\n [5 6]]\n```\n:::\n:::\n\n\n-   **Mixing Integer Indexing and Slicing:**\n\n::: {#22305d7f .cell execution_count=19}\n``` {.python .cell-code}\nprint(arr2d[1, :2])   # Select second row, first two columns (lower dimensional slice)\nprint(arr2d[:2, 2])    # Select first two rows, third column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4 5]\n[3 6]\n```\n:::\n:::\n\n\n- **Colon for Entire Axis:**\n\n::: {#736e0384 .cell execution_count=20}\n``` {.python .cell-code}\nprint(arr2d[:, :1])   # Select all rows, but only the first column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]\n [4]\n [7]]\n```\n:::\n:::\n\n\n:::\n\n## Two-dimensional array slicing\n\n::: {style=\"font-size: 0.85em;\"}\n| Expression         | Shape     |  Visualization                                                                              |\n|-------------------|-----------|--------------------------------------------------------------------------------------------|\n| `arr[:2,1:]`      |   (2,2)       |  ```{python}\n#| echo: false\nimport matplotlib.pyplot as plt\nimport numpy as np\n\narr = np.zeros((3,3))\narr[:2,1:] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n\n```    |\n| `arr[2]`          |    (3,)      |  ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[2,:] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```    |\n| `arr[2,:]`          |    (3,)      |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[2,:] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[2:,:]`          |     (1,3)     |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[2:,:] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[:, :2]`          |   (3,2)       |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[:,:2] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[1, :2]`          |     (2,)     |   ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[1,:2] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```   |\n| `arr[1:2, :2]`          |  (1,2)        |  ```{python}\n#| echo: false\narr = np.zeros((3,3))\narr[1:2,:2] = 1\nplt.imshow(arr, cmap='gray_r')\nplt.xticks([])\nplt.yticks([])\nplt.show()\n```    |\n:::\n\n## Boolean Indexing\n\n::: {style=\"font-size: 0.8em;\"}\n- **Concept:**  Select data based on a Boolean array (an array of `True`/`False` values).  The Boolean array typically has the same shape as the array you're indexing.\n\n::: {#c53c0934 .cell execution_count=21}\n``` {.python .cell-code}\nnames = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])\ndata = np.array([[4, 7], [0, 2], [-5, 6], [0, 0], [1, 2],\n                 [-12, -4], [3, 4]])\n\nprint(names == 'Bob')  # Create a Boolean array\nprint(data[names == 'Bob'])  # Select rows where names == 'Bob'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ True False False  True False False False]\n[[4 7]\n [0 0]]\n```\n:::\n:::\n\n\n-   **Combining with Slicing/Indexing:**\n\n::: {#9efc9609 .cell execution_count=22}\n``` {.python .cell-code}\nprint(data[names == 'Bob', 1:])  # Select rows where names == 'Bob', and columns from index 1\nprint(data[names != 'Bob'])     # Select rows where names is NOT 'Bob'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[7]\n [0]]\n[[  0   2]\n [ -5   6]\n [  1   2]\n [-12  -4]\n [  3   4]]\n```\n:::\n:::\n\n\n-   **Logical Operators:**\n    -   `~`: Negates a Boolean array (like `not`)\n    -   `&`:  Combines conditions (like `and`)\n    -   `|`:  Combines conditions (like `or`)\n\n::: {#48d923a0 .cell execution_count=23}\n``` {.python .cell-code}\nmask = (names == 'Bob') | (names == 'Will')\nprint(data[mask])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 4  7]\n [-5  6]\n [ 0  0]\n [ 1  2]]\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\nThe Python keywords and and or do not work with Boolean arrays. Use & (and) and | (or) instead.\n:::\n\n## Fancy Indexing\n\n\n-   **Concept:** Indexing using integer arrays.  Allows you to select specific rows or columns, and even reorder them.\n\n::: {#8622c8d4 .cell execution_count=24}\n``` {.python .cell-code}\narr = np.zeros((8, 4))\nfor i in range(8):\n    arr[i] = i\nprint(arr)\nprint(arr[[4, 3, 0, 6]])  # Select rows 4, 3, 0, and 6, in that order\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0. 0. 0. 0.]\n [1. 1. 1. 1.]\n [2. 2. 2. 2.]\n [3. 3. 3. 3.]\n [4. 4. 4. 4.]\n [5. 5. 5. 5.]\n [6. 6. 6. 6.]\n [7. 7. 7. 7.]]\n[[4. 4. 4. 4.]\n [3. 3. 3. 3.]\n [0. 0. 0. 0.]\n [6. 6. 6. 6.]]\n```\n:::\n:::\n\n\n::: {#ffbce088 .cell execution_count=25}\n``` {.python .cell-code}\narr = np.arange(32).reshape((8, 4))\nprint(arr[[1, 5, 7, 2], [0, 3, 1, 2]]) # Select elements (1, 0), (5, 3), (7, 1), (2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 4 23 29 10]\n```\n:::\n:::\n\n\n-   **Selecting a Rectangular Region:**\n\n::: {#d3970490 .cell execution_count=26}\n``` {.python .cell-code}\nprint(arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]])  # Select rows 1, 5, 7, 2, and reorder columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 4  7  5  6]\n [20 23 21 22]\n [28 31 29 30]\n [ 8 11  9 10]]\n```\n:::\n:::\n\n\n-   **Important:**  *Fancy indexing, unlike slicing, always copies the data into a new array*.\n\n\n\n## Transposing Arrays and Swapping Axes\n\n::: {style=\"font-size: 0.85em;\"}\n-   **Transposing:**  Rearranging data by switching rows and columns.  Use the `.T` attribute or the `transpose` method.\n\n::: {#d04f78b6 .cell execution_count=27}\n``` {.python .cell-code}\narr = np.arange(15).reshape((3, 5))\nprint(arr)\nprint(arr.T)  # Transpose the array\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 0  1  2  3  4]\n [ 5  6  7  8  9]\n [10 11 12 13 14]]\n[[ 0  5 10]\n [ 1  6 11]\n [ 2  7 12]\n [ 3  8 13]\n [ 4  9 14]]\n```\n:::\n:::\n\n\n-   **Matrix Multiplication:**  Use `np.dot` or the `@` operator for matrix multiplication.\n\n::: {#4ea93b8d .cell execution_count=28}\n``` {.python .cell-code}\narr = np.array([[0, 1, 0], [1, 2, -2], [6, 3, 2], [-1, 0, -1], [1, 0, 1]])\nprint(np.dot(arr.T, arr))  # Matrix multiplication\nprint(arr.T @ arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[39 20 12]\n [20 14  2]\n [12  2 10]]\n[[39 20 12]\n [20 14  2]\n [12  2 10]]\n```\n:::\n:::\n\n\n-   **Swapping Axes:**  The `swapaxes` method takes a pair of axis numbers and switches the indicated axes.\n\n::: {#2a8133c3 .cell execution_count=29}\n``` {.python .cell-code}\nprint(arr.swapaxes(0, 1)) # swap axis 0 and axis 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 0  1  6 -1  1]\n [ 1  2  3  0  0]\n [ 0 -2  2 -1  1]]\n```\n:::\n:::\n\n\n:::\n::: {.callout-note appearance=\"simple\"}\nTransposing and `swapaxes` return *views* on the underlying data without making a copy.\n:::\n\n## Pseudorandom Number Generation\n\n::: {style=\"font-size: 0.85em;\"}\n-   **`numpy.random` Module:**  Provides functions to generate arrays of random numbers from various distributions.\n\n-   **`default_rng`:**  The recommended way to create a random number generator.\n\n::: {#a4e2ac51 .cell execution_count=30}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed=12345)  # Create a generator with a seed\ndata = rng.standard_normal((2, 3))       # Generate a 2x3 array of standard normal values\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[-1.42382504  1.26372846 -0.87066174]\n [-0.25917323 -0.07534331 -0.74088465]]\n```\n:::\n:::\n\n\n-   **Why use a seed?**  Setting a seed ensures reproducibility.  You'll get the same random numbers each time you run the code with the same seed.\n\n-   **Generator Isolation:** The generator object `rng` is isolated from other code that might also use the `numpy.random` module.\n\n-   **Performance:** `numpy.random` is *much* faster than Python's built-in `random` module for generating large arrays.\n:::\n\n## Common `numpy.random` Functions\n\n::: {style=\"font-size: 0.75em;\"}\n| Method             | Description                                                                  |\n|----------------------|------------------------------------------------------------------------------|\n| `permutation`      | Returns a random permutation of a sequence, or a permuted range.               |\n| `shuffle`          | Randomly permutes a sequence in place.                                         |\n| `uniform`          | Draws samples from a uniform distribution.                                   |\n| `integers`       | Draws random integers from a given low-to-high range.                      |\n| `standard_normal`  | Draws samples from a standard normal distribution (mean 0, standard deviation 1). |\n| `binomial`         | Draws samples from a binomial distribution.                                  |\n| `normal`           | Draws samples from a normal (Gaussian) distribution.                           |\n| `beta`             | Draws samples from a Beta distribution.                                        |\n| `chisquare`        | Draws samples from a chi-square distribution.                                 |\n| `gamma`            | Draws samples from a gamma distribution.                                      |\n| `uniform`          | Draws samples from a uniform [0, 1) distribution.                              |\n:::\n\n## Universal Functions (ufuncs)\n\n::: {style=\"font-size: 0.85em;\"}\n- **What are ufuncs?**  Functions that perform element-wise operations on ndarrays. They are *fast* vectorized wrappers for simple functions.\n\n- **Unary ufuncs:**  Take a single array as input.\n\n::: {#512926bb .cell execution_count=31}\n``` {.python .cell-code}\narr = np.arange(10)\nprint(np.sqrt(arr))    # Square root of each element\nprint(np.exp(arr))     # Exponential of each element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.         1.         1.41421356 1.73205081 2.         2.23606798\n 2.44948974 2.64575131 2.82842712 3.        ]\n[1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01\n 5.45981500e+01 1.48413159e+02 4.03428793e+02 1.09663316e+03\n 2.98095799e+03 8.10308393e+03]\n```\n:::\n:::\n\n\n- **Binary ufuncs:** Take two arrays as input.\n\n::: {#f4373c86 .cell execution_count=32}\n``` {.python .cell-code}\nx = rng.standard_normal(8)\ny = rng.standard_normal(8)\nprint(np.maximum(x, y))  # Element-wise maximum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-0.46695317  0.6488928   0.78884434 -1.25666813  2.34740965  1.39897899\n  1.32229806  0.90219827]\n```\n:::\n:::\n\n\n- **ufuncs that return multiple arrays:**\n\n::: {#af39d372 .cell execution_count=33}\n``` {.python .cell-code}\narr = rng.standard_normal(7) * 5\nremainder, whole_part = np.modf(arr)  # Returns fractional and integral parts\nprint(remainder)\nprint(whole_part)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0.51459671 -0.10791367 -0.7909463   0.24741966 -0.71800536 -0.40843795\n  0.62369966]\n[ 4. -8. -0.  2. -6. -0.  8.]\n```\n:::\n:::\n\n\n:::\n\n## Some Unary Universal Functions\n\n::: {style=\"font-size: 0.7em;\"}\n| Function        | Description                                                                                   |\n|-----------------|-----------------------------------------------------------------------------------------------|\n| `abs`, `fabs`   | Computes the absolute value element-wise.  `fabs` is faster for non-complex data.             |\n| `sqrt`          | Computes the square root of each element (equivalent to `arr ** 0.5`).                        |\n| `square`        | Computes the square of each element (equivalent to `arr ** 2`).                              |\n| `exp`           | Computes the exponent *e*x of each element.                                                   |\n| `log`, `log10`, `log2`, `log1p` | Natural logarithm (base *e*), log base 10, log base 2, and log(1 + x), respectively.        |\n| `sign`          | Computes the sign of each element: 1 (positive), 0 (zero), or -1 (negative).                   |\n| `ceil`          | Computes the ceiling of each element (smallest integer greater than or equal to that number). |\n| `floor`         | Computes the floor of each element (largest integer less than or equal to each element).    |\n| `rint`          | Rounds elements to the nearest integer, preserving the dtype.                                 |\n| `modf`          | Returns fractional and integral parts of array as separate arrays.                           |\n| `isnan`         | Returns a Boolean array indicating whether each value is NaN (Not a Number).                  |\n| `isfinite`, `isinf` | Returns a Boolean array indicating whether each element is finite or infinite, respectively.  |\n| `cos`, `cosh`, `sin`, `sinh`, `tan`, `tanh` | Regular and hyperbolic trigonometric functions.                                         |\n| `arccos`, `arccosh`, `arcsin`, `arcsinh`, `arctan`, `arctanh` | Inverse trigonometric functions.                     |\n| `logical_not`   | Computes the truth value of `not x` element-wise (equivalent to `~arr`).                      |\n:::\n\n## Some Binary Universal Functions\n\n::: {style=\"font-size: 0.7em;\"}\n| Function            | Description                                                                                                |\n|----------------------|------------------------------------------------------------------------------------------------------------|\n| `add`                | Adds corresponding elements in arrays.                                                                        |\n| `subtract`           | Subtracts elements in second array from first array.                                                           |\n| `multiply`           | Multiplies array elements.                                                                                  |\n| `divide`, `floor_divide` | Divides or floor divides (truncating the remainder).                                                  |\n| `power`              | Raises elements in first array to powers indicated in second array.                                           |\n| `maximum`, `fmax`     | Element-wise maximum. `fmax` ignores NaN.                                                                  |\n| `minimum`, `fmin`     | Element-wise minimum. `fmin` ignores NaN.                                                                  |\n| `mod`                | Element-wise modulus (remainder of division).                                                                |\n| `copysign`           | Copies the sign of values in second argument to values in first argument.                                  |\n| `greater`, `greater_equal`, `less`, `less_equal`, `equal`, `not_equal` | Performs element-wise comparison, yielding a Boolean array.  |\n| `logical_and`, `logical_or`, `logical_xor` | Computes element-wise truth value of logical operations.                                                  |\n:::\n\n## Array-Oriented Programming: Example\n\n::: {style=\"font-size: 0.8em;\"}\nLet's compute the function âˆš(x^2 + y^2) across a grid of values:\n\n::: {#f8da7cc6 .cell execution_count=34}\n``` {.python .cell-code}\npoints = np.arange(-5, 5, 0.01)  # 1000 equally spaced points\nxs, ys = np.meshgrid(points, points)  # Create coordinate matrices\nz = np.sqrt(xs ** 2 + ys ** 2)      # Compute the function\n```\n:::\n\n\nNow, let's visualize the result using Matplotlib:\n\n::: {#0a7c8f9a .cell output-location='slide' execution_count=35}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nplt.imshow(z, cmap=plt.cm.gray, extent=[-5, 5, -5, 5])\nplt.colorbar()\nplt.title(\"Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values\")\n# plt.close('all')\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<>:4: SyntaxWarning: invalid escape sequence '\\s'\n<>:4: SyntaxWarning: invalid escape sequence '\\s'\nC:\\Users\\zwujr\\AppData\\Local\\Temp\\ipykernel_9680\\1319111413.py:4: SyntaxWarning: invalid escape sequence '\\s'\n  plt.title(\"Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values\")\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pandas3ed4_files/figure-html/cell-36-output-2.png){width=480 height=441}\n:::\n:::\n\n\nThis example demonstrates how concise and efficient array-oriented programming can be.\n:::\n\n## Expressing Conditional Logic: `np.where`\n\n::: {style=\"font-size: 0.85em;\"}\n-   **`np.where`:** A vectorized version of the ternary expression `x if condition else y`.\n\n::: {#430602ea .cell execution_count=36}\n``` {.python .cell-code}\nxarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])\nyarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])\ncond = np.array([True, False, True, True, False])\n\nresult = np.where(cond, xarr, yarr)  # Select from xarr if cond is True, otherwise yarr\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1.1 2.2 1.3 1.4 2.5]\n```\n:::\n:::\n\n\n-   **Example:**  Replace positive values in an array with 2, and negative values with -2:\n\n::: {#580806d5 .cell execution_count=37}\n``` {.python .cell-code}\narr = rng.standard_normal((4, 4))\nresult = np.where(arr > 0, 2, -2)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 2  2  2 -2]\n [-2 -2  2  2]\n [-2 -2  2  2]\n [-2  2 -2 -2]]\n```\n:::\n:::\n\n\n:::\n\n## Mathematical and Statistical Methods\n\n::: {style=\"font-size: 0.85em;\"}\nNumPy provides a set of methods for computing statistics on arrays:\n\n::: {#c2d62e8c .cell execution_count=38}\n``` {.python .cell-code}\narr = rng.standard_normal((5, 4))\nprint(arr.mean())       # Mean of all elements\nprint(np.mean(arr))    # Equivalent to arr.mean()\nprint(arr.sum())        # Sum of all elements\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-0.08719744457434529\n-0.08719744457434529\n-1.743948891486906\n```\n:::\n:::\n\n\n-   **Axis Argument:**  Many methods take an optional `axis` argument to compute the statistic along a specific axis:\n\n::: {#1b439887 .cell execution_count=39}\n``` {.python .cell-code}\nprint(arr.mean(axis=1))  # Mean across columns (for each row)\nprint(arr.sum(axis=0))   # Sum down rows (for each column)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0.10899104  0.3280763   0.16502112 -0.66719934 -0.37087634]\n[-1.62923076  1.03990647 -0.33436331 -0.82026129]\n```\n:::\n:::\n\n\n-   **`cumsum` and `cumprod`:**  Compute cumulative sums and products:\n\n::: {#62de6189 .cell execution_count=40}\n``` {.python .cell-code}\narr = np.array([0, 1, 2, 3, 4, 5, 6, 7])\nprint(arr.cumsum())  # Cumulative sum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0  1  3  6 10 15 21 28]\n```\n:::\n:::\n\n\n:::\n\n## Basic Array Statistical Methods\n\n::: {style=\"font-size: 0.8em;\"}\n| Method             | Description                                                                               |\n|----------------------|-------------------------------------------------------------------------------------------|\n| `sum`                | Sum of all the elements in the array or along an axis; zero-length arrays have sum 0.    |\n| `mean`               | Arithmetic mean; invalid (returns NaN) on zero-length arrays.                           |\n| `std`, `var`         | Standard deviation and variance, respectively.                                            |\n| `min`,`max`          | Minimum and maximum.                                                                      |\n| `argmin`, `argmax` | Indices of minimum and maximum elements, respectively.                                   |\n| `cumsum`             | Cumulative sum of elements starting from 0.                                               |\n| `cumprod`            | Cumulative product of elements starting from 1.                                             |\n:::\n\n## Methods for Boolean Arrays\n\n::: {style=\"font-size: 0.9em;\"}\n-   **`sum` with Booleans:**  `True` values are treated as 1, `False` as 0.  Useful for counting `True` values.\n\n::: {#d4208c85 .cell execution_count=41}\n``` {.python .cell-code}\narr = rng.standard_normal(100)\nprint((arr > 0).sum())  # Count positive values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n48\n```\n:::\n:::\n\n\n-   **`any` and `all`:**\n    -   `any`:  Checks if *at least one* value in a Boolean array is `True`.\n    -   `all`:  Checks if *all* values in a Boolean array are `True`.\n\n::: {#95815e6a .cell execution_count=42}\n``` {.python .cell-code}\nbools = np.array([False, False, True, False])\nprint(bools.any())  # Is there at least one True?\nprint(bools.all())  # Are all values True?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n```\n:::\n:::\n\n\n:::\n\n## Sorting\n\n::: {style=\"font-size: 0.9em;\"}\n-   **`sort` Method:**  Sorts an array *in place*.\n\n::: {#cf312a78 .cell execution_count=43}\n``` {.python .cell-code}\narr = rng.standard_normal(6)\narr.sort()  # Sort the array in place\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-0.72083767 -0.68391322 -0.08241372 -0.05481416  0.07726066  1.12062282]\n```\n:::\n:::\n\n\n-   **Sorting Along an Axis:**\n\n::: {#cf1342f7 .cell execution_count=44}\n``` {.python .cell-code}\narr = rng.standard_normal((5, 3))\narr.sort(axis=0)  # Sort within each column\nprint(arr)\narr.sort(axis=1) # Sort within each row\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[-2.05280763 -0.05032522  0.28931754]\n [ 0.17930568 -0.02788771  0.29204679]\n [ 0.40589222  0.38050908  0.75539067]\n [ 0.63840567  1.23853712  1.27279553]\n [ 0.9359865   1.39748056  1.37105185]]\n[[-2.05280763 -0.05032522  0.28931754]\n [-0.02788771  0.17930568  0.29204679]\n [ 0.38050908  0.40589222  0.75539067]\n [ 0.63840567  1.23853712  1.27279553]\n [ 0.9359865   1.37105185  1.39748056]]\n```\n:::\n:::\n\n\n- **`np.sort` Function:** Returns a *sorted copy* of an array (does not modify the original).\n:::\n\n## Unique and Other Set Logic\n\n::: {style=\"font-size: 0.9em;\"}\n\n-   **`np.unique`:**  Returns the sorted unique values in an array.\n\n::: {#a5d9c49f .cell execution_count=45}\n``` {.python .cell-code}\nnames = np.array(['Bob', 'Will', 'Joe', 'Bob', 'Will', 'Joe', 'Joe'])\nprint(np.unique(names)) # Get unique names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Bob' 'Joe' 'Will']\n```\n:::\n:::\n\n\n-   **`np.in1d`:**  Tests membership of values in one array within another.\n\n::: {#047aac9e .cell execution_count=46}\n``` {.python .cell-code}\nvalues = np.array([6, 0, 0, 3, 2, 5, 6])\nprint(np.in1d(values, [2, 3, 6]))  # Check if each value in 'values' is in [2, 3, 6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ True False False  True  True False  True]\n```\n:::\n:::\n\n\n:::\n\n## Array Set Operations\n\n::: {style=\"font-size: 0.85em;\"}\n| Method         | Description                                                                     |\n|-----------------|---------------------------------------------------------------------------------|\n| `unique(x)`     | Computes the sorted, unique elements in x.                                     |\n| `intersect1d(x, y)` | Computes the sorted, common elements in x and y.                            |\n| `union1d(x, y)`    | Computes the sorted union of elements.                                         |\n| `in1d(x, y)`       | Computes a Boolean array indicating whether each element of x is in y.        |\n| `setdiff1d(x, y)`  | Set difference: elements in x that are not in y.                             |\n| `setxor1d(x, y)`   | Set symmetric differences; elements that are in either of the arrays, but not both. |\n:::\n\n## File Input and Output with Arrays\n\n::: {style=\"font-size: 0.85em;\"}\n\n-   **`np.save` and `np.load`:**  Functions for saving and loading arrays in NumPy's binary format (`.npy`).\n\n::: {#7a196a09 .cell execution_count=47}\n``` {.python .cell-code}\narr = np.arange(10)\nnp.save('some_array', arr)  # Save to 'some_array.npy'\nloaded_arr = np.load('some_array.npy')  # Load from 'some_array.npy'\nprint(loaded_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5 6 7 8 9]\n```\n:::\n:::\n\n\n-   **`np.savez`:** Saves multiple arrays into an uncompressed archive (`.npz`).\n\n::: {#37c8ea67 .cell execution_count=48}\n``` {.python .cell-code}\nnp.savez('array_archive.npz', a=arr, b=arr)  # Save multiple arrays\narch = np.load('array_archive.npz')        # Load the archive\nprint(arch['b'])  # Access arrays by name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5 6 7 8 9]\n```\n:::\n:::\n\n\n-   **`np.savez_compressed`:** Saves multiple arrays into a *compressed* archive.\n:::\n\n## Linear Algebra\n\n::: {style=\"font-size: 0.9em;\"}\n-   **`numpy.linalg` Module:**  Provides functions for linear algebra operations.\n-   **Matrix Multiplication:**\n\n::: {#ee630a1d .cell execution_count=49}\n``` {.python .cell-code}\nx = np.array([[1., 2., 3.], [4., 5., 6.]])\ny = np.array([[6., 23.], [-1, 7], [8, 9]])\nprint(x.dot(y))        # Matrix multiplication (method)\nprint(np.dot(x, y))    # Matrix multiplication (function)\nprint( x @ np.ones(3)) # Matrix multiplication using the @ operator\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 28.  64.]\n [ 67. 181.]]\n[[ 28.  64.]\n [ 67. 181.]]\n[ 6. 15.]\n```\n:::\n:::\n\n\n-   **Inverse and Determinant:**\n\n::: {#8cb6914d .cell execution_count=50}\n``` {.python .cell-code}\nfrom numpy.linalg import inv, qr\nX = rng.standard_normal((5, 5))\nmat = X.T @ X\nprint(inv(mat))   # Inverse of a matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[  3.49932285   2.84436268   3.59557002 -16.55376878   4.47325573]\n [  2.84436268   2.56666253   2.9001963  -13.57742      3.76776505]\n [  3.59557002   2.9001963    4.48232906 -18.34525499   4.70660032]\n [-16.55376878 -13.57742    -18.34525499  84.01018808 -22.04840478]\n [  4.47325573   3.76776505   4.70660032 -22.04840478   6.05251342]]\n```\n:::\n:::\n\n\n:::\n\n## Commonly Used `numpy.linalg` Functions\n\n::: {style=\"font-size: 0.7em;\"}\n| Function     | Description                                                                                           |\n|--------------|-------------------------------------------------------------------------------------------------------|\n| `diag`       | Returns the diagonal (or off-diagonal) elements of a square matrix as a 1D array, or converts a 1D array to a square matrix. |\n| `dot`        | Matrix multiplication.                                                                              |\n| `trace`      | Computes the sum of the diagonal elements.                                                           |\n| `det`        | Computes the matrix determinant.                                                                     |\n| `eig`        | Computes the eigenvalues and eigenvectors of a square matrix.                                         |\n| `inv`        | Computes the inverse of a square matrix.                                                             |\n| `pinv`       | Computes the Moore-Penrose pseudoinverse of a matrix.                                                |\n| `qr`         | Computes the QR decomposition.                                                                     |\n| `svd`        | Computes the singular value decomposition (SVD).                                                     |\n| `solve`      | Solves the linear system Ax = b for x, where A is a square matrix.                                 |\n| `lstsq`      | Computes the least-squares solution to Ax = b.                                                      |\n:::\n\n## Example: Random Walks\n\n::: {style=\"font-size: 0.9em;\"}\nLet's simulate a simple random walk using NumPy:\n\n::: {#88d1fc50 .cell execution_count=51}\n``` {.python .cell-code}\nnsteps = 1000\nrng = np.random.default_rng(seed=12345)\ndraws = rng.integers(0, 2, size=nsteps)  # Generate 0s and 1s (coin flips)\nsteps = np.where(draws == 0, 1, -1)      # Convert to 1 and -1\nwalk = steps.cumsum()                    # Cumulative sum (the walk)\n```\n:::\n\n\nFirst 100 steps of a simple random walk:\n\n::: {#f1f615c8 .cell output-location='slide' execution_count=52}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nplt.plot(walk[:100])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas3ed4_files/figure-html/cell-53-output-1.png){width=582 height=411}\n:::\n:::\n\n\n:::\n\n## Random Walks: Analysis\n\n::: {style=\"font-size: 0.85em;\"}\n\nWe can analyze the random walk:\n\n::: {#06111d8a .cell execution_count=53}\n``` {.python .cell-code}\nprint(walk.min())  # Minimum value\nprint(walk.max())  # Maximum value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-8\n50\n```\n:::\n:::\n\n\n- **First Crossing Time:**  The step at which the walk reaches a particular value.\n\n::: {#e81e0194 .cell execution_count=54}\n``` {.python .cell-code}\nprint((np.abs(walk) >= 10).argmax())  # Find the first step where the absolute value is >= 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n155\n```\n:::\n:::\n\n\n:::\n::: {.callout-note appearance=\"simple\"}\nusing `argmax` here is not always efficient because it always makes a full scan of the array. In this special case, once a `True` is observed we know it to be the maximum value.\n:::\n\n## Simulating Many Random Walks at Once\n\n::: {style=\"font-size: 0.85em;\"}\n\nWe can efficiently simulate many random walks simultaneously:\n\n::: {#5617d2c4 .cell execution_count=55}\n``` {.python .cell-code}\nnwalks = 5000\nnsteps = 1000\ndraws = rng.integers(0, 2, size=(nwalks, nsteps))  # Generate draws for all walks\nsteps = np.where(draws > 0, 1, -1)\nwalks = steps.cumsum(axis=1)                     # Cumulative sum for each walk\n```\n:::\n\n\nThen, for example, calculate the average minimum crossing time:\n\n::: {#23512392 .cell execution_count=56}\n``` {.python .cell-code}\nhits30 = (np.abs(walks) >= 30).any(axis=1)\ncrossing_times = (np.abs(walks[hits30]) >= 30).argmax(axis=1)\nprint(crossing_times.mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n500.5699558173785\n```\n:::\n:::\n\n\n:::\n::: {.callout-note appearance=\"simple\"}\nthis vectorized approach requires creating an array with nwalks * nsteps elements, which may use a large amount of memory for large simulations. If memory is more constrained, then a different approach will be required.\n:::\n\n## Summary\n\n::: {style=\"font-size: 0.85em;\"}\n-   **NumPy's Power:** NumPy provides a powerful foundation for numerical computing in Python, thanks to its efficient `ndarray` and vectorized operations.\n\n-   **Key Concepts:**\n    -   `ndarray`:  Multidimensional array with homogeneous data.\n    -   `dtype`:  Data type of array elements.\n    -   Vectorization:  Performing operations on entire arrays without loops.\n    -   Broadcasting:  Arithmetic operations on arrays of different shapes.\n    -   Indexing and Slicing:  Accessing and modifying array elements and subarrays.\n    -   Fancy Indexing:  Indexing with integer arrays.\n    -   Transposing: Rearranging data.\n    -   ufuncs:  Fast element-wise functions.\n    -   `numpy.random`:  Generating arrays of random numbers.\n    -  Linear Algebra\n\n-   **Efficiency:** NumPy is designed for performance, especially with large datasets.\n:::\n\n## Thoughts and Discussion ðŸ¤”\n\n::: {style=\"font-size: 0.85em;\"}\n-   How does the concept of vectorization in NumPy compare to how you might perform similar operations in other programming languages you know?\n\n-   Can you think of specific data analysis tasks where NumPy's array-oriented approach would be significantly more efficient than using Python lists and loops?\n\n-   What are the advantages and potential disadvantages of NumPy array slices being *views* rather than copies? When might you need to explicitly create a copy?\n\n-   Consider the `np.where` function.  How could you use it to implement more complex conditional logic than the simple examples we saw?\n\n-   Why is it important to understand NumPy's data types (`dtypes`)?  How can they impact performance and memory usage?\n\n-   Discuss scenarios where you might use NumPy's linear algebra functions (e.g., `dot`, `inv`, `eig`).\n:::\n\n",
    "supporting": [
      "pandas3ed4_files"
    ],
    "filters": [],
    "includes": {}
  }
}